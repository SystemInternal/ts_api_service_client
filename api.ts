/* tslint:disable */
/* eslint-disable */
/**
 * System REST API
 *  This page provides documentation for the System REST API.  If you have any questions or need support, please contact us at the email provided.  ## Formatting query parameters  Filters should be formatted as `field:value` and use the logical OR operator `||` to specify an OR condition. (We\'ve deprecated the pipe operator for OR conditions.)   If they are numerical, they should be formatted as `field:opvalue`. Examples: - `doi:10.1234/5678|10.8765/4321` - `num_findings:>2`  Sorts should be formatted as `field:direction`. Examples: - `cited_by:desc` - `publish_date:asc`  Searches should be formatted as `field:value`. Examples: - `name:osteoporosis` 
 *
 * The version of the OpenAPI document: 0.1.0
 * Contact: api@system.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * Author.
 * @export
 * @interface Author
 */
export interface Author {
    /**
     * Full name of author
     * @type {string}
     * @memberof Author
     */
    'full_name': string;
    /**
     * 
     * @type {string}
     * @memberof Author
     */
    'orcid'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Author
     */
    'openalex_id'?: string | null;
}
/**
 * Type of finding.
 * @export
 * @enum {string}
 */

export const FindingType = {
    Statistical: 'statistical',
    Mechanistic: 'mechanistic'
} as const;

export type FindingType = typeof FindingType[keyof typeof FindingType];


/**
 * Flag.
 * @export
 * @interface Flag
 */
export interface Flag {
    /**
     * 
     * @type {string}
     * @memberof Flag
     */
    'flagged_property': string;
    /**
     * 
     * @type {string}
     * @memberof Flag
     */
    'reason'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Flag
     */
    'resource_id': string;
    /**
     * 
     * @type {string}
     * @memberof Flag
     */
    'system_id': string;
}
/**
 * Flag input.
 * @export
 * @interface FlagInput
 */
export interface FlagInput {
    /**
     * 
     * @type {string}
     * @memberof FlagInput
     */
    'flagged_property': string;
    /**
     * 
     * @type {string}
     * @memberof FlagInput
     */
    'reason'?: string | null;
}
/**
 * Graph response.
 * @export
 * @interface GraphResponse
 */
export interface GraphResponse {
    /**
     * 
     * @type {Array<Node>}
     * @memberof GraphResponse
     */
    'nodes': Array<Node>;
    /**
     * 
     * @type {Array<Link>}
     * @memberof GraphResponse
     */
    'links': Array<Link>;
}
/**
 * 
 * @export
 * @interface HTTPValidationError
 */
export interface HTTPValidationError {
    /**
     * 
     * @type {Array<ValidationError>}
     * @memberof HTTPValidationError
     */
    'detail'?: Array<ValidationError>;
}
/**
 * Status of a pubmed search synthesis job.
 * @export
 * @enum {string}
 */

export const JobStatus = {
    Accepted: 'accepted',
    Clustering: 'clustering',
    ClusteringFailed: 'clustering_failed',
    ClusteringFailedNoStatements: 'clustering_failed_no_statements',
    Synthesizing: 'synthesizing',
    SynthesisNotExists: 'synthesis_not_exists',
    SynthesisSubmitted: 'synthesis_submitted',
    SynthesisRunning: 'synthesis_running',
    SynthesisSuccess: 'synthesis_success',
    SynthesisFailed: 'synthesis_failed',
    SynthesisFailedNoCitations: 'synthesis_failed_no_citations',
    SynthesisFailedValidation: 'synthesis_failed_validation'
} as const;

export type JobStatus = typeof JobStatus[keyof typeof JobStatus];


/**
 * Link.
 * @export
 * @interface Link
 */
export interface Link {
    /**
     * 
     * @type {string}
     * @memberof Link
     */
    'source': string;
    /**
     * 
     * @type {string}
     * @memberof Link
     */
    'target': string;
}
/**
 * 
 * @export
 * @interface ListResponseMechanisticFinding
 */
export interface ListResponseMechanisticFinding {
    /**
     * 
     * @type {Array<MechanisticFinding>}
     * @memberof ListResponseMechanisticFinding
     */
    'data': Array<MechanisticFinding>;
    /**
     * 
     * @type {number}
     * @memberof ListResponseMechanisticFinding
     */
    'total'?: number | null;
}
/**
 * 
 * @export
 * @interface ListResponseRelationship
 */
export interface ListResponseRelationship {
    /**
     * 
     * @type {Array<Relationship>}
     * @memberof ListResponseRelationship
     */
    'data': Array<Relationship>;
    /**
     * 
     * @type {number}
     * @memberof ListResponseRelationship
     */
    'total'?: number | null;
}
/**
 * 
 * @export
 * @interface ListResponseStatement
 */
export interface ListResponseStatement {
    /**
     * 
     * @type {Array<Statement>}
     * @memberof ListResponseStatement
     */
    'data': Array<Statement>;
    /**
     * 
     * @type {number}
     * @memberof ListResponseStatement
     */
    'total'?: number | null;
}
/**
 * 
 * @export
 * @interface ListResponseStatisticalFinding
 */
export interface ListResponseStatisticalFinding {
    /**
     * 
     * @type {Array<StatisticalFinding>}
     * @memberof ListResponseStatisticalFinding
     */
    'data': Array<StatisticalFinding>;
    /**
     * 
     * @type {number}
     * @memberof ListResponseStatisticalFinding
     */
    'total'?: number | null;
}
/**
 * 
 * @export
 * @interface ListResponseStudy
 */
export interface ListResponseStudy {
    /**
     * 
     * @type {Array<Study>}
     * @memberof ListResponseStudy
     */
    'data': Array<Study>;
    /**
     * 
     * @type {number}
     * @memberof ListResponseStudy
     */
    'total'?: number | null;
}
/**
 * 
 * @export
 * @interface ListResponseTopic
 */
export interface ListResponseTopic {
    /**
     * 
     * @type {Array<Topic>}
     * @memberof ListResponseTopic
     */
    'data': Array<Topic>;
    /**
     * 
     * @type {number}
     * @memberof ListResponseTopic
     */
    'total'?: number | null;
}
/**
 * 
 * @export
 * @interface ListResponseTopicPath
 */
export interface ListResponseTopicPath {
    /**
     * 
     * @type {Array<TopicPath>}
     * @memberof ListResponseTopicPath
     */
    'data': Array<TopicPath>;
    /**
     * 
     * @type {number}
     * @memberof ListResponseTopicPath
     */
    'total'?: number | null;
}
/**
 * 
 * @export
 * @interface ListResponseVariable
 */
export interface ListResponseVariable {
    /**
     * 
     * @type {Array<Variable>}
     * @memberof ListResponseVariable
     */
    'data': Array<Variable>;
    /**
     * 
     * @type {number}
     * @memberof ListResponseVariable
     */
    'total'?: number | null;
}
/**
 * Mechanistic finding.
 * @export
 * @interface MechanisticFinding
 */
export interface MechanisticFinding {
    /**
     * Unique identifier
     * @type {string}
     * @memberof MechanisticFinding
     */
    'id': string;
    /**
     * Whether finding is flagged
     * @type {boolean}
     * @memberof MechanisticFinding
     */
    'flagged'?: boolean;
    /**
     * Type of finding
     * @type {string}
     * @memberof MechanisticFinding
     */
    'finding_type'?: MechanisticFindingFindingTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof MechanisticFinding
     */
    'summary'?: string | null;
    /**
     * 
     * @type {NestedResource}
     * @memberof MechanisticFinding
     */
    'topic_1'?: NestedResource | null;
    /**
     * 
     * @type {NestedResource}
     * @memberof MechanisticFinding
     */
    'topic_2'?: NestedResource | null;
    /**
     * Source variable of the finding
     * @type {NestedResource}
     * @memberof MechanisticFinding
     */
    'variable_1'?: NestedResource;
    /**
     * Target variable of the finding
     * @type {NestedResource}
     * @memberof MechanisticFinding
     */
    'variable_2'?: NestedResource;
    /**
     * Study supporting the finding
     * @type {NestedStudy}
     * @memberof MechanisticFinding
     */
    'study'?: NestedStudy;
    /**
     * 
     * @type {string}
     * @memberof MechanisticFinding
     */
    'mechanism_type'?: string | null;
}

export const MechanisticFindingFindingTypeEnum = {
    Mechanistic: 'mechanistic'
} as const;

export type MechanisticFindingFindingTypeEnum = typeof MechanisticFindingFindingTypeEnum[keyof typeof MechanisticFindingFindingTypeEnum];

/**
 * Nested resource.
 * @export
 * @interface NestedResource
 */
export interface NestedResource {
    /**
     * Unique identifier
     * @type {string}
     * @memberof NestedResource
     */
    'id': string;
    /**
     * Name of the resource
     * @type {string}
     * @memberof NestedResource
     */
    'name': string;
}
/**
 * Nested study.
 * @export
 * @interface NestedStudy
 */
export interface NestedStudy {
    /**
     * Unique identifier
     * @type {string}
     * @memberof NestedStudy
     */
    'id': string;
    /**
     * Digital Object Identifier (DOI)
     * @type {string}
     * @memberof NestedStudy
     */
    'doi'?: string;
    /**
     * Population studied
     * @type {string}
     * @memberof NestedStudy
     */
    'population'?: string;
    /**
     * Sample size of the study
     * @type {string}
     * @memberof NestedStudy
     */
    'sample_size'?: string;
}
/**
 * Node.
 * @export
 * @interface Node
 */
export interface Node {
    /**
     * 
     * @type {string}
     * @memberof Node
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Node
     */
    'label'?: string | null;
}
/**
 * Pubmed search synthesis input.
 * @export
 * @interface PubmedSearchSynthesisInput
 */
export interface PubmedSearchSynthesisInput {
    /**
     * 
     * @type {string}
     * @memberof PubmedSearchSynthesisInput
     */
    'query': string;
}
/**
 * Pubmed search synthesis job.
 * @export
 * @interface PubmedSearchSynthesisJob
 */
export interface PubmedSearchSynthesisJob {
    /**
     * Unique identifier of a Pubmed search synthesis job
     * @type {string}
     * @memberof PubmedSearchSynthesisJob
     */
    'id': string;
    /**
     * Status of job
     * @type {JobStatus}
     * @memberof PubmedSearchSynthesisJob
     */
    'status': JobStatus;
    /**
     * Date job was created
     * @type {string}
     * @memberof PubmedSearchSynthesisJob
     */
    'created_at': string;
    /**
     * Date job was last updated
     * @type {string}
     * @memberof PubmedSearchSynthesisJob
     */
    'updated_at': string;
    /**
     * Initial user query
     * @type {string}
     * @memberof PubmedSearchSynthesisJob
     */
    'user_query': string;
    /**
     * Pubmed query the user query resolved to
     * @type {string}
     * @memberof PubmedSearchSynthesisJob
     */
    'pubmed_query': string;
    /**
     * 
     * @type {string}
     * @memberof PubmedSearchSynthesisJob
     */
    'clustering_finished'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PubmedSearchSynthesisJob
     */
    'synthesis_finished'?: string | null;
}


/**
 * Relationship.
 * @export
 * @interface Relationship
 */
export interface Relationship {
    /**
     * Unique identifier of relationship.
     * @type {string}
     * @memberof Relationship
     */
    'id': string;
    /**
     * Number of findings on relationship
     * @type {number}
     * @memberof Relationship
     */
    'num_findings': number;
    /**
     * Number of studies supporting relationship
     * @type {number}
     * @memberof Relationship
     */
    'num_studies': number;
    /**
     * Number of significant findings on relationship
     * @type {number}
     * @memberof Relationship
     */
    'num_significant_findings': number;
    /**
     * Highest cited study supporting relationship
     * @type {number}
     * @memberof Relationship
     */
    'highest_cited'?: number;
    /**
     * 
     * @type {number}
     * @memberof Relationship
     */
    'median_effect_size'?: number | null;
    /**
     * Date relationship was last updated
     * @type {string}
     * @memberof Relationship
     */
    'last_updated': string;
    /**
     * Whether or not the relationship is supported by an experimental trial
     * @type {boolean}
     * @memberof Relationship
     */
    'has_experimental_trial': boolean;
    /**
     * Unique identifier of the source topic
     * @type {Topic}
     * @memberof Relationship
     */
    'source_topic': Topic;
    /**
     * Unique identifier of the target topic
     * @type {Topic}
     * @memberof Relationship
     */
    'target_topic': Topic;
}
/**
 * Statements generated from aggregated findings.
 * @export
 * @interface Statement
 */
export interface Statement {
    /**
     * 
     * @type {string}
     * @memberof Statement
     */
    'summary': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Statement
     */
    'finding_ids': Array<string>;
    /**
     * 
     * @type {FindingType}
     * @memberof Statement
     */
    'finding_type': FindingType;
}


/**
 * Statistic type.
 * @export
 * @enum {string}
 */

export const StatisticType = {
    OddsRatio: 'odds_ratio',
    AdjustedOddsRatio: 'adjusted_odds_ratio',
    HazardRatio: 'hazard_ratio',
    AdjustedHazardRatio: 'adjusted_hazard_ratio',
    RelativeRiskRatio: 'relative_risk_ratio',
    Coefficient: 'coefficient',
    PearsonR: 'pearson_r',
    IncidentRateRatio: 'incident_rate_ratio',
    PrevalenceRatio: 'prevalence_ratio',
    SpearmanCorrelation: 'spearman_correlation',
    MeanDifferenceStandardized: 'mean_difference_standardized',
    MeanDifferenceUnstandardized: 'mean_difference_unstandardized',
    RiskDifference: 'risk_difference',
    CoefficientOfDetermination: 'coefficient_of_determination',
    TTest: 't_test',
    Elasticity: 'elasticity',
    GiniCoefficient: 'gini_coefficient'
} as const;

export type StatisticType = typeof StatisticType[keyof typeof StatisticType];


/**
 * Statistical finding.
 * @export
 * @interface StatisticalFinding
 */
export interface StatisticalFinding {
    /**
     * Unique identifier
     * @type {string}
     * @memberof StatisticalFinding
     */
    'id': string;
    /**
     * Whether finding is flagged
     * @type {boolean}
     * @memberof StatisticalFinding
     */
    'flagged'?: boolean;
    /**
     * Type of finding
     * @type {string}
     * @memberof StatisticalFinding
     */
    'finding_type'?: StatisticalFindingFindingTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof StatisticalFinding
     */
    'summary'?: string | null;
    /**
     * 
     * @type {NestedResource}
     * @memberof StatisticalFinding
     */
    'topic_1'?: NestedResource | null;
    /**
     * 
     * @type {NestedResource}
     * @memberof StatisticalFinding
     */
    'topic_2'?: NestedResource | null;
    /**
     * Source variable of the finding
     * @type {NestedResource}
     * @memberof StatisticalFinding
     */
    'variable_1'?: NestedResource;
    /**
     * Target variable of the finding
     * @type {NestedResource}
     * @memberof StatisticalFinding
     */
    'variable_2'?: NestedResource;
    /**
     * Study supporting the finding
     * @type {NestedStudy}
     * @memberof StatisticalFinding
     */
    'study'?: NestedStudy;
    /**
     * 
     * @type {StatisticType}
     * @memberof StatisticalFinding
     */
    'statistic_type'?: StatisticType | null;
    /**
     * 
     * @type {number}
     * @memberof StatisticalFinding
     */
    'statistic_value'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof StatisticalFinding
     */
    'ci_upper'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof StatisticalFinding
     */
    'ci_lower'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof StatisticalFinding
     */
    'p_value'?: number | null;
}

export const StatisticalFindingFindingTypeEnum = {
    Statistical: 'statistical'
} as const;

export type StatisticalFindingFindingTypeEnum = typeof StatisticalFindingFindingTypeEnum[keyof typeof StatisticalFindingFindingTypeEnum];

/**
 * Study.
 * @export
 * @interface Study
 */
export interface Study {
    /**
     * Unique identifier
     * @type {string}
     * @memberof Study
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Study
     */
    'doi'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Study
     */
    'title'?: string | null;
    /**
     * 
     * @type {Array<Author>}
     * @memberof Study
     */
    'authors'?: Array<Author> | null;
    /**
     * 
     * @type {string}
     * @memberof Study
     */
    'journal'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Study
     */
    'publish_date'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Study
     */
    'population'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Study
     */
    'sample_size'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof Study
     */
    'summary'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Study
     */
    'cited_by'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof Study
     */
    'study_type'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Study
     */
    'retraction_reason'?: string | null;
}
/**
 * Synthesis response.
 * @export
 * @interface Synthesis
 */
export interface Synthesis {
    /**
     * Thematic summaries of the findings.
     * @type {Array<{ [key: string]: string; }>}
     * @memberof Synthesis
     */
    'summaries': Array<{ [key: string]: string; }>;
}
/**
 * Topic.
 * @export
 * @interface Topic
 */
export interface Topic {
    /**
     * Unique identifier
     * @type {string}
     * @memberof Topic
     */
    'id': string;
    /**
     * Name of the topic
     * @type {string}
     * @memberof Topic
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Topic
     */
    'wikidata_id'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof Topic
     */
    'umls_cuis'?: Array<string> | null;
    /**
     * 
     * @type {TopicCategory}
     * @memberof Topic
     */
    'category'?: TopicCategory | null;
    /**
     * 
     * @type {Array<TopicRole>}
     * @memberof Topic
     */
    'roles'?: Array<TopicRole> | null;
}


/**
 * Topic category.
 * @export
 * @enum {string}
 */

export const TopicCategory = {
    BiomedicalDiseasesDisorders: 'Biomedical - Diseases & Disorders',
    BiomedicalHospitalization: 'Biomedical - Hospitalization',
    BiomedicalMortalitySurvival: 'Biomedical - Mortality/survival',
    BiomedicalPathogen: 'Biomedical - Pathogen',
    BiomedicalEthnicity: 'Biomedical - Ethnicity',
    BiomedicalOtherBiologicalFactors: 'Biomedical - Other Biological factors',
    BiomedicalAnthropometry: 'Biomedical - Anthropometry',
    BiomedicalAge: 'Biomedical - Age',
    BiomedicalSex: 'Biomedical - Sex',
    BiomedicalCarcinogen: 'Biomedical - Carcinogen',
    BiomedicalGenetics: 'Biomedical - Genetics',
    BehavioralPersonalHygiene: 'Behavioral - Personal hygiene',
    BehavioralOtherDietaryFactors: 'Behavioral - Other dietary factors',
    BehavioralStress: 'Behavioral - Stress',
    BehavioralSubstanceUse: 'Behavioral - Substance Use',
    BehavioralEatingBehaviors: 'Behavioral - Eating behaviors',
    BehavioralSleep: 'Behavioral - Sleep',
    BehavioralPhysicalActivity: 'Behavioral - Physical activity',
    BehavioralOtherBehavioralFactors: 'Behavioral - Other behavioral factors',
    BehavioralSexualBehavior: 'Behavioral - Sexual behavior',
    EnvironmentalAirQuality: 'Environmental - Air quality',
    EnvironmentalWaterQuality: 'Environmental - Water quality',
    EnvironmentalWeatherAndClimateChange: 'Environmental - Weather and climate change',
    EnvironmentalOtherEnvironmentalFactors: 'Environmental - Other Environmental factors',
    SocialEducation: 'Social - Education',
    SocialEconomicContext: 'Social - Economic context',
    SocialOtherSocialFactors: 'Social - Other social factors',
    SocialPhysicalInfrastructure: 'Social - Physical infrastructure',
    SocialSocialContext: 'Social - Social context',
    SocialHealthcareContext: 'Social - Healthcare context',
    SocialOccupation: 'Social - Occupation',
    SocialGeography: 'Social - Geography',
    SocialOccupationalContext: 'Social - Occupational context',
    Healing: 'Healing',
    Preventative: 'Preventative',
    Diagnostic: 'Diagnostic',
    Preservative: 'Preservative',
    Managing: 'Managing',
    Therapeutic: 'Therapeutic',
    Other: 'Other'
} as const;

export type TopicCategory = typeof TopicCategory[keyof typeof TopicCategory];


/**
 * Path to topic.
 * @export
 * @interface TopicPath
 */
export interface TopicPath {
    /**
     * Unique identifier of relationship.
     * @type {string}
     * @memberof TopicPath
     */
    'id': string;
    /**
     * Number of findings on relationship
     * @type {number}
     * @memberof TopicPath
     */
    'num_findings': number;
    /**
     * Number of studies supporting relationship
     * @type {number}
     * @memberof TopicPath
     */
    'num_studies': number;
    /**
     * Number of significant findings on relationship
     * @type {number}
     * @memberof TopicPath
     */
    'num_significant_findings': number;
    /**
     * Highest cited study supporting relationship
     * @type {number}
     * @memberof TopicPath
     */
    'highest_cited'?: number;
    /**
     * 
     * @type {number}
     * @memberof TopicPath
     */
    'median_effect_size'?: number | null;
    /**
     * Date relationship was last updated
     * @type {string}
     * @memberof TopicPath
     */
    'last_updated': string;
    /**
     * Whether or not the relationship is supported by an experimental trial
     * @type {boolean}
     * @memberof TopicPath
     */
    'has_experimental_trial': boolean;
    /**
     * Topic in path
     * @type {Topic}
     * @memberof TopicPath
     */
    'topic': Topic;
}
/**
 * Topic role.
 * @export
 * @enum {string}
 */

export const TopicRole = {
    Determinant: 'Determinant',
    Intervention: 'Intervention',
    Outcome: 'Outcome',
    Agent: 'Agent'
} as const;

export type TopicRole = typeof TopicRole[keyof typeof TopicRole];


/**
 * 
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
    /**
     * 
     * @type {Array<ValidationErrorLocInner>}
     * @memberof ValidationError
     */
    'loc': Array<ValidationErrorLocInner>;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface ValidationErrorLocInner
 */
export interface ValidationErrorLocInner {
}
/**
 * Variable.
 * @export
 * @interface Variable
 */
export interface Variable {
    /**
     * Unique identifier
     * @type {string}
     * @memberof Variable
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Variable
     */
    'name'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Variable
     */
    'num_studies'?: number | null;
    /**
     * 
     * @type {NestedResource}
     * @memberof Variable
     */
    'topic'?: NestedResource | null;
}

/**
 * GraphApi - axios parameter creator
 * @export
 */
export const GraphApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Gets a subgraph of a topic by id.         The subgraph includes upstream and downstream relationships within two hops.         If the response takes too long or is too large, consider using filters to reduce the size of the response.
         * @summary Get subgraph by topic id
         * @param {string} topicId 
         * @param {string | null} [upstream1Filter] Fields and values to filter the first upstream relationship. Supported fields for filtering: id, num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial, topic.id, topic.wikidata_id, topic.category, topic.roles.
         * @param {string | null} [upstream2Filter] Fields and values to filter the second upstream relationship. Supported fields for filtering: id, num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial, topic.id, topic.wikidata_id, topic.category, topic.roles.
         * @param {string | null} [downstream1Filter] Fields and values to filter the first downstream relationship. Supported fields for filtering: id, num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial, topic.id, topic.wikidata_id, topic.category, topic.roles.
         * @param {string | null} [downstream2Filter] Fields and values to filter the second downstream relationship. Supported fields for filtering: id, num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial, topic.id, topic.wikidata_id, topic.category, topic.roles.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubgraphByTopicId: async (topicId: string, upstream1Filter?: string | null, upstream2Filter?: string | null, downstream1Filter?: string | null, downstream2Filter?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'topicId' is not null or undefined
            assertParamExists('getSubgraphByTopicId', 'topicId', topicId)
            const localVarPath = `/v0/graph/{topic_id}`
                .replace(`{${"topic_id"}}`, encodeURIComponent(String(topicId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (upstream1Filter !== undefined) {
                localVarQueryParameter['upstream_1_filter'] = upstream1Filter;
            }

            if (upstream2Filter !== undefined) {
                localVarQueryParameter['upstream_2_filter'] = upstream2Filter;
            }

            if (downstream1Filter !== undefined) {
                localVarQueryParameter['downstream_1_filter'] = downstream1Filter;
            }

            if (downstream2Filter !== undefined) {
                localVarQueryParameter['downstream_2_filter'] = downstream2Filter;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GraphApi - functional programming interface
 * @export
 */
export const GraphApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GraphApiAxiosParamCreator(configuration)
    return {
        /**
         * Gets a subgraph of a topic by id.         The subgraph includes upstream and downstream relationships within two hops.         If the response takes too long or is too large, consider using filters to reduce the size of the response.
         * @summary Get subgraph by topic id
         * @param {string} topicId 
         * @param {string | null} [upstream1Filter] Fields and values to filter the first upstream relationship. Supported fields for filtering: id, num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial, topic.id, topic.wikidata_id, topic.category, topic.roles.
         * @param {string | null} [upstream2Filter] Fields and values to filter the second upstream relationship. Supported fields for filtering: id, num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial, topic.id, topic.wikidata_id, topic.category, topic.roles.
         * @param {string | null} [downstream1Filter] Fields and values to filter the first downstream relationship. Supported fields for filtering: id, num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial, topic.id, topic.wikidata_id, topic.category, topic.roles.
         * @param {string | null} [downstream2Filter] Fields and values to filter the second downstream relationship. Supported fields for filtering: id, num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial, topic.id, topic.wikidata_id, topic.category, topic.roles.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSubgraphByTopicId(topicId: string, upstream1Filter?: string | null, upstream2Filter?: string | null, downstream1Filter?: string | null, downstream2Filter?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GraphResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSubgraphByTopicId(topicId, upstream1Filter, upstream2Filter, downstream1Filter, downstream2Filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GraphApi.getSubgraphByTopicId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GraphApi - factory interface
 * @export
 */
export const GraphApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GraphApiFp(configuration)
    return {
        /**
         * Gets a subgraph of a topic by id.         The subgraph includes upstream and downstream relationships within two hops.         If the response takes too long or is too large, consider using filters to reduce the size of the response.
         * @summary Get subgraph by topic id
         * @param {GraphApiGetSubgraphByTopicIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubgraphByTopicId(requestParameters: GraphApiGetSubgraphByTopicIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<GraphResponse> {
            return localVarFp.getSubgraphByTopicId(requestParameters.topicId, requestParameters.upstream1Filter, requestParameters.upstream2Filter, requestParameters.downstream1Filter, requestParameters.downstream2Filter, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getSubgraphByTopicId operation in GraphApi.
 * @export
 * @interface GraphApiGetSubgraphByTopicIdRequest
 */
export interface GraphApiGetSubgraphByTopicIdRequest {
    /**
     * 
     * @type {string}
     * @memberof GraphApiGetSubgraphByTopicId
     */
    readonly topicId: string

    /**
     * Fields and values to filter the first upstream relationship. Supported fields for filtering: id, num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial, topic.id, topic.wikidata_id, topic.category, topic.roles.
     * @type {string}
     * @memberof GraphApiGetSubgraphByTopicId
     */
    readonly upstream1Filter?: string | null

    /**
     * Fields and values to filter the second upstream relationship. Supported fields for filtering: id, num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial, topic.id, topic.wikidata_id, topic.category, topic.roles.
     * @type {string}
     * @memberof GraphApiGetSubgraphByTopicId
     */
    readonly upstream2Filter?: string | null

    /**
     * Fields and values to filter the first downstream relationship. Supported fields for filtering: id, num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial, topic.id, topic.wikidata_id, topic.category, topic.roles.
     * @type {string}
     * @memberof GraphApiGetSubgraphByTopicId
     */
    readonly downstream1Filter?: string | null

    /**
     * Fields and values to filter the second downstream relationship. Supported fields for filtering: id, num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial, topic.id, topic.wikidata_id, topic.category, topic.roles.
     * @type {string}
     * @memberof GraphApiGetSubgraphByTopicId
     */
    readonly downstream2Filter?: string | null
}

/**
 * GraphApi - object-oriented interface
 * @export
 * @class GraphApi
 * @extends {BaseAPI}
 */
export class GraphApi extends BaseAPI {
    /**
     * Gets a subgraph of a topic by id.         The subgraph includes upstream and downstream relationships within two hops.         If the response takes too long or is too large, consider using filters to reduce the size of the response.
     * @summary Get subgraph by topic id
     * @param {GraphApiGetSubgraphByTopicIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApi
     */
    public getSubgraphByTopicId(requestParameters: GraphApiGetSubgraphByTopicIdRequest, options?: RawAxiosRequestConfig) {
        return GraphApiFp(this.configuration).getSubgraphByTopicId(requestParameters.topicId, requestParameters.upstream1Filter, requestParameters.upstream2Filter, requestParameters.downstream1Filter, requestParameters.downstream2Filter, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MechanisticFindingsApi - axios parameter creator
 * @export
 */
export const MechanisticFindingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a mechanistic finding by its ID.
         * @summary Get a mechanistic finding
         * @param {string} findingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMechanisticFindingById: async (findingId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'findingId' is not null or undefined
            assertParamExists('getMechanisticFindingById', 'findingId', findingId)
            const localVarPath = `/v0/mechanistic_findings/{finding_id}`
                .replace(`{${"finding_id"}}`, encodeURIComponent(String(findingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of mechanistic findings.
         * @summary Get mechanistic findings
         * @param {string | null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, flagged, topic_1, topic_2, variable_1.id, variable_2.id, study.id, study.doi, mechanism_type.
         * @param {string | null} [sort] Field to sort the response by. Supported fields for sorting: none.
         * @param {string | null} [search] Field to search within. Supported fields for searching: none.
         * @param {string | null} [fields] Comma-separated list of fields to include in the response.
         * @param {boolean | null} [includeTotal] Include total number of records in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMechanisticFindings: async (filter?: string | null, sort?: string | null, search?: string | null, fields?: string | null, includeTotal?: boolean | null, offset?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v0/mechanistic_findings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (includeTotal !== undefined) {
                localVarQueryParameter['include_total'] = includeTotal;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MechanisticFindingsApi - functional programming interface
 * @export
 */
export const MechanisticFindingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MechanisticFindingsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a mechanistic finding by its ID.
         * @summary Get a mechanistic finding
         * @param {string} findingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMechanisticFindingById(findingId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MechanisticFinding>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMechanisticFindingById(findingId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MechanisticFindingsApi.getMechanisticFindingById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of mechanistic findings.
         * @summary Get mechanistic findings
         * @param {string | null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, flagged, topic_1, topic_2, variable_1.id, variable_2.id, study.id, study.doi, mechanism_type.
         * @param {string | null} [sort] Field to sort the response by. Supported fields for sorting: none.
         * @param {string | null} [search] Field to search within. Supported fields for searching: none.
         * @param {string | null} [fields] Comma-separated list of fields to include in the response.
         * @param {boolean | null} [includeTotal] Include total number of records in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMechanisticFindings(filter?: string | null, sort?: string | null, search?: string | null, fields?: string | null, includeTotal?: boolean | null, offset?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListResponseMechanisticFinding>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMechanisticFindings(filter, sort, search, fields, includeTotal, offset, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MechanisticFindingsApi.getMechanisticFindings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MechanisticFindingsApi - factory interface
 * @export
 */
export const MechanisticFindingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MechanisticFindingsApiFp(configuration)
    return {
        /**
         * Get a mechanistic finding by its ID.
         * @summary Get a mechanistic finding
         * @param {MechanisticFindingsApiGetMechanisticFindingByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMechanisticFindingById(requestParameters: MechanisticFindingsApiGetMechanisticFindingByIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<MechanisticFinding> {
            return localVarFp.getMechanisticFindingById(requestParameters.findingId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of mechanistic findings.
         * @summary Get mechanistic findings
         * @param {MechanisticFindingsApiGetMechanisticFindingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMechanisticFindings(requestParameters: MechanisticFindingsApiGetMechanisticFindingsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<ListResponseMechanisticFinding> {
            return localVarFp.getMechanisticFindings(requestParameters.filter, requestParameters.sort, requestParameters.search, requestParameters.fields, requestParameters.includeTotal, requestParameters.offset, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getMechanisticFindingById operation in MechanisticFindingsApi.
 * @export
 * @interface MechanisticFindingsApiGetMechanisticFindingByIdRequest
 */
export interface MechanisticFindingsApiGetMechanisticFindingByIdRequest {
    /**
     * 
     * @type {string}
     * @memberof MechanisticFindingsApiGetMechanisticFindingById
     */
    readonly findingId: string
}

/**
 * Request parameters for getMechanisticFindings operation in MechanisticFindingsApi.
 * @export
 * @interface MechanisticFindingsApiGetMechanisticFindingsRequest
 */
export interface MechanisticFindingsApiGetMechanisticFindingsRequest {
    /**
     * Fields and values to filter the response by. Supported fields for filtering: id, flagged, topic_1, topic_2, variable_1.id, variable_2.id, study.id, study.doi, mechanism_type.
     * @type {string}
     * @memberof MechanisticFindingsApiGetMechanisticFindings
     */
    readonly filter?: string | null

    /**
     * Field to sort the response by. Supported fields for sorting: none.
     * @type {string}
     * @memberof MechanisticFindingsApiGetMechanisticFindings
     */
    readonly sort?: string | null

    /**
     * Field to search within. Supported fields for searching: none.
     * @type {string}
     * @memberof MechanisticFindingsApiGetMechanisticFindings
     */
    readonly search?: string | null

    /**
     * Comma-separated list of fields to include in the response.
     * @type {string}
     * @memberof MechanisticFindingsApiGetMechanisticFindings
     */
    readonly fields?: string | null

    /**
     * Include total number of records in the response.
     * @type {boolean}
     * @memberof MechanisticFindingsApiGetMechanisticFindings
     */
    readonly includeTotal?: boolean | null

    /**
     * Offset
     * @type {number}
     * @memberof MechanisticFindingsApiGetMechanisticFindings
     */
    readonly offset?: number

    /**
     * Limit
     * @type {number}
     * @memberof MechanisticFindingsApiGetMechanisticFindings
     */
    readonly limit?: number
}

/**
 * MechanisticFindingsApi - object-oriented interface
 * @export
 * @class MechanisticFindingsApi
 * @extends {BaseAPI}
 */
export class MechanisticFindingsApi extends BaseAPI {
    /**
     * Get a mechanistic finding by its ID.
     * @summary Get a mechanistic finding
     * @param {MechanisticFindingsApiGetMechanisticFindingByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MechanisticFindingsApi
     */
    public getMechanisticFindingById(requestParameters: MechanisticFindingsApiGetMechanisticFindingByIdRequest, options?: RawAxiosRequestConfig) {
        return MechanisticFindingsApiFp(this.configuration).getMechanisticFindingById(requestParameters.findingId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of mechanistic findings.
     * @summary Get mechanistic findings
     * @param {MechanisticFindingsApiGetMechanisticFindingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MechanisticFindingsApi
     */
    public getMechanisticFindings(requestParameters: MechanisticFindingsApiGetMechanisticFindingsRequest = {}, options?: RawAxiosRequestConfig) {
        return MechanisticFindingsApiFp(this.configuration).getMechanisticFindings(requestParameters.filter, requestParameters.sort, requestParameters.search, requestParameters.fields, requestParameters.includeTotal, requestParameters.offset, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RelationshipsApi - axios parameter creator
 * @export
 */
export const RelationshipsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a relationship by its ID.
         * @summary Get a relationship
         * @param {string} relationshipId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelationshipById: async (relationshipId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'relationshipId' is not null or undefined
            assertParamExists('getRelationshipById', 'relationshipId', relationshipId)
            const localVarPath = `/v0/relationships/{relationship_id}`
                .replace(`{${"relationship_id"}}`, encodeURIComponent(String(relationshipId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of the statistical findings underlying a given relationship.
         * @summary Get relationship statistical findings
         * @param {string} relationshipId 
         * @param {string | null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, flagged, topic_1, topic_2, variable_1.id, variable_2.id, study.id, study.doi, statistic_type.
         * @param {string | null} [sort] Field to sort the response by. Supported fields for sorting: none.
         * @param {string | null} [search] Field to search within. Supported fields for searching: none.
         * @param {string | null} [fields] Comma-separated list of fields to include in the response.
         * @param {boolean | null} [includeTotal] Include total number of records in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelationshipStatisticalFindings: async (relationshipId: string, filter?: string | null, sort?: string | null, search?: string | null, fields?: string | null, includeTotal?: boolean | null, offset?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'relationshipId' is not null or undefined
            assertParamExists('getRelationshipStatisticalFindings', 'relationshipId', relationshipId)
            const localVarPath = `/v0/relationships/{relationship_id}/statistical_findings`
                .replace(`{${"relationship_id"}}`, encodeURIComponent(String(relationshipId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (includeTotal !== undefined) {
                localVarQueryParameter['include_total'] = includeTotal;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of the studies underlying a given relationship.
         * @summary Get relationship studies
         * @param {string} relationshipId 
         * @param {string | null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, doi, publish_date, cited_by, study_type.
         * @param {string | null} [sort] Field to sort the response by. Supported fields for sorting: publish_date, sample_size, cited_by.
         * @param {string | null} [search] Field to search within. Supported fields for searching: none.
         * @param {string | null} [fields] Comma-separated list of fields to include in the response.
         * @param {boolean | null} [includeTotal] Include total number of records in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelationshipStudies: async (relationshipId: string, filter?: string | null, sort?: string | null, search?: string | null, fields?: string | null, includeTotal?: boolean | null, offset?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'relationshipId' is not null or undefined
            assertParamExists('getRelationshipStudies', 'relationshipId', relationshipId)
            const localVarPath = `/v0/relationships/{relationship_id}/studies`
                .replace(`{${"relationship_id"}}`, encodeURIComponent(String(relationshipId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (includeTotal !== undefined) {
                localVarQueryParameter['include_total'] = includeTotal;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of relationships.
         * @summary Get relationships
         * @param {string | null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial, source_topic.id, source_topic.wikidata_id, source_topic.category, source_topic.roles, target_topic.id, target_topic.wikidata_id, target_topic.category, target_topic.roles.
         * @param {string | null} [sort] Field to sort the response by. Supported fields for sorting: num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial.
         * @param {string | null} [search] Field to search within. Supported fields for searching: none.
         * @param {string | null} [fields] Comma-separated list of fields to include in the response.
         * @param {boolean | null} [includeTotal] Include total number of records in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelationships: async (filter?: string | null, sort?: string | null, search?: string | null, fields?: string | null, includeTotal?: boolean | null, offset?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v0/relationships`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (includeTotal !== undefined) {
                localVarQueryParameter['include_total'] = includeTotal;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RelationshipsApi - functional programming interface
 * @export
 */
export const RelationshipsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RelationshipsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a relationship by its ID.
         * @summary Get a relationship
         * @param {string} relationshipId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRelationshipById(relationshipId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Relationship>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRelationshipById(relationshipId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RelationshipsApi.getRelationshipById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of the statistical findings underlying a given relationship.
         * @summary Get relationship statistical findings
         * @param {string} relationshipId 
         * @param {string | null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, flagged, topic_1, topic_2, variable_1.id, variable_2.id, study.id, study.doi, statistic_type.
         * @param {string | null} [sort] Field to sort the response by. Supported fields for sorting: none.
         * @param {string | null} [search] Field to search within. Supported fields for searching: none.
         * @param {string | null} [fields] Comma-separated list of fields to include in the response.
         * @param {boolean | null} [includeTotal] Include total number of records in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRelationshipStatisticalFindings(relationshipId: string, filter?: string | null, sort?: string | null, search?: string | null, fields?: string | null, includeTotal?: boolean | null, offset?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListResponseStatisticalFinding>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRelationshipStatisticalFindings(relationshipId, filter, sort, search, fields, includeTotal, offset, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RelationshipsApi.getRelationshipStatisticalFindings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of the studies underlying a given relationship.
         * @summary Get relationship studies
         * @param {string} relationshipId 
         * @param {string | null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, doi, publish_date, cited_by, study_type.
         * @param {string | null} [sort] Field to sort the response by. Supported fields for sorting: publish_date, sample_size, cited_by.
         * @param {string | null} [search] Field to search within. Supported fields for searching: none.
         * @param {string | null} [fields] Comma-separated list of fields to include in the response.
         * @param {boolean | null} [includeTotal] Include total number of records in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRelationshipStudies(relationshipId: string, filter?: string | null, sort?: string | null, search?: string | null, fields?: string | null, includeTotal?: boolean | null, offset?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListResponseStudy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRelationshipStudies(relationshipId, filter, sort, search, fields, includeTotal, offset, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RelationshipsApi.getRelationshipStudies']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of relationships.
         * @summary Get relationships
         * @param {string | null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial, source_topic.id, source_topic.wikidata_id, source_topic.category, source_topic.roles, target_topic.id, target_topic.wikidata_id, target_topic.category, target_topic.roles.
         * @param {string | null} [sort] Field to sort the response by. Supported fields for sorting: num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial.
         * @param {string | null} [search] Field to search within. Supported fields for searching: none.
         * @param {string | null} [fields] Comma-separated list of fields to include in the response.
         * @param {boolean | null} [includeTotal] Include total number of records in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRelationships(filter?: string | null, sort?: string | null, search?: string | null, fields?: string | null, includeTotal?: boolean | null, offset?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListResponseRelationship>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRelationships(filter, sort, search, fields, includeTotal, offset, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RelationshipsApi.getRelationships']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RelationshipsApi - factory interface
 * @export
 */
export const RelationshipsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RelationshipsApiFp(configuration)
    return {
        /**
         * Get a relationship by its ID.
         * @summary Get a relationship
         * @param {RelationshipsApiGetRelationshipByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelationshipById(requestParameters: RelationshipsApiGetRelationshipByIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<Relationship> {
            return localVarFp.getRelationshipById(requestParameters.relationshipId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of the statistical findings underlying a given relationship.
         * @summary Get relationship statistical findings
         * @param {RelationshipsApiGetRelationshipStatisticalFindingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelationshipStatisticalFindings(requestParameters: RelationshipsApiGetRelationshipStatisticalFindingsRequest, options?: RawAxiosRequestConfig): AxiosPromise<ListResponseStatisticalFinding> {
            return localVarFp.getRelationshipStatisticalFindings(requestParameters.relationshipId, requestParameters.filter, requestParameters.sort, requestParameters.search, requestParameters.fields, requestParameters.includeTotal, requestParameters.offset, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of the studies underlying a given relationship.
         * @summary Get relationship studies
         * @param {RelationshipsApiGetRelationshipStudiesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelationshipStudies(requestParameters: RelationshipsApiGetRelationshipStudiesRequest, options?: RawAxiosRequestConfig): AxiosPromise<ListResponseStudy> {
            return localVarFp.getRelationshipStudies(requestParameters.relationshipId, requestParameters.filter, requestParameters.sort, requestParameters.search, requestParameters.fields, requestParameters.includeTotal, requestParameters.offset, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of relationships.
         * @summary Get relationships
         * @param {RelationshipsApiGetRelationshipsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelationships(requestParameters: RelationshipsApiGetRelationshipsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<ListResponseRelationship> {
            return localVarFp.getRelationships(requestParameters.filter, requestParameters.sort, requestParameters.search, requestParameters.fields, requestParameters.includeTotal, requestParameters.offset, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getRelationshipById operation in RelationshipsApi.
 * @export
 * @interface RelationshipsApiGetRelationshipByIdRequest
 */
export interface RelationshipsApiGetRelationshipByIdRequest {
    /**
     * 
     * @type {string}
     * @memberof RelationshipsApiGetRelationshipById
     */
    readonly relationshipId: string
}

/**
 * Request parameters for getRelationshipStatisticalFindings operation in RelationshipsApi.
 * @export
 * @interface RelationshipsApiGetRelationshipStatisticalFindingsRequest
 */
export interface RelationshipsApiGetRelationshipStatisticalFindingsRequest {
    /**
     * 
     * @type {string}
     * @memberof RelationshipsApiGetRelationshipStatisticalFindings
     */
    readonly relationshipId: string

    /**
     * Fields and values to filter the response by. Supported fields for filtering: id, flagged, topic_1, topic_2, variable_1.id, variable_2.id, study.id, study.doi, statistic_type.
     * @type {string}
     * @memberof RelationshipsApiGetRelationshipStatisticalFindings
     */
    readonly filter?: string | null

    /**
     * Field to sort the response by. Supported fields for sorting: none.
     * @type {string}
     * @memberof RelationshipsApiGetRelationshipStatisticalFindings
     */
    readonly sort?: string | null

    /**
     * Field to search within. Supported fields for searching: none.
     * @type {string}
     * @memberof RelationshipsApiGetRelationshipStatisticalFindings
     */
    readonly search?: string | null

    /**
     * Comma-separated list of fields to include in the response.
     * @type {string}
     * @memberof RelationshipsApiGetRelationshipStatisticalFindings
     */
    readonly fields?: string | null

    /**
     * Include total number of records in the response.
     * @type {boolean}
     * @memberof RelationshipsApiGetRelationshipStatisticalFindings
     */
    readonly includeTotal?: boolean | null

    /**
     * Offset
     * @type {number}
     * @memberof RelationshipsApiGetRelationshipStatisticalFindings
     */
    readonly offset?: number

    /**
     * Limit
     * @type {number}
     * @memberof RelationshipsApiGetRelationshipStatisticalFindings
     */
    readonly limit?: number
}

/**
 * Request parameters for getRelationshipStudies operation in RelationshipsApi.
 * @export
 * @interface RelationshipsApiGetRelationshipStudiesRequest
 */
export interface RelationshipsApiGetRelationshipStudiesRequest {
    /**
     * 
     * @type {string}
     * @memberof RelationshipsApiGetRelationshipStudies
     */
    readonly relationshipId: string

    /**
     * Fields and values to filter the response by. Supported fields for filtering: id, doi, publish_date, cited_by, study_type.
     * @type {string}
     * @memberof RelationshipsApiGetRelationshipStudies
     */
    readonly filter?: string | null

    /**
     * Field to sort the response by. Supported fields for sorting: publish_date, sample_size, cited_by.
     * @type {string}
     * @memberof RelationshipsApiGetRelationshipStudies
     */
    readonly sort?: string | null

    /**
     * Field to search within. Supported fields for searching: none.
     * @type {string}
     * @memberof RelationshipsApiGetRelationshipStudies
     */
    readonly search?: string | null

    /**
     * Comma-separated list of fields to include in the response.
     * @type {string}
     * @memberof RelationshipsApiGetRelationshipStudies
     */
    readonly fields?: string | null

    /**
     * Include total number of records in the response.
     * @type {boolean}
     * @memberof RelationshipsApiGetRelationshipStudies
     */
    readonly includeTotal?: boolean | null

    /**
     * Offset
     * @type {number}
     * @memberof RelationshipsApiGetRelationshipStudies
     */
    readonly offset?: number

    /**
     * Limit
     * @type {number}
     * @memberof RelationshipsApiGetRelationshipStudies
     */
    readonly limit?: number
}

/**
 * Request parameters for getRelationships operation in RelationshipsApi.
 * @export
 * @interface RelationshipsApiGetRelationshipsRequest
 */
export interface RelationshipsApiGetRelationshipsRequest {
    /**
     * Fields and values to filter the response by. Supported fields for filtering: id, num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial, source_topic.id, source_topic.wikidata_id, source_topic.category, source_topic.roles, target_topic.id, target_topic.wikidata_id, target_topic.category, target_topic.roles.
     * @type {string}
     * @memberof RelationshipsApiGetRelationships
     */
    readonly filter?: string | null

    /**
     * Field to sort the response by. Supported fields for sorting: num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial.
     * @type {string}
     * @memberof RelationshipsApiGetRelationships
     */
    readonly sort?: string | null

    /**
     * Field to search within. Supported fields for searching: none.
     * @type {string}
     * @memberof RelationshipsApiGetRelationships
     */
    readonly search?: string | null

    /**
     * Comma-separated list of fields to include in the response.
     * @type {string}
     * @memberof RelationshipsApiGetRelationships
     */
    readonly fields?: string | null

    /**
     * Include total number of records in the response.
     * @type {boolean}
     * @memberof RelationshipsApiGetRelationships
     */
    readonly includeTotal?: boolean | null

    /**
     * Offset
     * @type {number}
     * @memberof RelationshipsApiGetRelationships
     */
    readonly offset?: number

    /**
     * Limit
     * @type {number}
     * @memberof RelationshipsApiGetRelationships
     */
    readonly limit?: number
}

/**
 * RelationshipsApi - object-oriented interface
 * @export
 * @class RelationshipsApi
 * @extends {BaseAPI}
 */
export class RelationshipsApi extends BaseAPI {
    /**
     * Get a relationship by its ID.
     * @summary Get a relationship
     * @param {RelationshipsApiGetRelationshipByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RelationshipsApi
     */
    public getRelationshipById(requestParameters: RelationshipsApiGetRelationshipByIdRequest, options?: RawAxiosRequestConfig) {
        return RelationshipsApiFp(this.configuration).getRelationshipById(requestParameters.relationshipId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of the statistical findings underlying a given relationship.
     * @summary Get relationship statistical findings
     * @param {RelationshipsApiGetRelationshipStatisticalFindingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RelationshipsApi
     */
    public getRelationshipStatisticalFindings(requestParameters: RelationshipsApiGetRelationshipStatisticalFindingsRequest, options?: RawAxiosRequestConfig) {
        return RelationshipsApiFp(this.configuration).getRelationshipStatisticalFindings(requestParameters.relationshipId, requestParameters.filter, requestParameters.sort, requestParameters.search, requestParameters.fields, requestParameters.includeTotal, requestParameters.offset, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of the studies underlying a given relationship.
     * @summary Get relationship studies
     * @param {RelationshipsApiGetRelationshipStudiesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RelationshipsApi
     */
    public getRelationshipStudies(requestParameters: RelationshipsApiGetRelationshipStudiesRequest, options?: RawAxiosRequestConfig) {
        return RelationshipsApiFp(this.configuration).getRelationshipStudies(requestParameters.relationshipId, requestParameters.filter, requestParameters.sort, requestParameters.search, requestParameters.fields, requestParameters.includeTotal, requestParameters.offset, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of relationships.
     * @summary Get relationships
     * @param {RelationshipsApiGetRelationshipsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RelationshipsApi
     */
    public getRelationships(requestParameters: RelationshipsApiGetRelationshipsRequest = {}, options?: RawAxiosRequestConfig) {
        return RelationshipsApiFp(this.configuration).getRelationships(requestParameters.filter, requestParameters.sort, requestParameters.search, requestParameters.fields, requestParameters.includeTotal, requestParameters.offset, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * StatisticalFindingsApi - axios parameter creator
 * @export
 */
export const StatisticalFindingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Flag a statistical finding for review.
         * @summary Flag statistical finding
         * @param {string} findingId 
         * @param {Array<FlagInput>} flagInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        flagStatisticalFinding: async (findingId: string, flagInput: Array<FlagInput>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'findingId' is not null or undefined
            assertParamExists('flagStatisticalFinding', 'findingId', findingId)
            // verify required parameter 'flagInput' is not null or undefined
            assertParamExists('flagStatisticalFinding', 'flagInput', flagInput)
            const localVarPath = `/v0/statistical_findings/{finding_id}/flags`
                .replace(`{${"finding_id"}}`, encodeURIComponent(String(findingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(flagInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a statistical finding by its ID.
         * @summary Get a statistical finding
         * @param {string} findingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatisticalFindingById: async (findingId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'findingId' is not null or undefined
            assertParamExists('getStatisticalFindingById', 'findingId', findingId)
            const localVarPath = `/v0/statistical_findings/{finding_id}`
                .replace(`{${"finding_id"}}`, encodeURIComponent(String(findingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of statistical findings.
         * @summary Get statistical findings
         * @param {string | null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, flagged, topic_1, topic_2, variable_1.id, variable_2.id, study.id, study.doi, statistic_type.
         * @param {string | null} [sort] Field to sort the response by. Supported fields for sorting: none.
         * @param {string | null} [search] Field to search within. Supported fields for searching: none.
         * @param {string | null} [fields] Comma-separated list of fields to include in the response.
         * @param {boolean | null} [includeTotal] Include total number of records in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatisticalFindings: async (filter?: string | null, sort?: string | null, search?: string | null, fields?: string | null, includeTotal?: boolean | null, offset?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v0/statistical_findings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (includeTotal !== undefined) {
                localVarQueryParameter['include_total'] = includeTotal;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StatisticalFindingsApi - functional programming interface
 * @export
 */
export const StatisticalFindingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StatisticalFindingsApiAxiosParamCreator(configuration)
    return {
        /**
         * Flag a statistical finding for review.
         * @summary Flag statistical finding
         * @param {string} findingId 
         * @param {Array<FlagInput>} flagInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async flagStatisticalFinding(findingId: string, flagInput: Array<FlagInput>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Flag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.flagStatisticalFinding(findingId, flagInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StatisticalFindingsApi.flagStatisticalFinding']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a statistical finding by its ID.
         * @summary Get a statistical finding
         * @param {string} findingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStatisticalFindingById(findingId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatisticalFinding>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStatisticalFindingById(findingId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StatisticalFindingsApi.getStatisticalFindingById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of statistical findings.
         * @summary Get statistical findings
         * @param {string | null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, flagged, topic_1, topic_2, variable_1.id, variable_2.id, study.id, study.doi, statistic_type.
         * @param {string | null} [sort] Field to sort the response by. Supported fields for sorting: none.
         * @param {string | null} [search] Field to search within. Supported fields for searching: none.
         * @param {string | null} [fields] Comma-separated list of fields to include in the response.
         * @param {boolean | null} [includeTotal] Include total number of records in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStatisticalFindings(filter?: string | null, sort?: string | null, search?: string | null, fields?: string | null, includeTotal?: boolean | null, offset?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListResponseStatisticalFinding>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStatisticalFindings(filter, sort, search, fields, includeTotal, offset, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StatisticalFindingsApi.getStatisticalFindings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * StatisticalFindingsApi - factory interface
 * @export
 */
export const StatisticalFindingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StatisticalFindingsApiFp(configuration)
    return {
        /**
         * Flag a statistical finding for review.
         * @summary Flag statistical finding
         * @param {StatisticalFindingsApiFlagStatisticalFindingRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        flagStatisticalFinding(requestParameters: StatisticalFindingsApiFlagStatisticalFindingRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<Flag>> {
            return localVarFp.flagStatisticalFinding(requestParameters.findingId, requestParameters.flagInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a statistical finding by its ID.
         * @summary Get a statistical finding
         * @param {StatisticalFindingsApiGetStatisticalFindingByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatisticalFindingById(requestParameters: StatisticalFindingsApiGetStatisticalFindingByIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<StatisticalFinding> {
            return localVarFp.getStatisticalFindingById(requestParameters.findingId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of statistical findings.
         * @summary Get statistical findings
         * @param {StatisticalFindingsApiGetStatisticalFindingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatisticalFindings(requestParameters: StatisticalFindingsApiGetStatisticalFindingsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<ListResponseStatisticalFinding> {
            return localVarFp.getStatisticalFindings(requestParameters.filter, requestParameters.sort, requestParameters.search, requestParameters.fields, requestParameters.includeTotal, requestParameters.offset, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for flagStatisticalFinding operation in StatisticalFindingsApi.
 * @export
 * @interface StatisticalFindingsApiFlagStatisticalFindingRequest
 */
export interface StatisticalFindingsApiFlagStatisticalFindingRequest {
    /**
     * 
     * @type {string}
     * @memberof StatisticalFindingsApiFlagStatisticalFinding
     */
    readonly findingId: string

    /**
     * 
     * @type {Array<FlagInput>}
     * @memberof StatisticalFindingsApiFlagStatisticalFinding
     */
    readonly flagInput: Array<FlagInput>
}

/**
 * Request parameters for getStatisticalFindingById operation in StatisticalFindingsApi.
 * @export
 * @interface StatisticalFindingsApiGetStatisticalFindingByIdRequest
 */
export interface StatisticalFindingsApiGetStatisticalFindingByIdRequest {
    /**
     * 
     * @type {string}
     * @memberof StatisticalFindingsApiGetStatisticalFindingById
     */
    readonly findingId: string
}

/**
 * Request parameters for getStatisticalFindings operation in StatisticalFindingsApi.
 * @export
 * @interface StatisticalFindingsApiGetStatisticalFindingsRequest
 */
export interface StatisticalFindingsApiGetStatisticalFindingsRequest {
    /**
     * Fields and values to filter the response by. Supported fields for filtering: id, flagged, topic_1, topic_2, variable_1.id, variable_2.id, study.id, study.doi, statistic_type.
     * @type {string}
     * @memberof StatisticalFindingsApiGetStatisticalFindings
     */
    readonly filter?: string | null

    /**
     * Field to sort the response by. Supported fields for sorting: none.
     * @type {string}
     * @memberof StatisticalFindingsApiGetStatisticalFindings
     */
    readonly sort?: string | null

    /**
     * Field to search within. Supported fields for searching: none.
     * @type {string}
     * @memberof StatisticalFindingsApiGetStatisticalFindings
     */
    readonly search?: string | null

    /**
     * Comma-separated list of fields to include in the response.
     * @type {string}
     * @memberof StatisticalFindingsApiGetStatisticalFindings
     */
    readonly fields?: string | null

    /**
     * Include total number of records in the response.
     * @type {boolean}
     * @memberof StatisticalFindingsApiGetStatisticalFindings
     */
    readonly includeTotal?: boolean | null

    /**
     * Offset
     * @type {number}
     * @memberof StatisticalFindingsApiGetStatisticalFindings
     */
    readonly offset?: number

    /**
     * Limit
     * @type {number}
     * @memberof StatisticalFindingsApiGetStatisticalFindings
     */
    readonly limit?: number
}

/**
 * StatisticalFindingsApi - object-oriented interface
 * @export
 * @class StatisticalFindingsApi
 * @extends {BaseAPI}
 */
export class StatisticalFindingsApi extends BaseAPI {
    /**
     * Flag a statistical finding for review.
     * @summary Flag statistical finding
     * @param {StatisticalFindingsApiFlagStatisticalFindingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatisticalFindingsApi
     */
    public flagStatisticalFinding(requestParameters: StatisticalFindingsApiFlagStatisticalFindingRequest, options?: RawAxiosRequestConfig) {
        return StatisticalFindingsApiFp(this.configuration).flagStatisticalFinding(requestParameters.findingId, requestParameters.flagInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a statistical finding by its ID.
     * @summary Get a statistical finding
     * @param {StatisticalFindingsApiGetStatisticalFindingByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatisticalFindingsApi
     */
    public getStatisticalFindingById(requestParameters: StatisticalFindingsApiGetStatisticalFindingByIdRequest, options?: RawAxiosRequestConfig) {
        return StatisticalFindingsApiFp(this.configuration).getStatisticalFindingById(requestParameters.findingId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of statistical findings.
     * @summary Get statistical findings
     * @param {StatisticalFindingsApiGetStatisticalFindingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatisticalFindingsApi
     */
    public getStatisticalFindings(requestParameters: StatisticalFindingsApiGetStatisticalFindingsRequest = {}, options?: RawAxiosRequestConfig) {
        return StatisticalFindingsApiFp(this.configuration).getStatisticalFindings(requestParameters.filter, requestParameters.sort, requestParameters.search, requestParameters.fields, requestParameters.includeTotal, requestParameters.offset, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * StudiesApi - axios parameter creator
 * @export
 */
export const StudiesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a list of studies.
         * @summary Get studies
         * @param {string | null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, doi, publish_date, cited_by, study_type.
         * @param {string | null} [sort] Field to sort the response by. Supported fields for sorting: publish_date, sample_size, cited_by.
         * @param {string | null} [search] Field to search within. Supported fields for searching: none.
         * @param {string | null} [fields] Comma-separated list of fields to include in the response.
         * @param {boolean | null} [includeTotal] Include total number of records in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudies: async (filter?: string | null, sort?: string | null, search?: string | null, fields?: string | null, includeTotal?: boolean | null, offset?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v0/studies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (includeTotal !== undefined) {
                localVarQueryParameter['include_total'] = includeTotal;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a study by its ID.
         * @summary Get a study
         * @param {string} studyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudyById: async (studyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'studyId' is not null or undefined
            assertParamExists('getStudyById', 'studyId', studyId)
            const localVarPath = `/v0/studies/{study_id}`
                .replace(`{${"study_id"}}`, encodeURIComponent(String(studyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of the statistical findings reported by a given study.
         * @summary Get study statistical findings
         * @param {string} studyId 
         * @param {string | null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, flagged, topic_1, topic_2, variable_1.id, variable_2.id, study.id, study.doi, statistic_type.
         * @param {string | null} [sort] Field to sort the response by. Supported fields for sorting: none.
         * @param {string | null} [search] Field to search within. Supported fields for searching: none.
         * @param {string | null} [fields] Comma-separated list of fields to include in the response.
         * @param {boolean | null} [includeTotal] Include total number of records in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudyStatisticalFindings: async (studyId: string, filter?: string | null, sort?: string | null, search?: string | null, fields?: string | null, includeTotal?: boolean | null, offset?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'studyId' is not null or undefined
            assertParamExists('getStudyStatisticalFindings', 'studyId', studyId)
            const localVarPath = `/v0/studies/{study_id}/statistical_findings`
                .replace(`{${"study_id"}}`, encodeURIComponent(String(studyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (includeTotal !== undefined) {
                localVarQueryParameter['include_total'] = includeTotal;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StudiesApi - functional programming interface
 * @export
 */
export const StudiesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StudiesApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a list of studies.
         * @summary Get studies
         * @param {string | null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, doi, publish_date, cited_by, study_type.
         * @param {string | null} [sort] Field to sort the response by. Supported fields for sorting: publish_date, sample_size, cited_by.
         * @param {string | null} [search] Field to search within. Supported fields for searching: none.
         * @param {string | null} [fields] Comma-separated list of fields to include in the response.
         * @param {boolean | null} [includeTotal] Include total number of records in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStudies(filter?: string | null, sort?: string | null, search?: string | null, fields?: string | null, includeTotal?: boolean | null, offset?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListResponseStudy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStudies(filter, sort, search, fields, includeTotal, offset, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StudiesApi.getStudies']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a study by its ID.
         * @summary Get a study
         * @param {string} studyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStudyById(studyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Study>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStudyById(studyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StudiesApi.getStudyById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of the statistical findings reported by a given study.
         * @summary Get study statistical findings
         * @param {string} studyId 
         * @param {string | null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, flagged, topic_1, topic_2, variable_1.id, variable_2.id, study.id, study.doi, statistic_type.
         * @param {string | null} [sort] Field to sort the response by. Supported fields for sorting: none.
         * @param {string | null} [search] Field to search within. Supported fields for searching: none.
         * @param {string | null} [fields] Comma-separated list of fields to include in the response.
         * @param {boolean | null} [includeTotal] Include total number of records in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStudyStatisticalFindings(studyId: string, filter?: string | null, sort?: string | null, search?: string | null, fields?: string | null, includeTotal?: boolean | null, offset?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListResponseStatisticalFinding>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStudyStatisticalFindings(studyId, filter, sort, search, fields, includeTotal, offset, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StudiesApi.getStudyStatisticalFindings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * StudiesApi - factory interface
 * @export
 */
export const StudiesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StudiesApiFp(configuration)
    return {
        /**
         * Get a list of studies.
         * @summary Get studies
         * @param {StudiesApiGetStudiesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudies(requestParameters: StudiesApiGetStudiesRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<ListResponseStudy> {
            return localVarFp.getStudies(requestParameters.filter, requestParameters.sort, requestParameters.search, requestParameters.fields, requestParameters.includeTotal, requestParameters.offset, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a study by its ID.
         * @summary Get a study
         * @param {StudiesApiGetStudyByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudyById(requestParameters: StudiesApiGetStudyByIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<Study> {
            return localVarFp.getStudyById(requestParameters.studyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of the statistical findings reported by a given study.
         * @summary Get study statistical findings
         * @param {StudiesApiGetStudyStatisticalFindingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudyStatisticalFindings(requestParameters: StudiesApiGetStudyStatisticalFindingsRequest, options?: RawAxiosRequestConfig): AxiosPromise<ListResponseStatisticalFinding> {
            return localVarFp.getStudyStatisticalFindings(requestParameters.studyId, requestParameters.filter, requestParameters.sort, requestParameters.search, requestParameters.fields, requestParameters.includeTotal, requestParameters.offset, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getStudies operation in StudiesApi.
 * @export
 * @interface StudiesApiGetStudiesRequest
 */
export interface StudiesApiGetStudiesRequest {
    /**
     * Fields and values to filter the response by. Supported fields for filtering: id, doi, publish_date, cited_by, study_type.
     * @type {string}
     * @memberof StudiesApiGetStudies
     */
    readonly filter?: string | null

    /**
     * Field to sort the response by. Supported fields for sorting: publish_date, sample_size, cited_by.
     * @type {string}
     * @memberof StudiesApiGetStudies
     */
    readonly sort?: string | null

    /**
     * Field to search within. Supported fields for searching: none.
     * @type {string}
     * @memberof StudiesApiGetStudies
     */
    readonly search?: string | null

    /**
     * Comma-separated list of fields to include in the response.
     * @type {string}
     * @memberof StudiesApiGetStudies
     */
    readonly fields?: string | null

    /**
     * Include total number of records in the response.
     * @type {boolean}
     * @memberof StudiesApiGetStudies
     */
    readonly includeTotal?: boolean | null

    /**
     * Offset
     * @type {number}
     * @memberof StudiesApiGetStudies
     */
    readonly offset?: number

    /**
     * Limit
     * @type {number}
     * @memberof StudiesApiGetStudies
     */
    readonly limit?: number
}

/**
 * Request parameters for getStudyById operation in StudiesApi.
 * @export
 * @interface StudiesApiGetStudyByIdRequest
 */
export interface StudiesApiGetStudyByIdRequest {
    /**
     * 
     * @type {string}
     * @memberof StudiesApiGetStudyById
     */
    readonly studyId: string
}

/**
 * Request parameters for getStudyStatisticalFindings operation in StudiesApi.
 * @export
 * @interface StudiesApiGetStudyStatisticalFindingsRequest
 */
export interface StudiesApiGetStudyStatisticalFindingsRequest {
    /**
     * 
     * @type {string}
     * @memberof StudiesApiGetStudyStatisticalFindings
     */
    readonly studyId: string

    /**
     * Fields and values to filter the response by. Supported fields for filtering: id, flagged, topic_1, topic_2, variable_1.id, variable_2.id, study.id, study.doi, statistic_type.
     * @type {string}
     * @memberof StudiesApiGetStudyStatisticalFindings
     */
    readonly filter?: string | null

    /**
     * Field to sort the response by. Supported fields for sorting: none.
     * @type {string}
     * @memberof StudiesApiGetStudyStatisticalFindings
     */
    readonly sort?: string | null

    /**
     * Field to search within. Supported fields for searching: none.
     * @type {string}
     * @memberof StudiesApiGetStudyStatisticalFindings
     */
    readonly search?: string | null

    /**
     * Comma-separated list of fields to include in the response.
     * @type {string}
     * @memberof StudiesApiGetStudyStatisticalFindings
     */
    readonly fields?: string | null

    /**
     * Include total number of records in the response.
     * @type {boolean}
     * @memberof StudiesApiGetStudyStatisticalFindings
     */
    readonly includeTotal?: boolean | null

    /**
     * Offset
     * @type {number}
     * @memberof StudiesApiGetStudyStatisticalFindings
     */
    readonly offset?: number

    /**
     * Limit
     * @type {number}
     * @memberof StudiesApiGetStudyStatisticalFindings
     */
    readonly limit?: number
}

/**
 * StudiesApi - object-oriented interface
 * @export
 * @class StudiesApi
 * @extends {BaseAPI}
 */
export class StudiesApi extends BaseAPI {
    /**
     * Get a list of studies.
     * @summary Get studies
     * @param {StudiesApiGetStudiesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudiesApi
     */
    public getStudies(requestParameters: StudiesApiGetStudiesRequest = {}, options?: RawAxiosRequestConfig) {
        return StudiesApiFp(this.configuration).getStudies(requestParameters.filter, requestParameters.sort, requestParameters.search, requestParameters.fields, requestParameters.includeTotal, requestParameters.offset, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a study by its ID.
     * @summary Get a study
     * @param {StudiesApiGetStudyByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudiesApi
     */
    public getStudyById(requestParameters: StudiesApiGetStudyByIdRequest, options?: RawAxiosRequestConfig) {
        return StudiesApiFp(this.configuration).getStudyById(requestParameters.studyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of the statistical findings reported by a given study.
     * @summary Get study statistical findings
     * @param {StudiesApiGetStudyStatisticalFindingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudiesApi
     */
    public getStudyStatisticalFindings(requestParameters: StudiesApiGetStudyStatisticalFindingsRequest, options?: RawAxiosRequestConfig) {
        return StudiesApiFp(this.configuration).getStudyStatisticalFindings(requestParameters.studyId, requestParameters.filter, requestParameters.sort, requestParameters.search, requestParameters.fields, requestParameters.includeTotal, requestParameters.offset, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SynthesisApi - axios parameter creator
 * @export
 */
export const SynthesisApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get statistical findings from pubmed search synthesis.
         * @summary Get mechanistic findings from pubmed search synthesis
         * @param {string} jobId 
         * @param {string | null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, flagged, topic_1, topic_2, variable_1.id, variable_2.id, study.id, study.doi, mechanism_type.
         * @param {string | null} [sort] Field to sort the response by. Supported fields for sorting: none.
         * @param {string | null} [search] Field to search within. Supported fields for searching: none.
         * @param {string | null} [fields] Comma-separated list of fields to include in the response.
         * @param {boolean | null} [includeTotal] Include total number of records in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMechanisticFindingsFromPubmedSearch: async (jobId: string, filter?: string | null, sort?: string | null, search?: string | null, fields?: string | null, includeTotal?: boolean | null, offset?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('getMechanisticFindingsFromPubmedSearch', 'jobId', jobId)
            const localVarPath = `/v0/synthesis/pubmed_search/{job_id}/mechanistic_findings`
                .replace(`{${"job_id"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (includeTotal !== undefined) {
                localVarQueryParameter['include_total'] = includeTotal;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information about a pubmed search synthesis job.
         * @summary Get pubmed search synthesis by ID
         * @param {string} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPubmedSearchSynthesisById: async (jobId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('getPubmedSearchSynthesisById', 'jobId', jobId)
            const localVarPath = `/v0/synthesis/pubmed_search/{job_id}`
                .replace(`{${"job_id"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get statements from pubmed search synthesis.
         * @summary Get statements from pubmed search synthesis
         * @param {string} jobId 
         * @param {boolean | null} [includeTotal] Include total number of records in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatementsFromPubmedSearch: async (jobId: string, includeTotal?: boolean | null, offset?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('getStatementsFromPubmedSearch', 'jobId', jobId)
            const localVarPath = `/v0/synthesis/pubmed_search/{job_id}/statements`
                .replace(`{${"job_id"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (includeTotal !== undefined) {
                localVarQueryParameter['include_total'] = includeTotal;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get statistical findings from pubmed search synthesis.
         * @summary Get statistical findings from pubmed search synthesis
         * @param {string} jobId 
         * @param {string | null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, flagged, topic_1, topic_2, variable_1.id, variable_2.id, study.id, study.doi, statistic_type.
         * @param {string | null} [sort] Field to sort the response by. Supported fields for sorting: none.
         * @param {string | null} [search] Field to search within. Supported fields for searching: none.
         * @param {string | null} [fields] Comma-separated list of fields to include in the response.
         * @param {boolean | null} [includeTotal] Include total number of records in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatisticalFindingsFromPubmedSearch: async (jobId: string, filter?: string | null, sort?: string | null, search?: string | null, fields?: string | null, includeTotal?: boolean | null, offset?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('getStatisticalFindingsFromPubmedSearch', 'jobId', jobId)
            const localVarPath = `/v0/synthesis/pubmed_search/{job_id}/statistical_findings`
                .replace(`{${"job_id"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (includeTotal !== undefined) {
                localVarQueryParameter['include_total'] = includeTotal;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get studies from pubmed search synthesis.
         * @summary Get studies from pubmed search synthesis
         * @param {string} jobId 
         * @param {string | null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, doi, publish_date, cited_by, study_type.
         * @param {string | null} [sort] Field to sort the response by. Supported fields for sorting: publish_date, sample_size, cited_by.
         * @param {string | null} [search] Field to search within. Supported fields for searching: none.
         * @param {string | null} [fields] Comma-separated list of fields to include in the response.
         * @param {boolean | null} [includeTotal] Include total number of records in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudiesFromPubmedSearch: async (jobId: string, filter?: string | null, sort?: string | null, search?: string | null, fields?: string | null, includeTotal?: boolean | null, offset?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('getStudiesFromPubmedSearch', 'jobId', jobId)
            const localVarPath = `/v0/synthesis/pubmed_search/{job_id}/studies`
                .replace(`{${"job_id"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (includeTotal !== undefined) {
                localVarQueryParameter['include_total'] = includeTotal;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get synthesis from pubmed search synthesis.
         * @summary Get synthesis from pubmed search synthesis
         * @param {string} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSynthesisFromPubmedSearch: async (jobId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('getSynthesisFromPubmedSearch', 'jobId', jobId)
            const localVarPath = `/v0/synthesis/pubmed_search/{job_id}/synthesis`
                .replace(`{${"job_id"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Initiate pubmed search synthesis.
         * @summary Initiate pubmed search synthesis
         * @param {PubmedSearchSynthesisInput} pubmedSearchSynthesisInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        synthesizePubmedSearch: async (pubmedSearchSynthesisInput: PubmedSearchSynthesisInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pubmedSearchSynthesisInput' is not null or undefined
            assertParamExists('synthesizePubmedSearch', 'pubmedSearchSynthesisInput', pubmedSearchSynthesisInput)
            const localVarPath = `/v0/synthesis/pubmed_search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pubmedSearchSynthesisInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SynthesisApi - functional programming interface
 * @export
 */
export const SynthesisApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SynthesisApiAxiosParamCreator(configuration)
    return {
        /**
         * Get statistical findings from pubmed search synthesis.
         * @summary Get mechanistic findings from pubmed search synthesis
         * @param {string} jobId 
         * @param {string | null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, flagged, topic_1, topic_2, variable_1.id, variable_2.id, study.id, study.doi, mechanism_type.
         * @param {string | null} [sort] Field to sort the response by. Supported fields for sorting: none.
         * @param {string | null} [search] Field to search within. Supported fields for searching: none.
         * @param {string | null} [fields] Comma-separated list of fields to include in the response.
         * @param {boolean | null} [includeTotal] Include total number of records in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMechanisticFindingsFromPubmedSearch(jobId: string, filter?: string | null, sort?: string | null, search?: string | null, fields?: string | null, includeTotal?: boolean | null, offset?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListResponseMechanisticFinding>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMechanisticFindingsFromPubmedSearch(jobId, filter, sort, search, fields, includeTotal, offset, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SynthesisApi.getMechanisticFindingsFromPubmedSearch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get information about a pubmed search synthesis job.
         * @summary Get pubmed search synthesis by ID
         * @param {string} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPubmedSearchSynthesisById(jobId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PubmedSearchSynthesisJob>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPubmedSearchSynthesisById(jobId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SynthesisApi.getPubmedSearchSynthesisById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get statements from pubmed search synthesis.
         * @summary Get statements from pubmed search synthesis
         * @param {string} jobId 
         * @param {boolean | null} [includeTotal] Include total number of records in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStatementsFromPubmedSearch(jobId: string, includeTotal?: boolean | null, offset?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListResponseStatement>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStatementsFromPubmedSearch(jobId, includeTotal, offset, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SynthesisApi.getStatementsFromPubmedSearch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get statistical findings from pubmed search synthesis.
         * @summary Get statistical findings from pubmed search synthesis
         * @param {string} jobId 
         * @param {string | null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, flagged, topic_1, topic_2, variable_1.id, variable_2.id, study.id, study.doi, statistic_type.
         * @param {string | null} [sort] Field to sort the response by. Supported fields for sorting: none.
         * @param {string | null} [search] Field to search within. Supported fields for searching: none.
         * @param {string | null} [fields] Comma-separated list of fields to include in the response.
         * @param {boolean | null} [includeTotal] Include total number of records in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStatisticalFindingsFromPubmedSearch(jobId: string, filter?: string | null, sort?: string | null, search?: string | null, fields?: string | null, includeTotal?: boolean | null, offset?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListResponseStatisticalFinding>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStatisticalFindingsFromPubmedSearch(jobId, filter, sort, search, fields, includeTotal, offset, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SynthesisApi.getStatisticalFindingsFromPubmedSearch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get studies from pubmed search synthesis.
         * @summary Get studies from pubmed search synthesis
         * @param {string} jobId 
         * @param {string | null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, doi, publish_date, cited_by, study_type.
         * @param {string | null} [sort] Field to sort the response by. Supported fields for sorting: publish_date, sample_size, cited_by.
         * @param {string | null} [search] Field to search within. Supported fields for searching: none.
         * @param {string | null} [fields] Comma-separated list of fields to include in the response.
         * @param {boolean | null} [includeTotal] Include total number of records in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStudiesFromPubmedSearch(jobId: string, filter?: string | null, sort?: string | null, search?: string | null, fields?: string | null, includeTotal?: boolean | null, offset?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListResponseStudy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStudiesFromPubmedSearch(jobId, filter, sort, search, fields, includeTotal, offset, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SynthesisApi.getStudiesFromPubmedSearch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get synthesis from pubmed search synthesis.
         * @summary Get synthesis from pubmed search synthesis
         * @param {string} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSynthesisFromPubmedSearch(jobId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Synthesis>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSynthesisFromPubmedSearch(jobId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SynthesisApi.getSynthesisFromPubmedSearch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Initiate pubmed search synthesis.
         * @summary Initiate pubmed search synthesis
         * @param {PubmedSearchSynthesisInput} pubmedSearchSynthesisInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async synthesizePubmedSearch(pubmedSearchSynthesisInput: PubmedSearchSynthesisInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.synthesizePubmedSearch(pubmedSearchSynthesisInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SynthesisApi.synthesizePubmedSearch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SynthesisApi - factory interface
 * @export
 */
export const SynthesisApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SynthesisApiFp(configuration)
    return {
        /**
         * Get statistical findings from pubmed search synthesis.
         * @summary Get mechanistic findings from pubmed search synthesis
         * @param {SynthesisApiGetMechanisticFindingsFromPubmedSearchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMechanisticFindingsFromPubmedSearch(requestParameters: SynthesisApiGetMechanisticFindingsFromPubmedSearchRequest, options?: RawAxiosRequestConfig): AxiosPromise<ListResponseMechanisticFinding> {
            return localVarFp.getMechanisticFindingsFromPubmedSearch(requestParameters.jobId, requestParameters.filter, requestParameters.sort, requestParameters.search, requestParameters.fields, requestParameters.includeTotal, requestParameters.offset, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get information about a pubmed search synthesis job.
         * @summary Get pubmed search synthesis by ID
         * @param {SynthesisApiGetPubmedSearchSynthesisByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPubmedSearchSynthesisById(requestParameters: SynthesisApiGetPubmedSearchSynthesisByIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<PubmedSearchSynthesisJob> {
            return localVarFp.getPubmedSearchSynthesisById(requestParameters.jobId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get statements from pubmed search synthesis.
         * @summary Get statements from pubmed search synthesis
         * @param {SynthesisApiGetStatementsFromPubmedSearchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatementsFromPubmedSearch(requestParameters: SynthesisApiGetStatementsFromPubmedSearchRequest, options?: RawAxiosRequestConfig): AxiosPromise<ListResponseStatement> {
            return localVarFp.getStatementsFromPubmedSearch(requestParameters.jobId, requestParameters.includeTotal, requestParameters.offset, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get statistical findings from pubmed search synthesis.
         * @summary Get statistical findings from pubmed search synthesis
         * @param {SynthesisApiGetStatisticalFindingsFromPubmedSearchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatisticalFindingsFromPubmedSearch(requestParameters: SynthesisApiGetStatisticalFindingsFromPubmedSearchRequest, options?: RawAxiosRequestConfig): AxiosPromise<ListResponseStatisticalFinding> {
            return localVarFp.getStatisticalFindingsFromPubmedSearch(requestParameters.jobId, requestParameters.filter, requestParameters.sort, requestParameters.search, requestParameters.fields, requestParameters.includeTotal, requestParameters.offset, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get studies from pubmed search synthesis.
         * @summary Get studies from pubmed search synthesis
         * @param {SynthesisApiGetStudiesFromPubmedSearchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudiesFromPubmedSearch(requestParameters: SynthesisApiGetStudiesFromPubmedSearchRequest, options?: RawAxiosRequestConfig): AxiosPromise<ListResponseStudy> {
            return localVarFp.getStudiesFromPubmedSearch(requestParameters.jobId, requestParameters.filter, requestParameters.sort, requestParameters.search, requestParameters.fields, requestParameters.includeTotal, requestParameters.offset, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get synthesis from pubmed search synthesis.
         * @summary Get synthesis from pubmed search synthesis
         * @param {SynthesisApiGetSynthesisFromPubmedSearchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSynthesisFromPubmedSearch(requestParameters: SynthesisApiGetSynthesisFromPubmedSearchRequest, options?: RawAxiosRequestConfig): AxiosPromise<Synthesis> {
            return localVarFp.getSynthesisFromPubmedSearch(requestParameters.jobId, options).then((request) => request(axios, basePath));
        },
        /**
         * Initiate pubmed search synthesis.
         * @summary Initiate pubmed search synthesis
         * @param {SynthesisApiSynthesizePubmedSearchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        synthesizePubmedSearch(requestParameters: SynthesisApiSynthesizePubmedSearchRequest, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.synthesizePubmedSearch(requestParameters.pubmedSearchSynthesisInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getMechanisticFindingsFromPubmedSearch operation in SynthesisApi.
 * @export
 * @interface SynthesisApiGetMechanisticFindingsFromPubmedSearchRequest
 */
export interface SynthesisApiGetMechanisticFindingsFromPubmedSearchRequest {
    /**
     * 
     * @type {string}
     * @memberof SynthesisApiGetMechanisticFindingsFromPubmedSearch
     */
    readonly jobId: string

    /**
     * Fields and values to filter the response by. Supported fields for filtering: id, flagged, topic_1, topic_2, variable_1.id, variable_2.id, study.id, study.doi, mechanism_type.
     * @type {string}
     * @memberof SynthesisApiGetMechanisticFindingsFromPubmedSearch
     */
    readonly filter?: string | null

    /**
     * Field to sort the response by. Supported fields for sorting: none.
     * @type {string}
     * @memberof SynthesisApiGetMechanisticFindingsFromPubmedSearch
     */
    readonly sort?: string | null

    /**
     * Field to search within. Supported fields for searching: none.
     * @type {string}
     * @memberof SynthesisApiGetMechanisticFindingsFromPubmedSearch
     */
    readonly search?: string | null

    /**
     * Comma-separated list of fields to include in the response.
     * @type {string}
     * @memberof SynthesisApiGetMechanisticFindingsFromPubmedSearch
     */
    readonly fields?: string | null

    /**
     * Include total number of records in the response.
     * @type {boolean}
     * @memberof SynthesisApiGetMechanisticFindingsFromPubmedSearch
     */
    readonly includeTotal?: boolean | null

    /**
     * Offset
     * @type {number}
     * @memberof SynthesisApiGetMechanisticFindingsFromPubmedSearch
     */
    readonly offset?: number

    /**
     * Limit
     * @type {number}
     * @memberof SynthesisApiGetMechanisticFindingsFromPubmedSearch
     */
    readonly limit?: number
}

/**
 * Request parameters for getPubmedSearchSynthesisById operation in SynthesisApi.
 * @export
 * @interface SynthesisApiGetPubmedSearchSynthesisByIdRequest
 */
export interface SynthesisApiGetPubmedSearchSynthesisByIdRequest {
    /**
     * 
     * @type {string}
     * @memberof SynthesisApiGetPubmedSearchSynthesisById
     */
    readonly jobId: string
}

/**
 * Request parameters for getStatementsFromPubmedSearch operation in SynthesisApi.
 * @export
 * @interface SynthesisApiGetStatementsFromPubmedSearchRequest
 */
export interface SynthesisApiGetStatementsFromPubmedSearchRequest {
    /**
     * 
     * @type {string}
     * @memberof SynthesisApiGetStatementsFromPubmedSearch
     */
    readonly jobId: string

    /**
     * Include total number of records in the response.
     * @type {boolean}
     * @memberof SynthesisApiGetStatementsFromPubmedSearch
     */
    readonly includeTotal?: boolean | null

    /**
     * Offset
     * @type {number}
     * @memberof SynthesisApiGetStatementsFromPubmedSearch
     */
    readonly offset?: number

    /**
     * Limit
     * @type {number}
     * @memberof SynthesisApiGetStatementsFromPubmedSearch
     */
    readonly limit?: number
}

/**
 * Request parameters for getStatisticalFindingsFromPubmedSearch operation in SynthesisApi.
 * @export
 * @interface SynthesisApiGetStatisticalFindingsFromPubmedSearchRequest
 */
export interface SynthesisApiGetStatisticalFindingsFromPubmedSearchRequest {
    /**
     * 
     * @type {string}
     * @memberof SynthesisApiGetStatisticalFindingsFromPubmedSearch
     */
    readonly jobId: string

    /**
     * Fields and values to filter the response by. Supported fields for filtering: id, flagged, topic_1, topic_2, variable_1.id, variable_2.id, study.id, study.doi, statistic_type.
     * @type {string}
     * @memberof SynthesisApiGetStatisticalFindingsFromPubmedSearch
     */
    readonly filter?: string | null

    /**
     * Field to sort the response by. Supported fields for sorting: none.
     * @type {string}
     * @memberof SynthesisApiGetStatisticalFindingsFromPubmedSearch
     */
    readonly sort?: string | null

    /**
     * Field to search within. Supported fields for searching: none.
     * @type {string}
     * @memberof SynthesisApiGetStatisticalFindingsFromPubmedSearch
     */
    readonly search?: string | null

    /**
     * Comma-separated list of fields to include in the response.
     * @type {string}
     * @memberof SynthesisApiGetStatisticalFindingsFromPubmedSearch
     */
    readonly fields?: string | null

    /**
     * Include total number of records in the response.
     * @type {boolean}
     * @memberof SynthesisApiGetStatisticalFindingsFromPubmedSearch
     */
    readonly includeTotal?: boolean | null

    /**
     * Offset
     * @type {number}
     * @memberof SynthesisApiGetStatisticalFindingsFromPubmedSearch
     */
    readonly offset?: number

    /**
     * Limit
     * @type {number}
     * @memberof SynthesisApiGetStatisticalFindingsFromPubmedSearch
     */
    readonly limit?: number
}

/**
 * Request parameters for getStudiesFromPubmedSearch operation in SynthesisApi.
 * @export
 * @interface SynthesisApiGetStudiesFromPubmedSearchRequest
 */
export interface SynthesisApiGetStudiesFromPubmedSearchRequest {
    /**
     * 
     * @type {string}
     * @memberof SynthesisApiGetStudiesFromPubmedSearch
     */
    readonly jobId: string

    /**
     * Fields and values to filter the response by. Supported fields for filtering: id, doi, publish_date, cited_by, study_type.
     * @type {string}
     * @memberof SynthesisApiGetStudiesFromPubmedSearch
     */
    readonly filter?: string | null

    /**
     * Field to sort the response by. Supported fields for sorting: publish_date, sample_size, cited_by.
     * @type {string}
     * @memberof SynthesisApiGetStudiesFromPubmedSearch
     */
    readonly sort?: string | null

    /**
     * Field to search within. Supported fields for searching: none.
     * @type {string}
     * @memberof SynthesisApiGetStudiesFromPubmedSearch
     */
    readonly search?: string | null

    /**
     * Comma-separated list of fields to include in the response.
     * @type {string}
     * @memberof SynthesisApiGetStudiesFromPubmedSearch
     */
    readonly fields?: string | null

    /**
     * Include total number of records in the response.
     * @type {boolean}
     * @memberof SynthesisApiGetStudiesFromPubmedSearch
     */
    readonly includeTotal?: boolean | null

    /**
     * Offset
     * @type {number}
     * @memberof SynthesisApiGetStudiesFromPubmedSearch
     */
    readonly offset?: number

    /**
     * Limit
     * @type {number}
     * @memberof SynthesisApiGetStudiesFromPubmedSearch
     */
    readonly limit?: number
}

/**
 * Request parameters for getSynthesisFromPubmedSearch operation in SynthesisApi.
 * @export
 * @interface SynthesisApiGetSynthesisFromPubmedSearchRequest
 */
export interface SynthesisApiGetSynthesisFromPubmedSearchRequest {
    /**
     * 
     * @type {string}
     * @memberof SynthesisApiGetSynthesisFromPubmedSearch
     */
    readonly jobId: string
}

/**
 * Request parameters for synthesizePubmedSearch operation in SynthesisApi.
 * @export
 * @interface SynthesisApiSynthesizePubmedSearchRequest
 */
export interface SynthesisApiSynthesizePubmedSearchRequest {
    /**
     * 
     * @type {PubmedSearchSynthesisInput}
     * @memberof SynthesisApiSynthesizePubmedSearch
     */
    readonly pubmedSearchSynthesisInput: PubmedSearchSynthesisInput
}

/**
 * SynthesisApi - object-oriented interface
 * @export
 * @class SynthesisApi
 * @extends {BaseAPI}
 */
export class SynthesisApi extends BaseAPI {
    /**
     * Get statistical findings from pubmed search synthesis.
     * @summary Get mechanistic findings from pubmed search synthesis
     * @param {SynthesisApiGetMechanisticFindingsFromPubmedSearchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SynthesisApi
     */
    public getMechanisticFindingsFromPubmedSearch(requestParameters: SynthesisApiGetMechanisticFindingsFromPubmedSearchRequest, options?: RawAxiosRequestConfig) {
        return SynthesisApiFp(this.configuration).getMechanisticFindingsFromPubmedSearch(requestParameters.jobId, requestParameters.filter, requestParameters.sort, requestParameters.search, requestParameters.fields, requestParameters.includeTotal, requestParameters.offset, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get information about a pubmed search synthesis job.
     * @summary Get pubmed search synthesis by ID
     * @param {SynthesisApiGetPubmedSearchSynthesisByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SynthesisApi
     */
    public getPubmedSearchSynthesisById(requestParameters: SynthesisApiGetPubmedSearchSynthesisByIdRequest, options?: RawAxiosRequestConfig) {
        return SynthesisApiFp(this.configuration).getPubmedSearchSynthesisById(requestParameters.jobId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get statements from pubmed search synthesis.
     * @summary Get statements from pubmed search synthesis
     * @param {SynthesisApiGetStatementsFromPubmedSearchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SynthesisApi
     */
    public getStatementsFromPubmedSearch(requestParameters: SynthesisApiGetStatementsFromPubmedSearchRequest, options?: RawAxiosRequestConfig) {
        return SynthesisApiFp(this.configuration).getStatementsFromPubmedSearch(requestParameters.jobId, requestParameters.includeTotal, requestParameters.offset, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get statistical findings from pubmed search synthesis.
     * @summary Get statistical findings from pubmed search synthesis
     * @param {SynthesisApiGetStatisticalFindingsFromPubmedSearchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SynthesisApi
     */
    public getStatisticalFindingsFromPubmedSearch(requestParameters: SynthesisApiGetStatisticalFindingsFromPubmedSearchRequest, options?: RawAxiosRequestConfig) {
        return SynthesisApiFp(this.configuration).getStatisticalFindingsFromPubmedSearch(requestParameters.jobId, requestParameters.filter, requestParameters.sort, requestParameters.search, requestParameters.fields, requestParameters.includeTotal, requestParameters.offset, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get studies from pubmed search synthesis.
     * @summary Get studies from pubmed search synthesis
     * @param {SynthesisApiGetStudiesFromPubmedSearchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SynthesisApi
     */
    public getStudiesFromPubmedSearch(requestParameters: SynthesisApiGetStudiesFromPubmedSearchRequest, options?: RawAxiosRequestConfig) {
        return SynthesisApiFp(this.configuration).getStudiesFromPubmedSearch(requestParameters.jobId, requestParameters.filter, requestParameters.sort, requestParameters.search, requestParameters.fields, requestParameters.includeTotal, requestParameters.offset, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get synthesis from pubmed search synthesis.
     * @summary Get synthesis from pubmed search synthesis
     * @param {SynthesisApiGetSynthesisFromPubmedSearchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SynthesisApi
     */
    public getSynthesisFromPubmedSearch(requestParameters: SynthesisApiGetSynthesisFromPubmedSearchRequest, options?: RawAxiosRequestConfig) {
        return SynthesisApiFp(this.configuration).getSynthesisFromPubmedSearch(requestParameters.jobId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Initiate pubmed search synthesis.
     * @summary Initiate pubmed search synthesis
     * @param {SynthesisApiSynthesizePubmedSearchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SynthesisApi
     */
    public synthesizePubmedSearch(requestParameters: SynthesisApiSynthesizePubmedSearchRequest, options?: RawAxiosRequestConfig) {
        return SynthesisApiFp(this.configuration).synthesizePubmedSearch(requestParameters.pubmedSearchSynthesisInput, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TopicsApi - axios parameter creator
 * @export
 */
export const TopicsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a topic by its ID.
         * @summary Get a topic
         * @param {string} topicId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTopicById: async (topicId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'topicId' is not null or undefined
            assertParamExists('getTopicById', 'topicId', topicId)
            const localVarPath = `/v0/topics/{topic_id}`
                .replace(`{${"topic_id"}}`, encodeURIComponent(String(topicId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of determinants for a given topic. These are formatted as `TopicPath`s, which include data about the relationship and the source topic.
         * @summary Get topic determinants
         * @param {string} topicId 
         * @param {string | null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial, topic.id, topic.wikidata_id, topic.category, topic.roles.
         * @param {string | null} [sort] Field to sort the response by. Supported fields for sorting: num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial.
         * @param {string | null} [search] Field to search within. Supported fields for searching: none.
         * @param {string | null} [fields] Comma-separated list of fields to include in the response.
         * @param {boolean | null} [includeTotal] Include total number of records in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTopicDeterminants: async (topicId: string, filter?: string | null, sort?: string | null, search?: string | null, fields?: string | null, includeTotal?: boolean | null, offset?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'topicId' is not null or undefined
            assertParamExists('getTopicDeterminants', 'topicId', topicId)
            const localVarPath = `/v0/topics/{topic_id}/determinants`
                .replace(`{${"topic_id"}}`, encodeURIComponent(String(topicId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (includeTotal !== undefined) {
                localVarQueryParameter['include_total'] = includeTotal;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of interventions for a given topic. These are formatted as `TopicPath`s, which include data about the relationship and the source topic.
         * @summary Get topic interventions
         * @param {string} topicId 
         * @param {string | null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial, topic.id, topic.wikidata_id, topic.category, topic.roles.
         * @param {string | null} [sort] Field to sort the response by. Supported fields for sorting: num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial.
         * @param {string | null} [search] Field to search within. Supported fields for searching: none.
         * @param {string | null} [fields] Comma-separated list of fields to include in the response.
         * @param {boolean | null} [includeTotal] Include total number of records in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTopicInterventions: async (topicId: string, filter?: string | null, sort?: string | null, search?: string | null, fields?: string | null, includeTotal?: boolean | null, offset?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'topicId' is not null or undefined
            assertParamExists('getTopicInterventions', 'topicId', topicId)
            const localVarPath = `/v0/topics/{topic_id}/interventions`
                .replace(`{${"topic_id"}}`, encodeURIComponent(String(topicId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (includeTotal !== undefined) {
                localVarQueryParameter['include_total'] = includeTotal;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of outcomes for a given topic. These are formatted as `TopicPath`s, which include data about the relationship and the target topic.
         * @summary Get topic outcomes
         * @param {string} topicId 
         * @param {string | null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial, topic.id, topic.wikidata_id, topic.category, topic.roles.
         * @param {string | null} [sort] Field to sort the response by. Supported fields for sorting: num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial.
         * @param {string | null} [search] Field to search within. Supported fields for searching: none.
         * @param {string | null} [fields] Comma-separated list of fields to include in the response.
         * @param {boolean | null} [includeTotal] Include total number of records in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTopicOutcomes: async (topicId: string, filter?: string | null, sort?: string | null, search?: string | null, fields?: string | null, includeTotal?: boolean | null, offset?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'topicId' is not null or undefined
            assertParamExists('getTopicOutcomes', 'topicId', topicId)
            const localVarPath = `/v0/topics/{topic_id}/outcomes`
                .replace(`{${"topic_id"}}`, encodeURIComponent(String(topicId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (includeTotal !== undefined) {
                localVarQueryParameter['include_total'] = includeTotal;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of the relationships that include a given topic as the source or target topic.
         * @summary Get topic relationships
         * @param {string} topicId 
         * @param {string | null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial, source_topic.id, source_topic.wikidata_id, source_topic.category, source_topic.roles, target_topic.id, target_topic.wikidata_id, target_topic.category, target_topic.roles.
         * @param {string | null} [sort] Field to sort the response by. Supported fields for sorting: num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial.
         * @param {string | null} [search] Field to search within. Supported fields for searching: none.
         * @param {string | null} [fields] Comma-separated list of fields to include in the response.
         * @param {boolean | null} [includeTotal] Include total number of records in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTopicRelationships: async (topicId: string, filter?: string | null, sort?: string | null, search?: string | null, fields?: string | null, includeTotal?: boolean | null, offset?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'topicId' is not null or undefined
            assertParamExists('getTopicRelationships', 'topicId', topicId)
            const localVarPath = `/v0/topics/{topic_id}/relationships`
                .replace(`{${"topic_id"}}`, encodeURIComponent(String(topicId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (includeTotal !== undefined) {
                localVarQueryParameter['include_total'] = includeTotal;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of the variables that have been matched to a given topic.
         * @summary Get topic variables
         * @param {string} topicId 
         * @param {string | null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, num_studies, topic.
         * @param {string | null} [sort] Field to sort the response by. Supported fields for sorting: num_studies.
         * @param {string | null} [search] Field to search within. Supported fields for searching: name.
         * @param {string | null} [fields] Comma-separated list of fields to include in the response.
         * @param {boolean | null} [includeTotal] Include total number of records in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTopicVariables: async (topicId: string, filter?: string | null, sort?: string | null, search?: string | null, fields?: string | null, includeTotal?: boolean | null, offset?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'topicId' is not null or undefined
            assertParamExists('getTopicVariables', 'topicId', topicId)
            const localVarPath = `/v0/topics/{topic_id}/variables`
                .replace(`{${"topic_id"}}`, encodeURIComponent(String(topicId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (includeTotal !== undefined) {
                localVarQueryParameter['include_total'] = includeTotal;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of topics.
         * @summary Get topics
         * @param {string | null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, wikidata_id, category, roles.
         * @param {string | null} [sort] Field to sort the response by. Supported fields for sorting: none.
         * @param {string | null} [search] Field to search within. Supported fields for searching: name.
         * @param {string | null} [fields] Comma-separated list of fields to include in the response.
         * @param {boolean | null} [includeTotal] Include total number of records in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTopics: async (filter?: string | null, sort?: string | null, search?: string | null, fields?: string | null, includeTotal?: boolean | null, offset?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v0/topics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (includeTotal !== undefined) {
                localVarQueryParameter['include_total'] = includeTotal;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TopicsApi - functional programming interface
 * @export
 */
export const TopicsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TopicsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a topic by its ID.
         * @summary Get a topic
         * @param {string} topicId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTopicById(topicId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Topic>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTopicById(topicId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TopicsApi.getTopicById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of determinants for a given topic. These are formatted as `TopicPath`s, which include data about the relationship and the source topic.
         * @summary Get topic determinants
         * @param {string} topicId 
         * @param {string | null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial, topic.id, topic.wikidata_id, topic.category, topic.roles.
         * @param {string | null} [sort] Field to sort the response by. Supported fields for sorting: num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial.
         * @param {string | null} [search] Field to search within. Supported fields for searching: none.
         * @param {string | null} [fields] Comma-separated list of fields to include in the response.
         * @param {boolean | null} [includeTotal] Include total number of records in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTopicDeterminants(topicId: string, filter?: string | null, sort?: string | null, search?: string | null, fields?: string | null, includeTotal?: boolean | null, offset?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListResponseTopicPath>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTopicDeterminants(topicId, filter, sort, search, fields, includeTotal, offset, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TopicsApi.getTopicDeterminants']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of interventions for a given topic. These are formatted as `TopicPath`s, which include data about the relationship and the source topic.
         * @summary Get topic interventions
         * @param {string} topicId 
         * @param {string | null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial, topic.id, topic.wikidata_id, topic.category, topic.roles.
         * @param {string | null} [sort] Field to sort the response by. Supported fields for sorting: num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial.
         * @param {string | null} [search] Field to search within. Supported fields for searching: none.
         * @param {string | null} [fields] Comma-separated list of fields to include in the response.
         * @param {boolean | null} [includeTotal] Include total number of records in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTopicInterventions(topicId: string, filter?: string | null, sort?: string | null, search?: string | null, fields?: string | null, includeTotal?: boolean | null, offset?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListResponseTopicPath>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTopicInterventions(topicId, filter, sort, search, fields, includeTotal, offset, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TopicsApi.getTopicInterventions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of outcomes for a given topic. These are formatted as `TopicPath`s, which include data about the relationship and the target topic.
         * @summary Get topic outcomes
         * @param {string} topicId 
         * @param {string | null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial, topic.id, topic.wikidata_id, topic.category, topic.roles.
         * @param {string | null} [sort] Field to sort the response by. Supported fields for sorting: num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial.
         * @param {string | null} [search] Field to search within. Supported fields for searching: none.
         * @param {string | null} [fields] Comma-separated list of fields to include in the response.
         * @param {boolean | null} [includeTotal] Include total number of records in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTopicOutcomes(topicId: string, filter?: string | null, sort?: string | null, search?: string | null, fields?: string | null, includeTotal?: boolean | null, offset?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListResponseTopicPath>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTopicOutcomes(topicId, filter, sort, search, fields, includeTotal, offset, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TopicsApi.getTopicOutcomes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of the relationships that include a given topic as the source or target topic.
         * @summary Get topic relationships
         * @param {string} topicId 
         * @param {string | null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial, source_topic.id, source_topic.wikidata_id, source_topic.category, source_topic.roles, target_topic.id, target_topic.wikidata_id, target_topic.category, target_topic.roles.
         * @param {string | null} [sort] Field to sort the response by. Supported fields for sorting: num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial.
         * @param {string | null} [search] Field to search within. Supported fields for searching: none.
         * @param {string | null} [fields] Comma-separated list of fields to include in the response.
         * @param {boolean | null} [includeTotal] Include total number of records in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTopicRelationships(topicId: string, filter?: string | null, sort?: string | null, search?: string | null, fields?: string | null, includeTotal?: boolean | null, offset?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListResponseRelationship>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTopicRelationships(topicId, filter, sort, search, fields, includeTotal, offset, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TopicsApi.getTopicRelationships']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of the variables that have been matched to a given topic.
         * @summary Get topic variables
         * @param {string} topicId 
         * @param {string | null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, num_studies, topic.
         * @param {string | null} [sort] Field to sort the response by. Supported fields for sorting: num_studies.
         * @param {string | null} [search] Field to search within. Supported fields for searching: name.
         * @param {string | null} [fields] Comma-separated list of fields to include in the response.
         * @param {boolean | null} [includeTotal] Include total number of records in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTopicVariables(topicId: string, filter?: string | null, sort?: string | null, search?: string | null, fields?: string | null, includeTotal?: boolean | null, offset?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListResponseVariable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTopicVariables(topicId, filter, sort, search, fields, includeTotal, offset, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TopicsApi.getTopicVariables']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of topics.
         * @summary Get topics
         * @param {string | null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, wikidata_id, category, roles.
         * @param {string | null} [sort] Field to sort the response by. Supported fields for sorting: none.
         * @param {string | null} [search] Field to search within. Supported fields for searching: name.
         * @param {string | null} [fields] Comma-separated list of fields to include in the response.
         * @param {boolean | null} [includeTotal] Include total number of records in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTopics(filter?: string | null, sort?: string | null, search?: string | null, fields?: string | null, includeTotal?: boolean | null, offset?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListResponseTopic>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTopics(filter, sort, search, fields, includeTotal, offset, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TopicsApi.getTopics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TopicsApi - factory interface
 * @export
 */
export const TopicsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TopicsApiFp(configuration)
    return {
        /**
         * Get a topic by its ID.
         * @summary Get a topic
         * @param {TopicsApiGetTopicByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTopicById(requestParameters: TopicsApiGetTopicByIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<Topic> {
            return localVarFp.getTopicById(requestParameters.topicId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of determinants for a given topic. These are formatted as `TopicPath`s, which include data about the relationship and the source topic.
         * @summary Get topic determinants
         * @param {TopicsApiGetTopicDeterminantsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTopicDeterminants(requestParameters: TopicsApiGetTopicDeterminantsRequest, options?: RawAxiosRequestConfig): AxiosPromise<ListResponseTopicPath> {
            return localVarFp.getTopicDeterminants(requestParameters.topicId, requestParameters.filter, requestParameters.sort, requestParameters.search, requestParameters.fields, requestParameters.includeTotal, requestParameters.offset, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of interventions for a given topic. These are formatted as `TopicPath`s, which include data about the relationship and the source topic.
         * @summary Get topic interventions
         * @param {TopicsApiGetTopicInterventionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTopicInterventions(requestParameters: TopicsApiGetTopicInterventionsRequest, options?: RawAxiosRequestConfig): AxiosPromise<ListResponseTopicPath> {
            return localVarFp.getTopicInterventions(requestParameters.topicId, requestParameters.filter, requestParameters.sort, requestParameters.search, requestParameters.fields, requestParameters.includeTotal, requestParameters.offset, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of outcomes for a given topic. These are formatted as `TopicPath`s, which include data about the relationship and the target topic.
         * @summary Get topic outcomes
         * @param {TopicsApiGetTopicOutcomesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTopicOutcomes(requestParameters: TopicsApiGetTopicOutcomesRequest, options?: RawAxiosRequestConfig): AxiosPromise<ListResponseTopicPath> {
            return localVarFp.getTopicOutcomes(requestParameters.topicId, requestParameters.filter, requestParameters.sort, requestParameters.search, requestParameters.fields, requestParameters.includeTotal, requestParameters.offset, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of the relationships that include a given topic as the source or target topic.
         * @summary Get topic relationships
         * @param {TopicsApiGetTopicRelationshipsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTopicRelationships(requestParameters: TopicsApiGetTopicRelationshipsRequest, options?: RawAxiosRequestConfig): AxiosPromise<ListResponseRelationship> {
            return localVarFp.getTopicRelationships(requestParameters.topicId, requestParameters.filter, requestParameters.sort, requestParameters.search, requestParameters.fields, requestParameters.includeTotal, requestParameters.offset, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of the variables that have been matched to a given topic.
         * @summary Get topic variables
         * @param {TopicsApiGetTopicVariablesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTopicVariables(requestParameters: TopicsApiGetTopicVariablesRequest, options?: RawAxiosRequestConfig): AxiosPromise<ListResponseVariable> {
            return localVarFp.getTopicVariables(requestParameters.topicId, requestParameters.filter, requestParameters.sort, requestParameters.search, requestParameters.fields, requestParameters.includeTotal, requestParameters.offset, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of topics.
         * @summary Get topics
         * @param {TopicsApiGetTopicsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTopics(requestParameters: TopicsApiGetTopicsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<ListResponseTopic> {
            return localVarFp.getTopics(requestParameters.filter, requestParameters.sort, requestParameters.search, requestParameters.fields, requestParameters.includeTotal, requestParameters.offset, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getTopicById operation in TopicsApi.
 * @export
 * @interface TopicsApiGetTopicByIdRequest
 */
export interface TopicsApiGetTopicByIdRequest {
    /**
     * 
     * @type {string}
     * @memberof TopicsApiGetTopicById
     */
    readonly topicId: string
}

/**
 * Request parameters for getTopicDeterminants operation in TopicsApi.
 * @export
 * @interface TopicsApiGetTopicDeterminantsRequest
 */
export interface TopicsApiGetTopicDeterminantsRequest {
    /**
     * 
     * @type {string}
     * @memberof TopicsApiGetTopicDeterminants
     */
    readonly topicId: string

    /**
     * Fields and values to filter the response by. Supported fields for filtering: id, num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial, topic.id, topic.wikidata_id, topic.category, topic.roles.
     * @type {string}
     * @memberof TopicsApiGetTopicDeterminants
     */
    readonly filter?: string | null

    /**
     * Field to sort the response by. Supported fields for sorting: num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial.
     * @type {string}
     * @memberof TopicsApiGetTopicDeterminants
     */
    readonly sort?: string | null

    /**
     * Field to search within. Supported fields for searching: none.
     * @type {string}
     * @memberof TopicsApiGetTopicDeterminants
     */
    readonly search?: string | null

    /**
     * Comma-separated list of fields to include in the response.
     * @type {string}
     * @memberof TopicsApiGetTopicDeterminants
     */
    readonly fields?: string | null

    /**
     * Include total number of records in the response.
     * @type {boolean}
     * @memberof TopicsApiGetTopicDeterminants
     */
    readonly includeTotal?: boolean | null

    /**
     * Offset
     * @type {number}
     * @memberof TopicsApiGetTopicDeterminants
     */
    readonly offset?: number

    /**
     * Limit
     * @type {number}
     * @memberof TopicsApiGetTopicDeterminants
     */
    readonly limit?: number
}

/**
 * Request parameters for getTopicInterventions operation in TopicsApi.
 * @export
 * @interface TopicsApiGetTopicInterventionsRequest
 */
export interface TopicsApiGetTopicInterventionsRequest {
    /**
     * 
     * @type {string}
     * @memberof TopicsApiGetTopicInterventions
     */
    readonly topicId: string

    /**
     * Fields and values to filter the response by. Supported fields for filtering: id, num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial, topic.id, topic.wikidata_id, topic.category, topic.roles.
     * @type {string}
     * @memberof TopicsApiGetTopicInterventions
     */
    readonly filter?: string | null

    /**
     * Field to sort the response by. Supported fields for sorting: num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial.
     * @type {string}
     * @memberof TopicsApiGetTopicInterventions
     */
    readonly sort?: string | null

    /**
     * Field to search within. Supported fields for searching: none.
     * @type {string}
     * @memberof TopicsApiGetTopicInterventions
     */
    readonly search?: string | null

    /**
     * Comma-separated list of fields to include in the response.
     * @type {string}
     * @memberof TopicsApiGetTopicInterventions
     */
    readonly fields?: string | null

    /**
     * Include total number of records in the response.
     * @type {boolean}
     * @memberof TopicsApiGetTopicInterventions
     */
    readonly includeTotal?: boolean | null

    /**
     * Offset
     * @type {number}
     * @memberof TopicsApiGetTopicInterventions
     */
    readonly offset?: number

    /**
     * Limit
     * @type {number}
     * @memberof TopicsApiGetTopicInterventions
     */
    readonly limit?: number
}

/**
 * Request parameters for getTopicOutcomes operation in TopicsApi.
 * @export
 * @interface TopicsApiGetTopicOutcomesRequest
 */
export interface TopicsApiGetTopicOutcomesRequest {
    /**
     * 
     * @type {string}
     * @memberof TopicsApiGetTopicOutcomes
     */
    readonly topicId: string

    /**
     * Fields and values to filter the response by. Supported fields for filtering: id, num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial, topic.id, topic.wikidata_id, topic.category, topic.roles.
     * @type {string}
     * @memberof TopicsApiGetTopicOutcomes
     */
    readonly filter?: string | null

    /**
     * Field to sort the response by. Supported fields for sorting: num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial.
     * @type {string}
     * @memberof TopicsApiGetTopicOutcomes
     */
    readonly sort?: string | null

    /**
     * Field to search within. Supported fields for searching: none.
     * @type {string}
     * @memberof TopicsApiGetTopicOutcomes
     */
    readonly search?: string | null

    /**
     * Comma-separated list of fields to include in the response.
     * @type {string}
     * @memberof TopicsApiGetTopicOutcomes
     */
    readonly fields?: string | null

    /**
     * Include total number of records in the response.
     * @type {boolean}
     * @memberof TopicsApiGetTopicOutcomes
     */
    readonly includeTotal?: boolean | null

    /**
     * Offset
     * @type {number}
     * @memberof TopicsApiGetTopicOutcomes
     */
    readonly offset?: number

    /**
     * Limit
     * @type {number}
     * @memberof TopicsApiGetTopicOutcomes
     */
    readonly limit?: number
}

/**
 * Request parameters for getTopicRelationships operation in TopicsApi.
 * @export
 * @interface TopicsApiGetTopicRelationshipsRequest
 */
export interface TopicsApiGetTopicRelationshipsRequest {
    /**
     * 
     * @type {string}
     * @memberof TopicsApiGetTopicRelationships
     */
    readonly topicId: string

    /**
     * Fields and values to filter the response by. Supported fields for filtering: id, num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial, source_topic.id, source_topic.wikidata_id, source_topic.category, source_topic.roles, target_topic.id, target_topic.wikidata_id, target_topic.category, target_topic.roles.
     * @type {string}
     * @memberof TopicsApiGetTopicRelationships
     */
    readonly filter?: string | null

    /**
     * Field to sort the response by. Supported fields for sorting: num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial.
     * @type {string}
     * @memberof TopicsApiGetTopicRelationships
     */
    readonly sort?: string | null

    /**
     * Field to search within. Supported fields for searching: none.
     * @type {string}
     * @memberof TopicsApiGetTopicRelationships
     */
    readonly search?: string | null

    /**
     * Comma-separated list of fields to include in the response.
     * @type {string}
     * @memberof TopicsApiGetTopicRelationships
     */
    readonly fields?: string | null

    /**
     * Include total number of records in the response.
     * @type {boolean}
     * @memberof TopicsApiGetTopicRelationships
     */
    readonly includeTotal?: boolean | null

    /**
     * Offset
     * @type {number}
     * @memberof TopicsApiGetTopicRelationships
     */
    readonly offset?: number

    /**
     * Limit
     * @type {number}
     * @memberof TopicsApiGetTopicRelationships
     */
    readonly limit?: number
}

/**
 * Request parameters for getTopicVariables operation in TopicsApi.
 * @export
 * @interface TopicsApiGetTopicVariablesRequest
 */
export interface TopicsApiGetTopicVariablesRequest {
    /**
     * 
     * @type {string}
     * @memberof TopicsApiGetTopicVariables
     */
    readonly topicId: string

    /**
     * Fields and values to filter the response by. Supported fields for filtering: id, num_studies, topic.
     * @type {string}
     * @memberof TopicsApiGetTopicVariables
     */
    readonly filter?: string | null

    /**
     * Field to sort the response by. Supported fields for sorting: num_studies.
     * @type {string}
     * @memberof TopicsApiGetTopicVariables
     */
    readonly sort?: string | null

    /**
     * Field to search within. Supported fields for searching: name.
     * @type {string}
     * @memberof TopicsApiGetTopicVariables
     */
    readonly search?: string | null

    /**
     * Comma-separated list of fields to include in the response.
     * @type {string}
     * @memberof TopicsApiGetTopicVariables
     */
    readonly fields?: string | null

    /**
     * Include total number of records in the response.
     * @type {boolean}
     * @memberof TopicsApiGetTopicVariables
     */
    readonly includeTotal?: boolean | null

    /**
     * Offset
     * @type {number}
     * @memberof TopicsApiGetTopicVariables
     */
    readonly offset?: number

    /**
     * Limit
     * @type {number}
     * @memberof TopicsApiGetTopicVariables
     */
    readonly limit?: number
}

/**
 * Request parameters for getTopics operation in TopicsApi.
 * @export
 * @interface TopicsApiGetTopicsRequest
 */
export interface TopicsApiGetTopicsRequest {
    /**
     * Fields and values to filter the response by. Supported fields for filtering: id, wikidata_id, category, roles.
     * @type {string}
     * @memberof TopicsApiGetTopics
     */
    readonly filter?: string | null

    /**
     * Field to sort the response by. Supported fields for sorting: none.
     * @type {string}
     * @memberof TopicsApiGetTopics
     */
    readonly sort?: string | null

    /**
     * Field to search within. Supported fields for searching: name.
     * @type {string}
     * @memberof TopicsApiGetTopics
     */
    readonly search?: string | null

    /**
     * Comma-separated list of fields to include in the response.
     * @type {string}
     * @memberof TopicsApiGetTopics
     */
    readonly fields?: string | null

    /**
     * Include total number of records in the response.
     * @type {boolean}
     * @memberof TopicsApiGetTopics
     */
    readonly includeTotal?: boolean | null

    /**
     * Offset
     * @type {number}
     * @memberof TopicsApiGetTopics
     */
    readonly offset?: number

    /**
     * Limit
     * @type {number}
     * @memberof TopicsApiGetTopics
     */
    readonly limit?: number
}

/**
 * TopicsApi - object-oriented interface
 * @export
 * @class TopicsApi
 * @extends {BaseAPI}
 */
export class TopicsApi extends BaseAPI {
    /**
     * Get a topic by its ID.
     * @summary Get a topic
     * @param {TopicsApiGetTopicByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TopicsApi
     */
    public getTopicById(requestParameters: TopicsApiGetTopicByIdRequest, options?: RawAxiosRequestConfig) {
        return TopicsApiFp(this.configuration).getTopicById(requestParameters.topicId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of determinants for a given topic. These are formatted as `TopicPath`s, which include data about the relationship and the source topic.
     * @summary Get topic determinants
     * @param {TopicsApiGetTopicDeterminantsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TopicsApi
     */
    public getTopicDeterminants(requestParameters: TopicsApiGetTopicDeterminantsRequest, options?: RawAxiosRequestConfig) {
        return TopicsApiFp(this.configuration).getTopicDeterminants(requestParameters.topicId, requestParameters.filter, requestParameters.sort, requestParameters.search, requestParameters.fields, requestParameters.includeTotal, requestParameters.offset, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of interventions for a given topic. These are formatted as `TopicPath`s, which include data about the relationship and the source topic.
     * @summary Get topic interventions
     * @param {TopicsApiGetTopicInterventionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TopicsApi
     */
    public getTopicInterventions(requestParameters: TopicsApiGetTopicInterventionsRequest, options?: RawAxiosRequestConfig) {
        return TopicsApiFp(this.configuration).getTopicInterventions(requestParameters.topicId, requestParameters.filter, requestParameters.sort, requestParameters.search, requestParameters.fields, requestParameters.includeTotal, requestParameters.offset, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of outcomes for a given topic. These are formatted as `TopicPath`s, which include data about the relationship and the target topic.
     * @summary Get topic outcomes
     * @param {TopicsApiGetTopicOutcomesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TopicsApi
     */
    public getTopicOutcomes(requestParameters: TopicsApiGetTopicOutcomesRequest, options?: RawAxiosRequestConfig) {
        return TopicsApiFp(this.configuration).getTopicOutcomes(requestParameters.topicId, requestParameters.filter, requestParameters.sort, requestParameters.search, requestParameters.fields, requestParameters.includeTotal, requestParameters.offset, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of the relationships that include a given topic as the source or target topic.
     * @summary Get topic relationships
     * @param {TopicsApiGetTopicRelationshipsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TopicsApi
     */
    public getTopicRelationships(requestParameters: TopicsApiGetTopicRelationshipsRequest, options?: RawAxiosRequestConfig) {
        return TopicsApiFp(this.configuration).getTopicRelationships(requestParameters.topicId, requestParameters.filter, requestParameters.sort, requestParameters.search, requestParameters.fields, requestParameters.includeTotal, requestParameters.offset, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of the variables that have been matched to a given topic.
     * @summary Get topic variables
     * @param {TopicsApiGetTopicVariablesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TopicsApi
     */
    public getTopicVariables(requestParameters: TopicsApiGetTopicVariablesRequest, options?: RawAxiosRequestConfig) {
        return TopicsApiFp(this.configuration).getTopicVariables(requestParameters.topicId, requestParameters.filter, requestParameters.sort, requestParameters.search, requestParameters.fields, requestParameters.includeTotal, requestParameters.offset, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of topics.
     * @summary Get topics
     * @param {TopicsApiGetTopicsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TopicsApi
     */
    public getTopics(requestParameters: TopicsApiGetTopicsRequest = {}, options?: RawAxiosRequestConfig) {
        return TopicsApiFp(this.configuration).getTopics(requestParameters.filter, requestParameters.sort, requestParameters.search, requestParameters.fields, requestParameters.includeTotal, requestParameters.offset, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VariablesApi - axios parameter creator
 * @export
 */
export const VariablesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a variable by its ID.
         * @summary Get a variable
         * @param {string} variableId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVariableById: async (variableId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'variableId' is not null or undefined
            assertParamExists('getVariableById', 'variableId', variableId)
            const localVarPath = `/v0/variables/{variable_id}`
                .replace(`{${"variable_id"}}`, encodeURIComponent(String(variableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of the statistical findings that include a given variable.
         * @summary Get variable statistical findings
         * @param {string} variableId 
         * @param {string | null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, flagged, topic_1, topic_2, variable_1.id, variable_2.id, study.id, study.doi, statistic_type.
         * @param {string | null} [sort] Field to sort the response by. Supported fields for sorting: none.
         * @param {string | null} [search] Field to search within. Supported fields for searching: none.
         * @param {string | null} [fields] Comma-separated list of fields to include in the response.
         * @param {boolean | null} [includeTotal] Include total number of records in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVariableStatisticalFindings: async (variableId: string, filter?: string | null, sort?: string | null, search?: string | null, fields?: string | null, includeTotal?: boolean | null, offset?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'variableId' is not null or undefined
            assertParamExists('getVariableStatisticalFindings', 'variableId', variableId)
            const localVarPath = `/v0/variables/{variable_id}/statistical_findings`
                .replace(`{${"variable_id"}}`, encodeURIComponent(String(variableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (includeTotal !== undefined) {
                localVarQueryParameter['include_total'] = includeTotal;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of variables.
         * @summary Get variables
         * @param {string | null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, num_studies, topic.
         * @param {string | null} [sort] Field to sort the response by. Supported fields for sorting: num_studies.
         * @param {string | null} [search] Field to search within. Supported fields for searching: name.
         * @param {string | null} [fields] Comma-separated list of fields to include in the response.
         * @param {boolean | null} [includeTotal] Include total number of records in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVariables: async (filter?: string | null, sort?: string | null, search?: string | null, fields?: string | null, includeTotal?: boolean | null, offset?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v0/variables`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (includeTotal !== undefined) {
                localVarQueryParameter['include_total'] = includeTotal;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VariablesApi - functional programming interface
 * @export
 */
export const VariablesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VariablesApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a variable by its ID.
         * @summary Get a variable
         * @param {string} variableId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVariableById(variableId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Variable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVariableById(variableId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VariablesApi.getVariableById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of the statistical findings that include a given variable.
         * @summary Get variable statistical findings
         * @param {string} variableId 
         * @param {string | null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, flagged, topic_1, topic_2, variable_1.id, variable_2.id, study.id, study.doi, statistic_type.
         * @param {string | null} [sort] Field to sort the response by. Supported fields for sorting: none.
         * @param {string | null} [search] Field to search within. Supported fields for searching: none.
         * @param {string | null} [fields] Comma-separated list of fields to include in the response.
         * @param {boolean | null} [includeTotal] Include total number of records in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVariableStatisticalFindings(variableId: string, filter?: string | null, sort?: string | null, search?: string | null, fields?: string | null, includeTotal?: boolean | null, offset?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListResponseStatisticalFinding>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVariableStatisticalFindings(variableId, filter, sort, search, fields, includeTotal, offset, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VariablesApi.getVariableStatisticalFindings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of variables.
         * @summary Get variables
         * @param {string | null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, num_studies, topic.
         * @param {string | null} [sort] Field to sort the response by. Supported fields for sorting: num_studies.
         * @param {string | null} [search] Field to search within. Supported fields for searching: name.
         * @param {string | null} [fields] Comma-separated list of fields to include in the response.
         * @param {boolean | null} [includeTotal] Include total number of records in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVariables(filter?: string | null, sort?: string | null, search?: string | null, fields?: string | null, includeTotal?: boolean | null, offset?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListResponseVariable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVariables(filter, sort, search, fields, includeTotal, offset, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VariablesApi.getVariables']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VariablesApi - factory interface
 * @export
 */
export const VariablesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VariablesApiFp(configuration)
    return {
        /**
         * Get a variable by its ID.
         * @summary Get a variable
         * @param {VariablesApiGetVariableByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVariableById(requestParameters: VariablesApiGetVariableByIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<Variable> {
            return localVarFp.getVariableById(requestParameters.variableId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of the statistical findings that include a given variable.
         * @summary Get variable statistical findings
         * @param {VariablesApiGetVariableStatisticalFindingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVariableStatisticalFindings(requestParameters: VariablesApiGetVariableStatisticalFindingsRequest, options?: RawAxiosRequestConfig): AxiosPromise<ListResponseStatisticalFinding> {
            return localVarFp.getVariableStatisticalFindings(requestParameters.variableId, requestParameters.filter, requestParameters.sort, requestParameters.search, requestParameters.fields, requestParameters.includeTotal, requestParameters.offset, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of variables.
         * @summary Get variables
         * @param {VariablesApiGetVariablesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVariables(requestParameters: VariablesApiGetVariablesRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<ListResponseVariable> {
            return localVarFp.getVariables(requestParameters.filter, requestParameters.sort, requestParameters.search, requestParameters.fields, requestParameters.includeTotal, requestParameters.offset, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getVariableById operation in VariablesApi.
 * @export
 * @interface VariablesApiGetVariableByIdRequest
 */
export interface VariablesApiGetVariableByIdRequest {
    /**
     * 
     * @type {string}
     * @memberof VariablesApiGetVariableById
     */
    readonly variableId: string
}

/**
 * Request parameters for getVariableStatisticalFindings operation in VariablesApi.
 * @export
 * @interface VariablesApiGetVariableStatisticalFindingsRequest
 */
export interface VariablesApiGetVariableStatisticalFindingsRequest {
    /**
     * 
     * @type {string}
     * @memberof VariablesApiGetVariableStatisticalFindings
     */
    readonly variableId: string

    /**
     * Fields and values to filter the response by. Supported fields for filtering: id, flagged, topic_1, topic_2, variable_1.id, variable_2.id, study.id, study.doi, statistic_type.
     * @type {string}
     * @memberof VariablesApiGetVariableStatisticalFindings
     */
    readonly filter?: string | null

    /**
     * Field to sort the response by. Supported fields for sorting: none.
     * @type {string}
     * @memberof VariablesApiGetVariableStatisticalFindings
     */
    readonly sort?: string | null

    /**
     * Field to search within. Supported fields for searching: none.
     * @type {string}
     * @memberof VariablesApiGetVariableStatisticalFindings
     */
    readonly search?: string | null

    /**
     * Comma-separated list of fields to include in the response.
     * @type {string}
     * @memberof VariablesApiGetVariableStatisticalFindings
     */
    readonly fields?: string | null

    /**
     * Include total number of records in the response.
     * @type {boolean}
     * @memberof VariablesApiGetVariableStatisticalFindings
     */
    readonly includeTotal?: boolean | null

    /**
     * Offset
     * @type {number}
     * @memberof VariablesApiGetVariableStatisticalFindings
     */
    readonly offset?: number

    /**
     * Limit
     * @type {number}
     * @memberof VariablesApiGetVariableStatisticalFindings
     */
    readonly limit?: number
}

/**
 * Request parameters for getVariables operation in VariablesApi.
 * @export
 * @interface VariablesApiGetVariablesRequest
 */
export interface VariablesApiGetVariablesRequest {
    /**
     * Fields and values to filter the response by. Supported fields for filtering: id, num_studies, topic.
     * @type {string}
     * @memberof VariablesApiGetVariables
     */
    readonly filter?: string | null

    /**
     * Field to sort the response by. Supported fields for sorting: num_studies.
     * @type {string}
     * @memberof VariablesApiGetVariables
     */
    readonly sort?: string | null

    /**
     * Field to search within. Supported fields for searching: name.
     * @type {string}
     * @memberof VariablesApiGetVariables
     */
    readonly search?: string | null

    /**
     * Comma-separated list of fields to include in the response.
     * @type {string}
     * @memberof VariablesApiGetVariables
     */
    readonly fields?: string | null

    /**
     * Include total number of records in the response.
     * @type {boolean}
     * @memberof VariablesApiGetVariables
     */
    readonly includeTotal?: boolean | null

    /**
     * Offset
     * @type {number}
     * @memberof VariablesApiGetVariables
     */
    readonly offset?: number

    /**
     * Limit
     * @type {number}
     * @memberof VariablesApiGetVariables
     */
    readonly limit?: number
}

/**
 * VariablesApi - object-oriented interface
 * @export
 * @class VariablesApi
 * @extends {BaseAPI}
 */
export class VariablesApi extends BaseAPI {
    /**
     * Get a variable by its ID.
     * @summary Get a variable
     * @param {VariablesApiGetVariableByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariablesApi
     */
    public getVariableById(requestParameters: VariablesApiGetVariableByIdRequest, options?: RawAxiosRequestConfig) {
        return VariablesApiFp(this.configuration).getVariableById(requestParameters.variableId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of the statistical findings that include a given variable.
     * @summary Get variable statistical findings
     * @param {VariablesApiGetVariableStatisticalFindingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariablesApi
     */
    public getVariableStatisticalFindings(requestParameters: VariablesApiGetVariableStatisticalFindingsRequest, options?: RawAxiosRequestConfig) {
        return VariablesApiFp(this.configuration).getVariableStatisticalFindings(requestParameters.variableId, requestParameters.filter, requestParameters.sort, requestParameters.search, requestParameters.fields, requestParameters.includeTotal, requestParameters.offset, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of variables.
     * @summary Get variables
     * @param {VariablesApiGetVariablesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariablesApi
     */
    public getVariables(requestParameters: VariablesApiGetVariablesRequest = {}, options?: RawAxiosRequestConfig) {
        return VariablesApiFp(this.configuration).getVariables(requestParameters.filter, requestParameters.sort, requestParameters.search, requestParameters.fields, requestParameters.includeTotal, requestParameters.offset, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }
}



