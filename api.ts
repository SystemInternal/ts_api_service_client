/* tslint:disable */
/* eslint-disable */
/**
 * System REST API
 *  This page provides documentation for the System REST API.  If you have any questions or need support, please contact us at the email provided.  ## Formatting query parameters  Filters should be formatted as `field:value` and use the pipe operator `|` to specify an OR condition.   If they are numerical, they should be formatted as `field:opvalue`. Examples: - `doi:10.1234/5678|10.8765/4321` - `num_findings:>2`  Sorts should be formatted as `field:direction`. Examples: - `cited_by:desc` - `publish_date:asc`  Searches should be formatted as `field:value`. Examples: - `name:osteoporosis` 
 *
 * The version of the OpenAPI document: 0.1.0
 * Contact: api@system.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * Cluster.
 * @export
 * @interface Cluster
 */
export interface Cluster {
    /**
     * 
     * @type {string}
     * @memberof Cluster
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Cluster
     */
    'cluster_label_1': string;
    /**
     * 
     * @type {string}
     * @memberof Cluster
     */
    'cluster_label_2': string;
    /**
     * 
     * @type {string}
     * @memberof Cluster
     */
    'summary': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Cluster
     */
    'finding_ids': Array<string>;
}
/**
 * Flag.
 * @export
 * @interface Flag
 */
export interface Flag {
    /**
     * 
     * @type {string}
     * @memberof Flag
     */
    'flagged_property': string;
    /**
     * 
     * @type {string | Null}
     * @memberof Flag
     */
    'reason'?: string | Null;
    /**
     * 
     * @type {string}
     * @memberof Flag
     */
    'resource_id': string;
    /**
     * 
     * @type {string}
     * @memberof Flag
     */
    'system_id': string;
}
/**
 * Flag input.
 * @export
 * @interface FlagInput
 */
export interface FlagInput {
    /**
     * 
     * @type {string}
     * @memberof FlagInput
     */
    'flagged_property': string;
    /**
     * 
     * @type {string | Null}
     * @memberof FlagInput
     */
    'reason'?: string | Null;
}
/**
 * Graph response.
 * @export
 * @interface GraphResponse
 */
export interface GraphResponse {
    /**
     * 
     * @type {Array<Node>}
     * @memberof GraphResponse
     */
    'nodes': Array<Node>;
    /**
     * 
     * @type {Array<Link>}
     * @memberof GraphResponse
     */
    'links': Array<Link>;
}
/**
 * 
 * @export
 * @interface HTTPValidationError
 */
export interface HTTPValidationError {
    /**
     * 
     * @type {Array<ValidationError>}
     * @memberof HTTPValidationError
     */
    'detail'?: Array<ValidationError>;
}
/**
 * Status of a pubmed search synthesis job.
 * @export
 * @enum {string}
 */

export enum JobStatus {
    Accepted = 'accepted',
    Clustering = 'clustering',
    ClusteringFailed = 'clustering_failed',
    Synthesizing = 'synthesizing',
    SynthesisNotExists = 'synthesis_not_exists',
    SynthesisSubmitted = 'synthesis_submitted',
    SynthesisRunning = 'synthesis_running',
    SynthesisSuccess = 'synthesis_success',
    SynthesisFailed = 'synthesis_failed',
    SynthesisFailedNoCitations = 'synthesis_failed_no_citations',
    SynthesisFailedValidation = 'synthesis_failed_validation'
}

/**
 * Link.
 * @export
 * @interface Link
 */
export interface Link {
    /**
     * 
     * @type {string}
     * @memberof Link
     */
    'source': string;
    /**
     * 
     * @type {string}
     * @memberof Link
     */
    'target': string;
}
/**
 * 
 * @export
 * @interface ListResponseCluster
 */
export interface ListResponseCluster {
    /**
     * 
     * @type {Array<Cluster>}
     * @memberof ListResponseCluster
     */
    'data': Array<Cluster>;
    /**
     * 
     * @type {number}
     * @memberof ListResponseCluster
     */
    'total': number;
}
/**
 * 
 * @export
 * @interface ListResponseRelationship
 */
export interface ListResponseRelationship {
    /**
     * 
     * @type {Array<Relationship>}
     * @memberof ListResponseRelationship
     */
    'data': Array<Relationship>;
    /**
     * 
     * @type {number}
     * @memberof ListResponseRelationship
     */
    'total': number;
}
/**
 * 
 * @export
 * @interface ListResponseStatisticalFinding
 */
export interface ListResponseStatisticalFinding {
    /**
     * 
     * @type {Array<StatisticalFinding>}
     * @memberof ListResponseStatisticalFinding
     */
    'data': Array<StatisticalFinding>;
    /**
     * 
     * @type {number}
     * @memberof ListResponseStatisticalFinding
     */
    'total': number;
}
/**
 * 
 * @export
 * @interface ListResponseStudy
 */
export interface ListResponseStudy {
    /**
     * 
     * @type {Array<Study>}
     * @memberof ListResponseStudy
     */
    'data': Array<Study>;
    /**
     * 
     * @type {number}
     * @memberof ListResponseStudy
     */
    'total': number;
}
/**
 * 
 * @export
 * @interface ListResponseTopic
 */
export interface ListResponseTopic {
    /**
     * 
     * @type {Array<Topic>}
     * @memberof ListResponseTopic
     */
    'data': Array<Topic>;
    /**
     * 
     * @type {number}
     * @memberof ListResponseTopic
     */
    'total': number;
}
/**
 * 
 * @export
 * @interface ListResponseTopicPath
 */
export interface ListResponseTopicPath {
    /**
     * 
     * @type {Array<TopicPath>}
     * @memberof ListResponseTopicPath
     */
    'data': Array<TopicPath>;
    /**
     * 
     * @type {number}
     * @memberof ListResponseTopicPath
     */
    'total': number;
}
/**
 * 
 * @export
 * @interface ListResponseVariable
 */
export interface ListResponseVariable {
    /**
     * 
     * @type {Array<Variable>}
     * @memberof ListResponseVariable
     */
    'data': Array<Variable>;
    /**
     * 
     * @type {number}
     * @memberof ListResponseVariable
     */
    'total': number;
}
/**
 * Nested resource.
 * @export
 * @interface NestedResource
 */
export interface NestedResource {
    /**
     * Unique identifier
     * @type {string}
     * @memberof NestedResource
     */
    'id': string;
    /**
     * Name of the resource
     * @type {string}
     * @memberof NestedResource
     */
    'name': string;
}
/**
 * Nested study.
 * @export
 * @interface NestedStudy
 */
export interface NestedStudy {
    /**
     * Unique identifier
     * @type {string}
     * @memberof NestedStudy
     */
    'id': string;
    /**
     * Digital Object Identifier (DOI)
     * @type {string}
     * @memberof NestedStudy
     */
    'doi'?: string;
    /**
     * Population studied
     * @type {string}
     * @memberof NestedStudy
     */
    'population'?: string;
    /**
     * Sample size of the study
     * @type {string}
     * @memberof NestedStudy
     */
    'sample_size'?: string;
}
/**
 * Node.
 * @export
 * @interface Node
 */
export interface Node {
    /**
     * 
     * @type {string}
     * @memberof Node
     */
    'id': string;
    /**
     * 
     * @type {string | Null}
     * @memberof Node
     */
    'label'?: string | Null;
}
/**
 * Pubmed search synthesis input.
 * @export
 * @interface PubmedSearchSynthesisInput
 */
export interface PubmedSearchSynthesisInput {
    /**
     * 
     * @type {string}
     * @memberof PubmedSearchSynthesisInput
     */
    'query': string;
}
/**
 * Pubmed search synthesis job.
 * @export
 * @interface PubmedSearchSynthesisJob
 */
export interface PubmedSearchSynthesisJob {
    /**
     * Unique identifier of a Pubmed search synthesis job
     * @type {string}
     * @memberof PubmedSearchSynthesisJob
     */
    'id': string;
    /**
     * Status of job
     * @type {JobStatus}
     * @memberof PubmedSearchSynthesisJob
     */
    'status': JobStatus;
    /**
     * Date job was created
     * @type {string}
     * @memberof PubmedSearchSynthesisJob
     */
    'created_at': string;
    /**
     * Date job was last updated
     * @type {string}
     * @memberof PubmedSearchSynthesisJob
     */
    'updated_at': string;
    /**
     * Initial user query
     * @type {string}
     * @memberof PubmedSearchSynthesisJob
     */
    'user_query': string;
    /**
     * Pubmed query the user query resolved to
     * @type {string}
     * @memberof PubmedSearchSynthesisJob
     */
    'pubmed_query': string;
    /**
     * Date clustering was finished
     * @type {string | Null}
     * @memberof PubmedSearchSynthesisJob
     */
    'clustering_finished'?: string | Null;
    /**
     * Date synthesis was finished
     * @type {string | Null}
     * @memberof PubmedSearchSynthesisJob
     */
    'synthesis_finished'?: string | Null;
}
/**
 * Relationship.
 * @export
 * @interface Relationship
 */
export interface Relationship {
    /**
     * Unique identifier of relationship.
     * @type {string}
     * @memberof Relationship
     */
    'id': string;
    /**
     * Number of findings on relationship
     * @type {number}
     * @memberof Relationship
     */
    'num_findings': number;
    /**
     * Number of studies supporting relationship
     * @type {number}
     * @memberof Relationship
     */
    'num_studies': number;
    /**
     * Number of significant findings on relationship
     * @type {number}
     * @memberof Relationship
     */
    'num_significant_findings': number;
    /**
     * Highest cited study supporting relationship
     * @type {number}
     * @memberof Relationship
     */
    'highest_cited'?: number;
    /**
     * Median effect size of findings on relationship
     * @type {number | Null}
     * @memberof Relationship
     */
    'median_effect_size'?: number | Null;
    /**
     * Date relationship was last updated
     * @type {string}
     * @memberof Relationship
     */
    'last_updated': string;
    /**
     * Whether or not the relationship is supported by an experimental trial
     * @type {boolean}
     * @memberof Relationship
     */
    'has_experimental_trial': boolean;
    /**
     * Unique identifier of the source topic
     * @type {Topic}
     * @memberof Relationship
     */
    'source_topic': Topic;
    /**
     * Unique identifier of the target topic
     * @type {Topic}
     * @memberof Relationship
     */
    'target_topic': Topic;
}
/**
 * Statistic type.
 * @export
 * @enum {string}
 */

export enum StatisticType {
    OddsRatio = 'odds_ratio',
    AdjustedOddsRatio = 'adjusted_odds_ratio',
    HazardRatio = 'hazard_ratio',
    AdjustedHazardRatio = 'adjusted_hazard_ratio',
    RelativeRiskRatio = 'relative_risk_ratio',
    Coefficient = 'coefficient',
    PearsonR = 'pearson_r',
    IncidentRateRatio = 'incident_rate_ratio',
    PrevalenceRatio = 'prevalence_ratio',
    SpearmanCorrelation = 'spearman_correlation',
    MeanDifferenceStandardized = 'mean_difference_standardized',
    MeanDifferenceUnstandardized = 'mean_difference_unstandardized',
    RiskDifference = 'risk_difference',
    CoefficientOfDetermination = 'coefficient_of_determination',
    TTest = 't_test',
    Elasticity = 'elasticity',
    GiniCoefficient = 'gini_coefficient'
}

/**
 * Statistical finding.
 * @export
 * @interface StatisticalFinding
 */
export interface StatisticalFinding {
    /**
     * Unique identifier
     * @type {string}
     * @memberof StatisticalFinding
     */
    'id': string;
    /**
     * Whether finding is flagged
     * @type {boolean}
     * @memberof StatisticalFinding
     */
    'flagged'?: boolean;
    /**
     * Type of finding
     * @type {string}
     * @memberof StatisticalFinding
     */
    'finding_type'?: StatisticalFindingFindingTypeEnum;
    /**
     * Summary of the finding
     * @type {string | Null}
     * @memberof StatisticalFinding
     */
    'summary'?: string | Null;
    /**
     * Source topic of the finding
     * @type {NestedResource | Null}
     * @memberof StatisticalFinding
     */
    'topic_1'?: NestedResource | Null;
    /**
     * Target topic of the finding
     * @type {NestedResource | Null}
     * @memberof StatisticalFinding
     */
    'topic_2'?: NestedResource | Null;
    /**
     * Source variable of the finding
     * @type {NestedResource}
     * @memberof StatisticalFinding
     */
    'variable_1'?: NestedResource;
    /**
     * Target variable of the finding
     * @type {NestedResource}
     * @memberof StatisticalFinding
     */
    'variable_2'?: NestedResource;
    /**
     * Study supporting the finding
     * @type {NestedStudy}
     * @memberof StatisticalFinding
     */
    'study'?: NestedStudy;
    /**
     * Type of statistic
     * @type {StatisticType | Null}
     * @memberof StatisticalFinding
     */
    'statistic_type'?: StatisticType | Null;
    /**
     * Value of statistic
     * @type {number | Null}
     * @memberof StatisticalFinding
     */
    'statistic_value'?: number | Null;
    /**
     * Upper bound of confidence interval
     * @type {number | Null}
     * @memberof StatisticalFinding
     */
    'ci_upper'?: number | Null;
    /**
     * Lower bound of confidence interval
     * @type {number | Null}
     * @memberof StatisticalFinding
     */
    'ci_lower'?: number | Null;
    /**
     * P-value
     * @type {number | Null}
     * @memberof StatisticalFinding
     */
    'p_value'?: number | Null;
}

/**
    * @export
    * @enum {string}
    */
export enum StatisticalFindingFindingTypeEnum {
    Statistical = 'statistical'
}

/**
 * Study.
 * @export
 * @interface Study
 */
export interface Study {
    /**
     * Unique identifier
     * @type {string}
     * @memberof Study
     */
    'id': string;
    /**
     * Digital Object Identifier (DOI)
     * @type {string | Null}
     * @memberof Study
     */
    'doi'?: string | Null;
    /**
     * Title of the study
     * @type {string | Null}
     * @memberof Study
     */
    'title'?: string | Null;
    /**
     * Authors of the study
     * @type {Array<object> | Null}
     * @memberof Study
     */
    'authors'?: Array<object> | Null;
    /**
     * Journal the study was published in
     * @type {string | Null}
     * @memberof Study
     */
    'journal'?: string | Null;
    /**
     * Year of publication
     * @type {string | Null}
     * @memberof Study
     */
    'publish_date'?: string | Null;
    /**
     * Population studied
     * @type {string | Null}
     * @memberof Study
     */
    'population'?: string | Null;
    /**
     * Sample size of the study
     * @type {number | Null}
     * @memberof Study
     */
    'sample_size'?: number | Null;
    /**
     * Summary of the study
     * @type {string | Null}
     * @memberof Study
     */
    'summary'?: string | Null;
    /**
     * Number of times study was cited by another study
     * @type {number | Null}
     * @memberof Study
     */
    'cited_by'?: number | Null;
    /**
     * Type of study
     * @type {string | Null}
     * @memberof Study
     */
    'study_type'?: string | Null;
    /**
     * Reason for retraction of study
     * @type {string | Null}
     * @memberof Study
     */
    'retraction_reason'?: string | Null;
}
/**
 * Topic.
 * @export
 * @interface Topic
 */
export interface Topic {
    /**
     * Unique identifier
     * @type {string}
     * @memberof Topic
     */
    'id': string;
    /**
     * Name of the topic
     * @type {string}
     * @memberof Topic
     */
    'name': string;
    /**
     * Wikidata identifier for the topic
     * @type {string | Null}
     * @memberof Topic
     */
    'wikidata_id'?: string | Null;
    /**
     * UMLS Concept Unique Identifiers (CUIs) for the topic
     * @type {Array<string> | Null}
     * @memberof Topic
     */
    'umls_cuis'?: Array<string> | Null;
    /**
     * Category of the topic
     * @type {TopicCategory | Null}
     * @memberof Topic
     */
    'category'?: TopicCategory | Null;
    /**
     * Roles associated with the topic
     * @type {Array<TopicRole> | Null}
     * @memberof Topic
     */
    'roles'?: Array<TopicRole> | Null;
}
/**
 * Topic category.
 * @export
 * @enum {string}
 */

export enum TopicCategory {
    BiomedicalDiseasesDisorders = 'Biomedical - Diseases & Disorders',
    BiomedicalHospitalization = 'Biomedical - Hospitalization',
    BiomedicalMortalitySurvival = 'Biomedical - Mortality/survival',
    BiomedicalPathogen = 'Biomedical - Pathogen',
    BiomedicalEthnicity = 'Biomedical - Ethnicity',
    BiomedicalOtherBiologicalFactors = 'Biomedical - Other Biological factors',
    BiomedicalAnthropometry = 'Biomedical - Anthropometry',
    BiomedicalAge = 'Biomedical - Age',
    BiomedicalSex = 'Biomedical - Sex',
    BiomedicalCarcinogen = 'Biomedical - Carcinogen',
    BiomedicalGenetics = 'Biomedical - Genetics',
    BehavioralPersonalHygiene = 'Behavioral - Personal hygiene',
    BehavioralOtherDietaryFactors = 'Behavioral - Other dietary factors',
    BehavioralStress = 'Behavioral - Stress',
    BehavioralSubstanceUse = 'Behavioral - Substance Use',
    BehavioralEatingBehaviors = 'Behavioral - Eating behaviors',
    BehavioralSleep = 'Behavioral - Sleep',
    BehavioralPhysicalActivity = 'Behavioral - Physical activity',
    BehavioralOtherBehavioralFactors = 'Behavioral - Other behavioral factors',
    BehavioralSexualBehavior = 'Behavioral - Sexual behavior',
    EnvironmentalAirQuality = 'Environmental - Air quality',
    EnvironmentalWaterQuality = 'Environmental - Water quality',
    EnvironmentalWeatherAndClimateChange = 'Environmental - Weather and climate change',
    EnvironmentalOtherEnvironmentalFactors = 'Environmental - Other Environmental factors',
    SocialEducation = 'Social - Education',
    SocialEconomicContext = 'Social - Economic context',
    SocialOtherSocialFactors = 'Social - Other social factors',
    SocialPhysicalInfrastructure = 'Social - Physical infrastructure',
    SocialSocialContext = 'Social - Social context',
    SocialHealthcareContext = 'Social - Healthcare context',
    SocialOccupation = 'Social - Occupation',
    SocialGeography = 'Social - Geography',
    SocialOccupationalContext = 'Social - Occupational context',
    Healing = 'Healing',
    Preventative = 'Preventative',
    Diagnostic = 'Diagnostic',
    Preservative = 'Preservative',
    Managing = 'Managing',
    Therapeutic = 'Therapeutic',
    Other = 'Other'
}

/**
 * Path to topic.
 * @export
 * @interface TopicPath
 */
export interface TopicPath {
    /**
     * Unique identifier of relationship.
     * @type {string}
     * @memberof TopicPath
     */
    'id': string;
    /**
     * Number of findings on relationship
     * @type {number}
     * @memberof TopicPath
     */
    'num_findings': number;
    /**
     * Number of studies supporting relationship
     * @type {number}
     * @memberof TopicPath
     */
    'num_studies': number;
    /**
     * Number of significant findings on relationship
     * @type {number}
     * @memberof TopicPath
     */
    'num_significant_findings': number;
    /**
     * Highest cited study supporting relationship
     * @type {number}
     * @memberof TopicPath
     */
    'highest_cited'?: number;
    /**
     * Median effect size of findings on relationship
     * @type {number | Null}
     * @memberof TopicPath
     */
    'median_effect_size'?: number | Null;
    /**
     * Date relationship was last updated
     * @type {string}
     * @memberof TopicPath
     */
    'last_updated': string;
    /**
     * Whether or not the relationship is supported by an experimental trial
     * @type {boolean}
     * @memberof TopicPath
     */
    'has_experimental_trial': boolean;
    /**
     * Topic in path
     * @type {Topic}
     * @memberof TopicPath
     */
    'topic': Topic;
}
/**
 * Topic role.
 * @export
 * @enum {string}
 */

export enum TopicRole {
    Determinant = 'Determinant',
    Intervention = 'Intervention',
    Outcome = 'Outcome',
    Agent = 'Agent'
}

/**
 * 
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
    /**
     * 
     * @type {Array<string | number>}
     * @memberof ValidationError
     */
    'loc': Array<string | number>;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'type': string;
}
/**
 * Variable.
 * @export
 * @interface Variable
 */
export interface Variable {
    /**
     * Unique identifier
     * @type {string}
     * @memberof Variable
     */
    'id': string;
    /**
     * Name of the variable
     * @type {string | Null}
     * @memberof Variable
     */
    'name'?: string | Null;
    /**
     * Number of studies the variable appears in
     * @type {number | Null}
     * @memberof Variable
     */
    'num_studies'?: number | Null;
    /**
     * Topic that the variable is matched to
     * @type {NestedResource | Null}
     * @memberof Variable
     */
    'topic'?: NestedResource | Null;
}

/**
 * GraphApi - axios parameter creator
 * @export
 */
export const GraphApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Gets a subgraph of a topic by id.         The subgraph includes upstream and downstream relationships within two hops.         If the response takes too long or is too large, consider using filters to reduce the size of the response.
         * @summary Get subgraph by topic id
         * @param {string} topicId 
         * @param {string | Null} [upstream1Filter] Fields and values to filter the first upstream relationship. Supported fields for filtering: id, num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial, topic.id, topic.wikidata_id, topic.category, topic.roles.
         * @param {string | Null} [upstream2Filter] Fields and values to filter the second upstream relationship. Supported fields for filtering: id, num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial, topic.id, topic.wikidata_id, topic.category, topic.roles.
         * @param {string | Null} [downstream1Filter] Fields and values to filter the first downstream relationship. Supported fields for filtering: id, num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial, topic.id, topic.wikidata_id, topic.category, topic.roles.
         * @param {string | Null} [downstream2Filter] Fields and values to filter the second downstream relationship. Supported fields for filtering: id, num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial, topic.id, topic.wikidata_id, topic.category, topic.roles.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubgraphByTopicId: async (topicId: string, upstream1Filter?: string | Null, upstream2Filter?: string | Null, downstream1Filter?: string | Null, downstream2Filter?: string | Null, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'topicId' is not null or undefined
            assertParamExists('getSubgraphByTopicId', 'topicId', topicId)
            const localVarPath = `/v0/graph/{topic_id}`
                .replace(`{${"topic_id"}}`, encodeURIComponent(String(topicId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (upstream1Filter !== undefined) {
                localVarQueryParameter['upstream_1_filter'] = upstream1Filter;
            }

            if (upstream2Filter !== undefined) {
                localVarQueryParameter['upstream_2_filter'] = upstream2Filter;
            }

            if (downstream1Filter !== undefined) {
                localVarQueryParameter['downstream_1_filter'] = downstream1Filter;
            }

            if (downstream2Filter !== undefined) {
                localVarQueryParameter['downstream_2_filter'] = downstream2Filter;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GraphApi - functional programming interface
 * @export
 */
export const GraphApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GraphApiAxiosParamCreator(configuration)
    return {
        /**
         * Gets a subgraph of a topic by id.         The subgraph includes upstream and downstream relationships within two hops.         If the response takes too long or is too large, consider using filters to reduce the size of the response.
         * @summary Get subgraph by topic id
         * @param {string} topicId 
         * @param {string | Null} [upstream1Filter] Fields and values to filter the first upstream relationship. Supported fields for filtering: id, num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial, topic.id, topic.wikidata_id, topic.category, topic.roles.
         * @param {string | Null} [upstream2Filter] Fields and values to filter the second upstream relationship. Supported fields for filtering: id, num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial, topic.id, topic.wikidata_id, topic.category, topic.roles.
         * @param {string | Null} [downstream1Filter] Fields and values to filter the first downstream relationship. Supported fields for filtering: id, num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial, topic.id, topic.wikidata_id, topic.category, topic.roles.
         * @param {string | Null} [downstream2Filter] Fields and values to filter the second downstream relationship. Supported fields for filtering: id, num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial, topic.id, topic.wikidata_id, topic.category, topic.roles.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSubgraphByTopicId(topicId: string, upstream1Filter?: string | Null, upstream2Filter?: string | Null, downstream1Filter?: string | Null, downstream2Filter?: string | Null, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GraphResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSubgraphByTopicId(topicId, upstream1Filter, upstream2Filter, downstream1Filter, downstream2Filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * GraphApi - factory interface
 * @export
 */
export const GraphApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GraphApiFp(configuration)
    return {
        /**
         * Gets a subgraph of a topic by id.         The subgraph includes upstream and downstream relationships within two hops.         If the response takes too long or is too large, consider using filters to reduce the size of the response.
         * @summary Get subgraph by topic id
         * @param {string} topicId 
         * @param {string | Null} [upstream1Filter] Fields and values to filter the first upstream relationship. Supported fields for filtering: id, num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial, topic.id, topic.wikidata_id, topic.category, topic.roles.
         * @param {string | Null} [upstream2Filter] Fields and values to filter the second upstream relationship. Supported fields for filtering: id, num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial, topic.id, topic.wikidata_id, topic.category, topic.roles.
         * @param {string | Null} [downstream1Filter] Fields and values to filter the first downstream relationship. Supported fields for filtering: id, num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial, topic.id, topic.wikidata_id, topic.category, topic.roles.
         * @param {string | Null} [downstream2Filter] Fields and values to filter the second downstream relationship. Supported fields for filtering: id, num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial, topic.id, topic.wikidata_id, topic.category, topic.roles.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubgraphByTopicId(topicId: string, upstream1Filter?: string | Null, upstream2Filter?: string | Null, downstream1Filter?: string | Null, downstream2Filter?: string | Null, options?: any): AxiosPromise<GraphResponse> {
            return localVarFp.getSubgraphByTopicId(topicId, upstream1Filter, upstream2Filter, downstream1Filter, downstream2Filter, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getSubgraphByTopicId operation in GraphApi.
 * @export
 * @interface GraphApiGetSubgraphByTopicIdRequest
 */
export interface GraphApiGetSubgraphByTopicIdRequest {
    /**
     * 
     * @type {string}
     * @memberof GraphApiGetSubgraphByTopicId
     */
    readonly topicId: string

    /**
     * Fields and values to filter the first upstream relationship. Supported fields for filtering: id, num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial, topic.id, topic.wikidata_id, topic.category, topic.roles.
     * @type {string | Null}
     * @memberof GraphApiGetSubgraphByTopicId
     */
    readonly upstream1Filter?: string | Null

    /**
     * Fields and values to filter the second upstream relationship. Supported fields for filtering: id, num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial, topic.id, topic.wikidata_id, topic.category, topic.roles.
     * @type {string | Null}
     * @memberof GraphApiGetSubgraphByTopicId
     */
    readonly upstream2Filter?: string | Null

    /**
     * Fields and values to filter the first downstream relationship. Supported fields for filtering: id, num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial, topic.id, topic.wikidata_id, topic.category, topic.roles.
     * @type {string | Null}
     * @memberof GraphApiGetSubgraphByTopicId
     */
    readonly downstream1Filter?: string | Null

    /**
     * Fields and values to filter the second downstream relationship. Supported fields for filtering: id, num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial, topic.id, topic.wikidata_id, topic.category, topic.roles.
     * @type {string | Null}
     * @memberof GraphApiGetSubgraphByTopicId
     */
    readonly downstream2Filter?: string | Null
}

/**
 * GraphApi - object-oriented interface
 * @export
 * @class GraphApi
 * @extends {BaseAPI}
 */
export class GraphApi extends BaseAPI {
    /**
     * Gets a subgraph of a topic by id.         The subgraph includes upstream and downstream relationships within two hops.         If the response takes too long or is too large, consider using filters to reduce the size of the response.
     * @summary Get subgraph by topic id
     * @param {GraphApiGetSubgraphByTopicIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApi
     */
    public getSubgraphByTopicId(requestParameters: GraphApiGetSubgraphByTopicIdRequest, options?: AxiosRequestConfig) {
        return GraphApiFp(this.configuration).getSubgraphByTopicId(requestParameters.topicId, requestParameters.upstream1Filter, requestParameters.upstream2Filter, requestParameters.downstream1Filter, requestParameters.downstream2Filter, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RelationshipsApi - axios parameter creator
 * @export
 */
export const RelationshipsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a relationship by its ID.
         * @summary Get a relationship
         * @param {string} relationshipId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelationshipById: async (relationshipId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'relationshipId' is not null or undefined
            assertParamExists('getRelationshipById', 'relationshipId', relationshipId)
            const localVarPath = `/v0/relationships/{relationship_id}`
                .replace(`{${"relationship_id"}}`, encodeURIComponent(String(relationshipId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of the statistical findings underlying a given relationship.
         * @summary Get relationship statistical findings
         * @param {string} relationshipId 
         * @param {string | Null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, flagged, topic_1, topic_2, variable_1.id, variable_2.id, study.id, study.doi, statistic_type.
         * @param {string | Null} [sort] Field to sort the response by. Supported fields for sorting: none.
         * @param {string | Null} [search] Field to search within. Supported fields for searching: none.
         * @param {string | Null} [fields] Comma-separated list of fields to include in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelationshipStatisticalFindings: async (relationshipId: string, filter?: string | Null, sort?: string | Null, search?: string | Null, fields?: string | Null, offset?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'relationshipId' is not null or undefined
            assertParamExists('getRelationshipStatisticalFindings', 'relationshipId', relationshipId)
            const localVarPath = `/v0/relationships/{relationship_id}/statistical_findings`
                .replace(`{${"relationship_id"}}`, encodeURIComponent(String(relationshipId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of the studies underlying a given relationship.
         * @summary Get relationship studies
         * @param {string} relationshipId 
         * @param {string | Null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, doi, publish_date, cited_by, study_type.
         * @param {string | Null} [sort] Field to sort the response by. Supported fields for sorting: publish_date, sample_size, cited_by.
         * @param {string | Null} [search] Field to search within. Supported fields for searching: title.
         * @param {string | Null} [fields] Comma-separated list of fields to include in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelationshipStudies: async (relationshipId: string, filter?: string | Null, sort?: string | Null, search?: string | Null, fields?: string | Null, offset?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'relationshipId' is not null or undefined
            assertParamExists('getRelationshipStudies', 'relationshipId', relationshipId)
            const localVarPath = `/v0/relationships/{relationship_id}/studies`
                .replace(`{${"relationship_id"}}`, encodeURIComponent(String(relationshipId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of relationships.
         * @summary Get relationships
         * @param {string | Null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial, source_topic.id, source_topic.wikidata_id, source_topic.category, source_topic.roles, target_topic.id, target_topic.wikidata_id, target_topic.category, target_topic.roles.
         * @param {string | Null} [sort] Field to sort the response by. Supported fields for sorting: num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial.
         * @param {string | Null} [search] Field to search within. Supported fields for searching: none.
         * @param {string | Null} [fields] Comma-separated list of fields to include in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelationships: async (filter?: string | Null, sort?: string | Null, search?: string | Null, fields?: string | Null, offset?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v0/relationships`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RelationshipsApi - functional programming interface
 * @export
 */
export const RelationshipsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RelationshipsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a relationship by its ID.
         * @summary Get a relationship
         * @param {string} relationshipId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRelationshipById(relationshipId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Relationship>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRelationshipById(relationshipId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of the statistical findings underlying a given relationship.
         * @summary Get relationship statistical findings
         * @param {string} relationshipId 
         * @param {string | Null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, flagged, topic_1, topic_2, variable_1.id, variable_2.id, study.id, study.doi, statistic_type.
         * @param {string | Null} [sort] Field to sort the response by. Supported fields for sorting: none.
         * @param {string | Null} [search] Field to search within. Supported fields for searching: none.
         * @param {string | Null} [fields] Comma-separated list of fields to include in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRelationshipStatisticalFindings(relationshipId: string, filter?: string | Null, sort?: string | Null, search?: string | Null, fields?: string | Null, offset?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListResponseStatisticalFinding>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRelationshipStatisticalFindings(relationshipId, filter, sort, search, fields, offset, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of the studies underlying a given relationship.
         * @summary Get relationship studies
         * @param {string} relationshipId 
         * @param {string | Null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, doi, publish_date, cited_by, study_type.
         * @param {string | Null} [sort] Field to sort the response by. Supported fields for sorting: publish_date, sample_size, cited_by.
         * @param {string | Null} [search] Field to search within. Supported fields for searching: title.
         * @param {string | Null} [fields] Comma-separated list of fields to include in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRelationshipStudies(relationshipId: string, filter?: string | Null, sort?: string | Null, search?: string | Null, fields?: string | Null, offset?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListResponseStudy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRelationshipStudies(relationshipId, filter, sort, search, fields, offset, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of relationships.
         * @summary Get relationships
         * @param {string | Null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial, source_topic.id, source_topic.wikidata_id, source_topic.category, source_topic.roles, target_topic.id, target_topic.wikidata_id, target_topic.category, target_topic.roles.
         * @param {string | Null} [sort] Field to sort the response by. Supported fields for sorting: num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial.
         * @param {string | Null} [search] Field to search within. Supported fields for searching: none.
         * @param {string | Null} [fields] Comma-separated list of fields to include in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRelationships(filter?: string | Null, sort?: string | Null, search?: string | Null, fields?: string | Null, offset?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListResponseRelationship>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRelationships(filter, sort, search, fields, offset, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RelationshipsApi - factory interface
 * @export
 */
export const RelationshipsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RelationshipsApiFp(configuration)
    return {
        /**
         * Get a relationship by its ID.
         * @summary Get a relationship
         * @param {string} relationshipId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelationshipById(relationshipId: string, options?: any): AxiosPromise<Relationship> {
            return localVarFp.getRelationshipById(relationshipId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of the statistical findings underlying a given relationship.
         * @summary Get relationship statistical findings
         * @param {string} relationshipId 
         * @param {string | Null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, flagged, topic_1, topic_2, variable_1.id, variable_2.id, study.id, study.doi, statistic_type.
         * @param {string | Null} [sort] Field to sort the response by. Supported fields for sorting: none.
         * @param {string | Null} [search] Field to search within. Supported fields for searching: none.
         * @param {string | Null} [fields] Comma-separated list of fields to include in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelationshipStatisticalFindings(relationshipId: string, filter?: string | Null, sort?: string | Null, search?: string | Null, fields?: string | Null, offset?: number, limit?: number, options?: any): AxiosPromise<ListResponseStatisticalFinding> {
            return localVarFp.getRelationshipStatisticalFindings(relationshipId, filter, sort, search, fields, offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of the studies underlying a given relationship.
         * @summary Get relationship studies
         * @param {string} relationshipId 
         * @param {string | Null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, doi, publish_date, cited_by, study_type.
         * @param {string | Null} [sort] Field to sort the response by. Supported fields for sorting: publish_date, sample_size, cited_by.
         * @param {string | Null} [search] Field to search within. Supported fields for searching: title.
         * @param {string | Null} [fields] Comma-separated list of fields to include in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelationshipStudies(relationshipId: string, filter?: string | Null, sort?: string | Null, search?: string | Null, fields?: string | Null, offset?: number, limit?: number, options?: any): AxiosPromise<ListResponseStudy> {
            return localVarFp.getRelationshipStudies(relationshipId, filter, sort, search, fields, offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of relationships.
         * @summary Get relationships
         * @param {string | Null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial, source_topic.id, source_topic.wikidata_id, source_topic.category, source_topic.roles, target_topic.id, target_topic.wikidata_id, target_topic.category, target_topic.roles.
         * @param {string | Null} [sort] Field to sort the response by. Supported fields for sorting: num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial.
         * @param {string | Null} [search] Field to search within. Supported fields for searching: none.
         * @param {string | Null} [fields] Comma-separated list of fields to include in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelationships(filter?: string | Null, sort?: string | Null, search?: string | Null, fields?: string | Null, offset?: number, limit?: number, options?: any): AxiosPromise<ListResponseRelationship> {
            return localVarFp.getRelationships(filter, sort, search, fields, offset, limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getRelationshipById operation in RelationshipsApi.
 * @export
 * @interface RelationshipsApiGetRelationshipByIdRequest
 */
export interface RelationshipsApiGetRelationshipByIdRequest {
    /**
     * 
     * @type {string}
     * @memberof RelationshipsApiGetRelationshipById
     */
    readonly relationshipId: string
}

/**
 * Request parameters for getRelationshipStatisticalFindings operation in RelationshipsApi.
 * @export
 * @interface RelationshipsApiGetRelationshipStatisticalFindingsRequest
 */
export interface RelationshipsApiGetRelationshipStatisticalFindingsRequest {
    /**
     * 
     * @type {string}
     * @memberof RelationshipsApiGetRelationshipStatisticalFindings
     */
    readonly relationshipId: string

    /**
     * Fields and values to filter the response by. Supported fields for filtering: id, flagged, topic_1, topic_2, variable_1.id, variable_2.id, study.id, study.doi, statistic_type.
     * @type {string | Null}
     * @memberof RelationshipsApiGetRelationshipStatisticalFindings
     */
    readonly filter?: string | Null

    /**
     * Field to sort the response by. Supported fields for sorting: none.
     * @type {string | Null}
     * @memberof RelationshipsApiGetRelationshipStatisticalFindings
     */
    readonly sort?: string | Null

    /**
     * Field to search within. Supported fields for searching: none.
     * @type {string | Null}
     * @memberof RelationshipsApiGetRelationshipStatisticalFindings
     */
    readonly search?: string | Null

    /**
     * Comma-separated list of fields to include in the response.
     * @type {string | Null}
     * @memberof RelationshipsApiGetRelationshipStatisticalFindings
     */
    readonly fields?: string | Null

    /**
     * Offset
     * @type {number}
     * @memberof RelationshipsApiGetRelationshipStatisticalFindings
     */
    readonly offset?: number

    /**
     * Limit
     * @type {number}
     * @memberof RelationshipsApiGetRelationshipStatisticalFindings
     */
    readonly limit?: number
}

/**
 * Request parameters for getRelationshipStudies operation in RelationshipsApi.
 * @export
 * @interface RelationshipsApiGetRelationshipStudiesRequest
 */
export interface RelationshipsApiGetRelationshipStudiesRequest {
    /**
     * 
     * @type {string}
     * @memberof RelationshipsApiGetRelationshipStudies
     */
    readonly relationshipId: string

    /**
     * Fields and values to filter the response by. Supported fields for filtering: id, doi, publish_date, cited_by, study_type.
     * @type {string | Null}
     * @memberof RelationshipsApiGetRelationshipStudies
     */
    readonly filter?: string | Null

    /**
     * Field to sort the response by. Supported fields for sorting: publish_date, sample_size, cited_by.
     * @type {string | Null}
     * @memberof RelationshipsApiGetRelationshipStudies
     */
    readonly sort?: string | Null

    /**
     * Field to search within. Supported fields for searching: title.
     * @type {string | Null}
     * @memberof RelationshipsApiGetRelationshipStudies
     */
    readonly search?: string | Null

    /**
     * Comma-separated list of fields to include in the response.
     * @type {string | Null}
     * @memberof RelationshipsApiGetRelationshipStudies
     */
    readonly fields?: string | Null

    /**
     * Offset
     * @type {number}
     * @memberof RelationshipsApiGetRelationshipStudies
     */
    readonly offset?: number

    /**
     * Limit
     * @type {number}
     * @memberof RelationshipsApiGetRelationshipStudies
     */
    readonly limit?: number
}

/**
 * Request parameters for getRelationships operation in RelationshipsApi.
 * @export
 * @interface RelationshipsApiGetRelationshipsRequest
 */
export interface RelationshipsApiGetRelationshipsRequest {
    /**
     * Fields and values to filter the response by. Supported fields for filtering: id, num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial, source_topic.id, source_topic.wikidata_id, source_topic.category, source_topic.roles, target_topic.id, target_topic.wikidata_id, target_topic.category, target_topic.roles.
     * @type {string | Null}
     * @memberof RelationshipsApiGetRelationships
     */
    readonly filter?: string | Null

    /**
     * Field to sort the response by. Supported fields for sorting: num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial.
     * @type {string | Null}
     * @memberof RelationshipsApiGetRelationships
     */
    readonly sort?: string | Null

    /**
     * Field to search within. Supported fields for searching: none.
     * @type {string | Null}
     * @memberof RelationshipsApiGetRelationships
     */
    readonly search?: string | Null

    /**
     * Comma-separated list of fields to include in the response.
     * @type {string | Null}
     * @memberof RelationshipsApiGetRelationships
     */
    readonly fields?: string | Null

    /**
     * Offset
     * @type {number}
     * @memberof RelationshipsApiGetRelationships
     */
    readonly offset?: number

    /**
     * Limit
     * @type {number}
     * @memberof RelationshipsApiGetRelationships
     */
    readonly limit?: number
}

/**
 * RelationshipsApi - object-oriented interface
 * @export
 * @class RelationshipsApi
 * @extends {BaseAPI}
 */
export class RelationshipsApi extends BaseAPI {
    /**
     * Get a relationship by its ID.
     * @summary Get a relationship
     * @param {RelationshipsApiGetRelationshipByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RelationshipsApi
     */
    public getRelationshipById(requestParameters: RelationshipsApiGetRelationshipByIdRequest, options?: AxiosRequestConfig) {
        return RelationshipsApiFp(this.configuration).getRelationshipById(requestParameters.relationshipId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of the statistical findings underlying a given relationship.
     * @summary Get relationship statistical findings
     * @param {RelationshipsApiGetRelationshipStatisticalFindingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RelationshipsApi
     */
    public getRelationshipStatisticalFindings(requestParameters: RelationshipsApiGetRelationshipStatisticalFindingsRequest, options?: AxiosRequestConfig) {
        return RelationshipsApiFp(this.configuration).getRelationshipStatisticalFindings(requestParameters.relationshipId, requestParameters.filter, requestParameters.sort, requestParameters.search, requestParameters.fields, requestParameters.offset, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of the studies underlying a given relationship.
     * @summary Get relationship studies
     * @param {RelationshipsApiGetRelationshipStudiesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RelationshipsApi
     */
    public getRelationshipStudies(requestParameters: RelationshipsApiGetRelationshipStudiesRequest, options?: AxiosRequestConfig) {
        return RelationshipsApiFp(this.configuration).getRelationshipStudies(requestParameters.relationshipId, requestParameters.filter, requestParameters.sort, requestParameters.search, requestParameters.fields, requestParameters.offset, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of relationships.
     * @summary Get relationships
     * @param {RelationshipsApiGetRelationshipsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RelationshipsApi
     */
    public getRelationships(requestParameters: RelationshipsApiGetRelationshipsRequest = {}, options?: AxiosRequestConfig) {
        return RelationshipsApiFp(this.configuration).getRelationships(requestParameters.filter, requestParameters.sort, requestParameters.search, requestParameters.fields, requestParameters.offset, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StatisticalFindingsApi - axios parameter creator
 * @export
 */
export const StatisticalFindingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Flag a statistical finding for review.
         * @summary Flag statistical finding
         * @param {string} findingId 
         * @param {Array<FlagInput>} flagInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        flagStatisticalFinding: async (findingId: string, flagInput: Array<FlagInput>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'findingId' is not null or undefined
            assertParamExists('flagStatisticalFinding', 'findingId', findingId)
            // verify required parameter 'flagInput' is not null or undefined
            assertParamExists('flagStatisticalFinding', 'flagInput', flagInput)
            const localVarPath = `/v0/statistical_findings/{finding_id}/flags`
                .replace(`{${"finding_id"}}`, encodeURIComponent(String(findingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(flagInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a statistical finding by its ID.
         * @summary Get a statistical finding
         * @param {string} findingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatisticalFindingById: async (findingId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'findingId' is not null or undefined
            assertParamExists('getStatisticalFindingById', 'findingId', findingId)
            const localVarPath = `/v0/statistical_findings/{finding_id}`
                .replace(`{${"finding_id"}}`, encodeURIComponent(String(findingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of statistical findings.
         * @summary Get statistical findings
         * @param {string | Null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, flagged, topic_1, topic_2, variable_1.id, variable_2.id, study.id, study.doi, statistic_type.
         * @param {string | Null} [sort] Field to sort the response by. Supported fields for sorting: none.
         * @param {string | Null} [search] Field to search within. Supported fields for searching: none.
         * @param {string | Null} [fields] Comma-separated list of fields to include in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatisticalFindings: async (filter?: string | Null, sort?: string | Null, search?: string | Null, fields?: string | Null, offset?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v0/statistical_findings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StatisticalFindingsApi - functional programming interface
 * @export
 */
export const StatisticalFindingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StatisticalFindingsApiAxiosParamCreator(configuration)
    return {
        /**
         * Flag a statistical finding for review.
         * @summary Flag statistical finding
         * @param {string} findingId 
         * @param {Array<FlagInput>} flagInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async flagStatisticalFinding(findingId: string, flagInput: Array<FlagInput>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Flag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.flagStatisticalFinding(findingId, flagInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a statistical finding by its ID.
         * @summary Get a statistical finding
         * @param {string} findingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStatisticalFindingById(findingId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatisticalFinding>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStatisticalFindingById(findingId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of statistical findings.
         * @summary Get statistical findings
         * @param {string | Null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, flagged, topic_1, topic_2, variable_1.id, variable_2.id, study.id, study.doi, statistic_type.
         * @param {string | Null} [sort] Field to sort the response by. Supported fields for sorting: none.
         * @param {string | Null} [search] Field to search within. Supported fields for searching: none.
         * @param {string | Null} [fields] Comma-separated list of fields to include in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStatisticalFindings(filter?: string | Null, sort?: string | Null, search?: string | Null, fields?: string | Null, offset?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListResponseStatisticalFinding>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStatisticalFindings(filter, sort, search, fields, offset, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StatisticalFindingsApi - factory interface
 * @export
 */
export const StatisticalFindingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StatisticalFindingsApiFp(configuration)
    return {
        /**
         * Flag a statistical finding for review.
         * @summary Flag statistical finding
         * @param {string} findingId 
         * @param {Array<FlagInput>} flagInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        flagStatisticalFinding(findingId: string, flagInput: Array<FlagInput>, options?: any): AxiosPromise<Array<Flag>> {
            return localVarFp.flagStatisticalFinding(findingId, flagInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a statistical finding by its ID.
         * @summary Get a statistical finding
         * @param {string} findingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatisticalFindingById(findingId: string, options?: any): AxiosPromise<StatisticalFinding> {
            return localVarFp.getStatisticalFindingById(findingId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of statistical findings.
         * @summary Get statistical findings
         * @param {string | Null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, flagged, topic_1, topic_2, variable_1.id, variable_2.id, study.id, study.doi, statistic_type.
         * @param {string | Null} [sort] Field to sort the response by. Supported fields for sorting: none.
         * @param {string | Null} [search] Field to search within. Supported fields for searching: none.
         * @param {string | Null} [fields] Comma-separated list of fields to include in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatisticalFindings(filter?: string | Null, sort?: string | Null, search?: string | Null, fields?: string | Null, offset?: number, limit?: number, options?: any): AxiosPromise<ListResponseStatisticalFinding> {
            return localVarFp.getStatisticalFindings(filter, sort, search, fields, offset, limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for flagStatisticalFinding operation in StatisticalFindingsApi.
 * @export
 * @interface StatisticalFindingsApiFlagStatisticalFindingRequest
 */
export interface StatisticalFindingsApiFlagStatisticalFindingRequest {
    /**
     * 
     * @type {string}
     * @memberof StatisticalFindingsApiFlagStatisticalFinding
     */
    readonly findingId: string

    /**
     * 
     * @type {Array<FlagInput>}
     * @memberof StatisticalFindingsApiFlagStatisticalFinding
     */
    readonly flagInput: Array<FlagInput>
}

/**
 * Request parameters for getStatisticalFindingById operation in StatisticalFindingsApi.
 * @export
 * @interface StatisticalFindingsApiGetStatisticalFindingByIdRequest
 */
export interface StatisticalFindingsApiGetStatisticalFindingByIdRequest {
    /**
     * 
     * @type {string}
     * @memberof StatisticalFindingsApiGetStatisticalFindingById
     */
    readonly findingId: string
}

/**
 * Request parameters for getStatisticalFindings operation in StatisticalFindingsApi.
 * @export
 * @interface StatisticalFindingsApiGetStatisticalFindingsRequest
 */
export interface StatisticalFindingsApiGetStatisticalFindingsRequest {
    /**
     * Fields and values to filter the response by. Supported fields for filtering: id, flagged, topic_1, topic_2, variable_1.id, variable_2.id, study.id, study.doi, statistic_type.
     * @type {string | Null}
     * @memberof StatisticalFindingsApiGetStatisticalFindings
     */
    readonly filter?: string | Null

    /**
     * Field to sort the response by. Supported fields for sorting: none.
     * @type {string | Null}
     * @memberof StatisticalFindingsApiGetStatisticalFindings
     */
    readonly sort?: string | Null

    /**
     * Field to search within. Supported fields for searching: none.
     * @type {string | Null}
     * @memberof StatisticalFindingsApiGetStatisticalFindings
     */
    readonly search?: string | Null

    /**
     * Comma-separated list of fields to include in the response.
     * @type {string | Null}
     * @memberof StatisticalFindingsApiGetStatisticalFindings
     */
    readonly fields?: string | Null

    /**
     * Offset
     * @type {number}
     * @memberof StatisticalFindingsApiGetStatisticalFindings
     */
    readonly offset?: number

    /**
     * Limit
     * @type {number}
     * @memberof StatisticalFindingsApiGetStatisticalFindings
     */
    readonly limit?: number
}

/**
 * StatisticalFindingsApi - object-oriented interface
 * @export
 * @class StatisticalFindingsApi
 * @extends {BaseAPI}
 */
export class StatisticalFindingsApi extends BaseAPI {
    /**
     * Flag a statistical finding for review.
     * @summary Flag statistical finding
     * @param {StatisticalFindingsApiFlagStatisticalFindingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatisticalFindingsApi
     */
    public flagStatisticalFinding(requestParameters: StatisticalFindingsApiFlagStatisticalFindingRequest, options?: AxiosRequestConfig) {
        return StatisticalFindingsApiFp(this.configuration).flagStatisticalFinding(requestParameters.findingId, requestParameters.flagInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a statistical finding by its ID.
     * @summary Get a statistical finding
     * @param {StatisticalFindingsApiGetStatisticalFindingByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatisticalFindingsApi
     */
    public getStatisticalFindingById(requestParameters: StatisticalFindingsApiGetStatisticalFindingByIdRequest, options?: AxiosRequestConfig) {
        return StatisticalFindingsApiFp(this.configuration).getStatisticalFindingById(requestParameters.findingId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of statistical findings.
     * @summary Get statistical findings
     * @param {StatisticalFindingsApiGetStatisticalFindingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatisticalFindingsApi
     */
    public getStatisticalFindings(requestParameters: StatisticalFindingsApiGetStatisticalFindingsRequest = {}, options?: AxiosRequestConfig) {
        return StatisticalFindingsApiFp(this.configuration).getStatisticalFindings(requestParameters.filter, requestParameters.sort, requestParameters.search, requestParameters.fields, requestParameters.offset, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StudiesApi - axios parameter creator
 * @export
 */
export const StudiesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a list of studies.
         * @summary Get studies
         * @param {string | Null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, doi, publish_date, cited_by, study_type.
         * @param {string | Null} [sort] Field to sort the response by. Supported fields for sorting: publish_date, sample_size, cited_by.
         * @param {string | Null} [search] Field to search within. Supported fields for searching: title.
         * @param {string | Null} [fields] Comma-separated list of fields to include in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudies: async (filter?: string | Null, sort?: string | Null, search?: string | Null, fields?: string | Null, offset?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v0/studies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a study by its ID.
         * @summary Get a study
         * @param {string} studyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudyById: async (studyId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'studyId' is not null or undefined
            assertParamExists('getStudyById', 'studyId', studyId)
            const localVarPath = `/v0/studies/{study_id}`
                .replace(`{${"study_id"}}`, encodeURIComponent(String(studyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of the statistical findings reported by a given study.
         * @summary Get study statistical findings
         * @param {string} studyId 
         * @param {string | Null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, flagged, topic_1, topic_2, variable_1.id, variable_2.id, study.id, study.doi, statistic_type.
         * @param {string | Null} [sort] Field to sort the response by. Supported fields for sorting: none.
         * @param {string | Null} [search] Field to search within. Supported fields for searching: none.
         * @param {string | Null} [fields] Comma-separated list of fields to include in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudyStatisticalFindings: async (studyId: string, filter?: string | Null, sort?: string | Null, search?: string | Null, fields?: string | Null, offset?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'studyId' is not null or undefined
            assertParamExists('getStudyStatisticalFindings', 'studyId', studyId)
            const localVarPath = `/v0/studies/{study_id}/statistical_findings`
                .replace(`{${"study_id"}}`, encodeURIComponent(String(studyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StudiesApi - functional programming interface
 * @export
 */
export const StudiesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StudiesApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a list of studies.
         * @summary Get studies
         * @param {string | Null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, doi, publish_date, cited_by, study_type.
         * @param {string | Null} [sort] Field to sort the response by. Supported fields for sorting: publish_date, sample_size, cited_by.
         * @param {string | Null} [search] Field to search within. Supported fields for searching: title.
         * @param {string | Null} [fields] Comma-separated list of fields to include in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStudies(filter?: string | Null, sort?: string | Null, search?: string | Null, fields?: string | Null, offset?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListResponseStudy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStudies(filter, sort, search, fields, offset, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a study by its ID.
         * @summary Get a study
         * @param {string} studyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStudyById(studyId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Study>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStudyById(studyId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of the statistical findings reported by a given study.
         * @summary Get study statistical findings
         * @param {string} studyId 
         * @param {string | Null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, flagged, topic_1, topic_2, variable_1.id, variable_2.id, study.id, study.doi, statistic_type.
         * @param {string | Null} [sort] Field to sort the response by. Supported fields for sorting: none.
         * @param {string | Null} [search] Field to search within. Supported fields for searching: none.
         * @param {string | Null} [fields] Comma-separated list of fields to include in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStudyStatisticalFindings(studyId: string, filter?: string | Null, sort?: string | Null, search?: string | Null, fields?: string | Null, offset?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListResponseStatisticalFinding>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStudyStatisticalFindings(studyId, filter, sort, search, fields, offset, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StudiesApi - factory interface
 * @export
 */
export const StudiesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StudiesApiFp(configuration)
    return {
        /**
         * Get a list of studies.
         * @summary Get studies
         * @param {string | Null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, doi, publish_date, cited_by, study_type.
         * @param {string | Null} [sort] Field to sort the response by. Supported fields for sorting: publish_date, sample_size, cited_by.
         * @param {string | Null} [search] Field to search within. Supported fields for searching: title.
         * @param {string | Null} [fields] Comma-separated list of fields to include in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudies(filter?: string | Null, sort?: string | Null, search?: string | Null, fields?: string | Null, offset?: number, limit?: number, options?: any): AxiosPromise<ListResponseStudy> {
            return localVarFp.getStudies(filter, sort, search, fields, offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a study by its ID.
         * @summary Get a study
         * @param {string} studyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudyById(studyId: string, options?: any): AxiosPromise<Study> {
            return localVarFp.getStudyById(studyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of the statistical findings reported by a given study.
         * @summary Get study statistical findings
         * @param {string} studyId 
         * @param {string | Null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, flagged, topic_1, topic_2, variable_1.id, variable_2.id, study.id, study.doi, statistic_type.
         * @param {string | Null} [sort] Field to sort the response by. Supported fields for sorting: none.
         * @param {string | Null} [search] Field to search within. Supported fields for searching: none.
         * @param {string | Null} [fields] Comma-separated list of fields to include in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudyStatisticalFindings(studyId: string, filter?: string | Null, sort?: string | Null, search?: string | Null, fields?: string | Null, offset?: number, limit?: number, options?: any): AxiosPromise<ListResponseStatisticalFinding> {
            return localVarFp.getStudyStatisticalFindings(studyId, filter, sort, search, fields, offset, limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getStudies operation in StudiesApi.
 * @export
 * @interface StudiesApiGetStudiesRequest
 */
export interface StudiesApiGetStudiesRequest {
    /**
     * Fields and values to filter the response by. Supported fields for filtering: id, doi, publish_date, cited_by, study_type.
     * @type {string | Null}
     * @memberof StudiesApiGetStudies
     */
    readonly filter?: string | Null

    /**
     * Field to sort the response by. Supported fields for sorting: publish_date, sample_size, cited_by.
     * @type {string | Null}
     * @memberof StudiesApiGetStudies
     */
    readonly sort?: string | Null

    /**
     * Field to search within. Supported fields for searching: title.
     * @type {string | Null}
     * @memberof StudiesApiGetStudies
     */
    readonly search?: string | Null

    /**
     * Comma-separated list of fields to include in the response.
     * @type {string | Null}
     * @memberof StudiesApiGetStudies
     */
    readonly fields?: string | Null

    /**
     * Offset
     * @type {number}
     * @memberof StudiesApiGetStudies
     */
    readonly offset?: number

    /**
     * Limit
     * @type {number}
     * @memberof StudiesApiGetStudies
     */
    readonly limit?: number
}

/**
 * Request parameters for getStudyById operation in StudiesApi.
 * @export
 * @interface StudiesApiGetStudyByIdRequest
 */
export interface StudiesApiGetStudyByIdRequest {
    /**
     * 
     * @type {string}
     * @memberof StudiesApiGetStudyById
     */
    readonly studyId: string
}

/**
 * Request parameters for getStudyStatisticalFindings operation in StudiesApi.
 * @export
 * @interface StudiesApiGetStudyStatisticalFindingsRequest
 */
export interface StudiesApiGetStudyStatisticalFindingsRequest {
    /**
     * 
     * @type {string}
     * @memberof StudiesApiGetStudyStatisticalFindings
     */
    readonly studyId: string

    /**
     * Fields and values to filter the response by. Supported fields for filtering: id, flagged, topic_1, topic_2, variable_1.id, variable_2.id, study.id, study.doi, statistic_type.
     * @type {string | Null}
     * @memberof StudiesApiGetStudyStatisticalFindings
     */
    readonly filter?: string | Null

    /**
     * Field to sort the response by. Supported fields for sorting: none.
     * @type {string | Null}
     * @memberof StudiesApiGetStudyStatisticalFindings
     */
    readonly sort?: string | Null

    /**
     * Field to search within. Supported fields for searching: none.
     * @type {string | Null}
     * @memberof StudiesApiGetStudyStatisticalFindings
     */
    readonly search?: string | Null

    /**
     * Comma-separated list of fields to include in the response.
     * @type {string | Null}
     * @memberof StudiesApiGetStudyStatisticalFindings
     */
    readonly fields?: string | Null

    /**
     * Offset
     * @type {number}
     * @memberof StudiesApiGetStudyStatisticalFindings
     */
    readonly offset?: number

    /**
     * Limit
     * @type {number}
     * @memberof StudiesApiGetStudyStatisticalFindings
     */
    readonly limit?: number
}

/**
 * StudiesApi - object-oriented interface
 * @export
 * @class StudiesApi
 * @extends {BaseAPI}
 */
export class StudiesApi extends BaseAPI {
    /**
     * Get a list of studies.
     * @summary Get studies
     * @param {StudiesApiGetStudiesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudiesApi
     */
    public getStudies(requestParameters: StudiesApiGetStudiesRequest = {}, options?: AxiosRequestConfig) {
        return StudiesApiFp(this.configuration).getStudies(requestParameters.filter, requestParameters.sort, requestParameters.search, requestParameters.fields, requestParameters.offset, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a study by its ID.
     * @summary Get a study
     * @param {StudiesApiGetStudyByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudiesApi
     */
    public getStudyById(requestParameters: StudiesApiGetStudyByIdRequest, options?: AxiosRequestConfig) {
        return StudiesApiFp(this.configuration).getStudyById(requestParameters.studyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of the statistical findings reported by a given study.
     * @summary Get study statistical findings
     * @param {StudiesApiGetStudyStatisticalFindingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudiesApi
     */
    public getStudyStatisticalFindings(requestParameters: StudiesApiGetStudyStatisticalFindingsRequest, options?: AxiosRequestConfig) {
        return StudiesApiFp(this.configuration).getStudyStatisticalFindings(requestParameters.studyId, requestParameters.filter, requestParameters.sort, requestParameters.search, requestParameters.fields, requestParameters.offset, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SynthesisApi - axios parameter creator
 * @export
 */
export const SynthesisApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get clusters from pubmed search synthesis.
         * @summary Get clusters from pubmed search synthesis
         * @param {string} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClustersFromPubmedSearch: async (jobId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('getClustersFromPubmedSearch', 'jobId', jobId)
            const localVarPath = `/v0/synthesis/pubmed_search/{job_id}/clusters`
                .replace(`{${"job_id"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a pubmed search synthesis by its ID.
         * @summary Get pubmed search synthesis
         * @param {string} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPubmedSearchSynthesisById: async (jobId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('getPubmedSearchSynthesisById', 'jobId', jobId)
            const localVarPath = `/v0/synthesis/pubmed_search/{job_id}`
                .replace(`{${"job_id"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get statistical findings from pubmed search synthesis.
         * @summary Get statistical findings from pubmed search synthesis
         * @param {string} jobId 
         * @param {string | Null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, flagged, topic_1, topic_2, variable_1.id, variable_2.id, study.id, study.doi, statistic_type.
         * @param {string | Null} [sort] Field to sort the response by. Supported fields for sorting: none.
         * @param {string | Null} [search] Field to search within. Supported fields for searching: none.
         * @param {string | Null} [fields] Comma-separated list of fields to include in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatisticalFindingsFromPubmedSearch: async (jobId: string, filter?: string | Null, sort?: string | Null, search?: string | Null, fields?: string | Null, offset?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('getStatisticalFindingsFromPubmedSearch', 'jobId', jobId)
            const localVarPath = `/v0/synthesis/pubmed_search/{job_id}/statistical_findings`
                .replace(`{${"job_id"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get studies from pubmed search synthesis.
         * @summary Get studies from pubmed search synthesis
         * @param {string} jobId 
         * @param {string | Null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, doi, publish_date, cited_by, study_type.
         * @param {string | Null} [sort] Field to sort the response by. Supported fields for sorting: publish_date, sample_size, cited_by.
         * @param {string | Null} [search] Field to search within. Supported fields for searching: title.
         * @param {string | Null} [fields] Comma-separated list of fields to include in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudiesFromPubmedSearch: async (jobId: string, filter?: string | Null, sort?: string | Null, search?: string | Null, fields?: string | Null, offset?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('getStudiesFromPubmedSearch', 'jobId', jobId)
            const localVarPath = `/v0/synthesis/pubmed_search/{job_id}/studies`
                .replace(`{${"job_id"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get synthesis from pubmed search synthesis.
         * @summary Get synthesis from pubmed search synthesis
         * @param {string} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSynthesisFromPubmedSearch: async (jobId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('getSynthesisFromPubmedSearch', 'jobId', jobId)
            const localVarPath = `/v0/synthesis/pubmed_search/{job_id}/synthesis`
                .replace(`{${"job_id"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Initiate pubmed search synthesis.
         * @summary Initiate pubmed search synthesis
         * @param {PubmedSearchSynthesisInput} pubmedSearchSynthesisInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        synthesizePubmedSearch: async (pubmedSearchSynthesisInput: PubmedSearchSynthesisInput, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pubmedSearchSynthesisInput' is not null or undefined
            assertParamExists('synthesizePubmedSearch', 'pubmedSearchSynthesisInput', pubmedSearchSynthesisInput)
            const localVarPath = `/v0/synthesis/pubmed_search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pubmedSearchSynthesisInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SynthesisApi - functional programming interface
 * @export
 */
export const SynthesisApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SynthesisApiAxiosParamCreator(configuration)
    return {
        /**
         * Get clusters from pubmed search synthesis.
         * @summary Get clusters from pubmed search synthesis
         * @param {string} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getClustersFromPubmedSearch(jobId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListResponseCluster>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getClustersFromPubmedSearch(jobId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a pubmed search synthesis by its ID.
         * @summary Get pubmed search synthesis
         * @param {string} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPubmedSearchSynthesisById(jobId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PubmedSearchSynthesisJob>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPubmedSearchSynthesisById(jobId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get statistical findings from pubmed search synthesis.
         * @summary Get statistical findings from pubmed search synthesis
         * @param {string} jobId 
         * @param {string | Null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, flagged, topic_1, topic_2, variable_1.id, variable_2.id, study.id, study.doi, statistic_type.
         * @param {string | Null} [sort] Field to sort the response by. Supported fields for sorting: none.
         * @param {string | Null} [search] Field to search within. Supported fields for searching: none.
         * @param {string | Null} [fields] Comma-separated list of fields to include in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStatisticalFindingsFromPubmedSearch(jobId: string, filter?: string | Null, sort?: string | Null, search?: string | Null, fields?: string | Null, offset?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListResponseStatisticalFinding>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStatisticalFindingsFromPubmedSearch(jobId, filter, sort, search, fields, offset, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get studies from pubmed search synthesis.
         * @summary Get studies from pubmed search synthesis
         * @param {string} jobId 
         * @param {string | Null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, doi, publish_date, cited_by, study_type.
         * @param {string | Null} [sort] Field to sort the response by. Supported fields for sorting: publish_date, sample_size, cited_by.
         * @param {string | Null} [search] Field to search within. Supported fields for searching: title.
         * @param {string | Null} [fields] Comma-separated list of fields to include in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStudiesFromPubmedSearch(jobId: string, filter?: string | Null, sort?: string | Null, search?: string | Null, fields?: string | Null, offset?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListResponseStudy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStudiesFromPubmedSearch(jobId, filter, sort, search, fields, offset, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get synthesis from pubmed search synthesis.
         * @summary Get synthesis from pubmed search synthesis
         * @param {string} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSynthesisFromPubmedSearch(jobId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSynthesisFromPubmedSearch(jobId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Initiate pubmed search synthesis.
         * @summary Initiate pubmed search synthesis
         * @param {PubmedSearchSynthesisInput} pubmedSearchSynthesisInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async synthesizePubmedSearch(pubmedSearchSynthesisInput: PubmedSearchSynthesisInput, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.synthesizePubmedSearch(pubmedSearchSynthesisInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SynthesisApi - factory interface
 * @export
 */
export const SynthesisApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SynthesisApiFp(configuration)
    return {
        /**
         * Get clusters from pubmed search synthesis.
         * @summary Get clusters from pubmed search synthesis
         * @param {string} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClustersFromPubmedSearch(jobId: string, options?: any): AxiosPromise<ListResponseCluster> {
            return localVarFp.getClustersFromPubmedSearch(jobId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a pubmed search synthesis by its ID.
         * @summary Get pubmed search synthesis
         * @param {string} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPubmedSearchSynthesisById(jobId: string, options?: any): AxiosPromise<PubmedSearchSynthesisJob> {
            return localVarFp.getPubmedSearchSynthesisById(jobId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get statistical findings from pubmed search synthesis.
         * @summary Get statistical findings from pubmed search synthesis
         * @param {string} jobId 
         * @param {string | Null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, flagged, topic_1, topic_2, variable_1.id, variable_2.id, study.id, study.doi, statistic_type.
         * @param {string | Null} [sort] Field to sort the response by. Supported fields for sorting: none.
         * @param {string | Null} [search] Field to search within. Supported fields for searching: none.
         * @param {string | Null} [fields] Comma-separated list of fields to include in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatisticalFindingsFromPubmedSearch(jobId: string, filter?: string | Null, sort?: string | Null, search?: string | Null, fields?: string | Null, offset?: number, limit?: number, options?: any): AxiosPromise<ListResponseStatisticalFinding> {
            return localVarFp.getStatisticalFindingsFromPubmedSearch(jobId, filter, sort, search, fields, offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get studies from pubmed search synthesis.
         * @summary Get studies from pubmed search synthesis
         * @param {string} jobId 
         * @param {string | Null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, doi, publish_date, cited_by, study_type.
         * @param {string | Null} [sort] Field to sort the response by. Supported fields for sorting: publish_date, sample_size, cited_by.
         * @param {string | Null} [search] Field to search within. Supported fields for searching: title.
         * @param {string | Null} [fields] Comma-separated list of fields to include in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudiesFromPubmedSearch(jobId: string, filter?: string | Null, sort?: string | Null, search?: string | Null, fields?: string | Null, offset?: number, limit?: number, options?: any): AxiosPromise<ListResponseStudy> {
            return localVarFp.getStudiesFromPubmedSearch(jobId, filter, sort, search, fields, offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get synthesis from pubmed search synthesis.
         * @summary Get synthesis from pubmed search synthesis
         * @param {string} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSynthesisFromPubmedSearch(jobId: string, options?: any): AxiosPromise<any> {
            return localVarFp.getSynthesisFromPubmedSearch(jobId, options).then((request) => request(axios, basePath));
        },
        /**
         * Initiate pubmed search synthesis.
         * @summary Initiate pubmed search synthesis
         * @param {PubmedSearchSynthesisInput} pubmedSearchSynthesisInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        synthesizePubmedSearch(pubmedSearchSynthesisInput: PubmedSearchSynthesisInput, options?: any): AxiosPromise<string> {
            return localVarFp.synthesizePubmedSearch(pubmedSearchSynthesisInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getClustersFromPubmedSearch operation in SynthesisApi.
 * @export
 * @interface SynthesisApiGetClustersFromPubmedSearchRequest
 */
export interface SynthesisApiGetClustersFromPubmedSearchRequest {
    /**
     * 
     * @type {string}
     * @memberof SynthesisApiGetClustersFromPubmedSearch
     */
    readonly jobId: string
}

/**
 * Request parameters for getPubmedSearchSynthesisById operation in SynthesisApi.
 * @export
 * @interface SynthesisApiGetPubmedSearchSynthesisByIdRequest
 */
export interface SynthesisApiGetPubmedSearchSynthesisByIdRequest {
    /**
     * 
     * @type {string}
     * @memberof SynthesisApiGetPubmedSearchSynthesisById
     */
    readonly jobId: string
}

/**
 * Request parameters for getStatisticalFindingsFromPubmedSearch operation in SynthesisApi.
 * @export
 * @interface SynthesisApiGetStatisticalFindingsFromPubmedSearchRequest
 */
export interface SynthesisApiGetStatisticalFindingsFromPubmedSearchRequest {
    /**
     * 
     * @type {string}
     * @memberof SynthesisApiGetStatisticalFindingsFromPubmedSearch
     */
    readonly jobId: string

    /**
     * Fields and values to filter the response by. Supported fields for filtering: id, flagged, topic_1, topic_2, variable_1.id, variable_2.id, study.id, study.doi, statistic_type.
     * @type {string | Null}
     * @memberof SynthesisApiGetStatisticalFindingsFromPubmedSearch
     */
    readonly filter?: string | Null

    /**
     * Field to sort the response by. Supported fields for sorting: none.
     * @type {string | Null}
     * @memberof SynthesisApiGetStatisticalFindingsFromPubmedSearch
     */
    readonly sort?: string | Null

    /**
     * Field to search within. Supported fields for searching: none.
     * @type {string | Null}
     * @memberof SynthesisApiGetStatisticalFindingsFromPubmedSearch
     */
    readonly search?: string | Null

    /**
     * Comma-separated list of fields to include in the response.
     * @type {string | Null}
     * @memberof SynthesisApiGetStatisticalFindingsFromPubmedSearch
     */
    readonly fields?: string | Null

    /**
     * Offset
     * @type {number}
     * @memberof SynthesisApiGetStatisticalFindingsFromPubmedSearch
     */
    readonly offset?: number

    /**
     * Limit
     * @type {number}
     * @memberof SynthesisApiGetStatisticalFindingsFromPubmedSearch
     */
    readonly limit?: number
}

/**
 * Request parameters for getStudiesFromPubmedSearch operation in SynthesisApi.
 * @export
 * @interface SynthesisApiGetStudiesFromPubmedSearchRequest
 */
export interface SynthesisApiGetStudiesFromPubmedSearchRequest {
    /**
     * 
     * @type {string}
     * @memberof SynthesisApiGetStudiesFromPubmedSearch
     */
    readonly jobId: string

    /**
     * Fields and values to filter the response by. Supported fields for filtering: id, doi, publish_date, cited_by, study_type.
     * @type {string | Null}
     * @memberof SynthesisApiGetStudiesFromPubmedSearch
     */
    readonly filter?: string | Null

    /**
     * Field to sort the response by. Supported fields for sorting: publish_date, sample_size, cited_by.
     * @type {string | Null}
     * @memberof SynthesisApiGetStudiesFromPubmedSearch
     */
    readonly sort?: string | Null

    /**
     * Field to search within. Supported fields for searching: title.
     * @type {string | Null}
     * @memberof SynthesisApiGetStudiesFromPubmedSearch
     */
    readonly search?: string | Null

    /**
     * Comma-separated list of fields to include in the response.
     * @type {string | Null}
     * @memberof SynthesisApiGetStudiesFromPubmedSearch
     */
    readonly fields?: string | Null

    /**
     * Offset
     * @type {number}
     * @memberof SynthesisApiGetStudiesFromPubmedSearch
     */
    readonly offset?: number

    /**
     * Limit
     * @type {number}
     * @memberof SynthesisApiGetStudiesFromPubmedSearch
     */
    readonly limit?: number
}

/**
 * Request parameters for getSynthesisFromPubmedSearch operation in SynthesisApi.
 * @export
 * @interface SynthesisApiGetSynthesisFromPubmedSearchRequest
 */
export interface SynthesisApiGetSynthesisFromPubmedSearchRequest {
    /**
     * 
     * @type {string}
     * @memberof SynthesisApiGetSynthesisFromPubmedSearch
     */
    readonly jobId: string
}

/**
 * Request parameters for synthesizePubmedSearch operation in SynthesisApi.
 * @export
 * @interface SynthesisApiSynthesizePubmedSearchRequest
 */
export interface SynthesisApiSynthesizePubmedSearchRequest {
    /**
     * 
     * @type {PubmedSearchSynthesisInput}
     * @memberof SynthesisApiSynthesizePubmedSearch
     */
    readonly pubmedSearchSynthesisInput: PubmedSearchSynthesisInput
}

/**
 * SynthesisApi - object-oriented interface
 * @export
 * @class SynthesisApi
 * @extends {BaseAPI}
 */
export class SynthesisApi extends BaseAPI {
    /**
     * Get clusters from pubmed search synthesis.
     * @summary Get clusters from pubmed search synthesis
     * @param {SynthesisApiGetClustersFromPubmedSearchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SynthesisApi
     */
    public getClustersFromPubmedSearch(requestParameters: SynthesisApiGetClustersFromPubmedSearchRequest, options?: AxiosRequestConfig) {
        return SynthesisApiFp(this.configuration).getClustersFromPubmedSearch(requestParameters.jobId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a pubmed search synthesis by its ID.
     * @summary Get pubmed search synthesis
     * @param {SynthesisApiGetPubmedSearchSynthesisByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SynthesisApi
     */
    public getPubmedSearchSynthesisById(requestParameters: SynthesisApiGetPubmedSearchSynthesisByIdRequest, options?: AxiosRequestConfig) {
        return SynthesisApiFp(this.configuration).getPubmedSearchSynthesisById(requestParameters.jobId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get statistical findings from pubmed search synthesis.
     * @summary Get statistical findings from pubmed search synthesis
     * @param {SynthesisApiGetStatisticalFindingsFromPubmedSearchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SynthesisApi
     */
    public getStatisticalFindingsFromPubmedSearch(requestParameters: SynthesisApiGetStatisticalFindingsFromPubmedSearchRequest, options?: AxiosRequestConfig) {
        return SynthesisApiFp(this.configuration).getStatisticalFindingsFromPubmedSearch(requestParameters.jobId, requestParameters.filter, requestParameters.sort, requestParameters.search, requestParameters.fields, requestParameters.offset, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get studies from pubmed search synthesis.
     * @summary Get studies from pubmed search synthesis
     * @param {SynthesisApiGetStudiesFromPubmedSearchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SynthesisApi
     */
    public getStudiesFromPubmedSearch(requestParameters: SynthesisApiGetStudiesFromPubmedSearchRequest, options?: AxiosRequestConfig) {
        return SynthesisApiFp(this.configuration).getStudiesFromPubmedSearch(requestParameters.jobId, requestParameters.filter, requestParameters.sort, requestParameters.search, requestParameters.fields, requestParameters.offset, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get synthesis from pubmed search synthesis.
     * @summary Get synthesis from pubmed search synthesis
     * @param {SynthesisApiGetSynthesisFromPubmedSearchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SynthesisApi
     */
    public getSynthesisFromPubmedSearch(requestParameters: SynthesisApiGetSynthesisFromPubmedSearchRequest, options?: AxiosRequestConfig) {
        return SynthesisApiFp(this.configuration).getSynthesisFromPubmedSearch(requestParameters.jobId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Initiate pubmed search synthesis.
     * @summary Initiate pubmed search synthesis
     * @param {SynthesisApiSynthesizePubmedSearchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SynthesisApi
     */
    public synthesizePubmedSearch(requestParameters: SynthesisApiSynthesizePubmedSearchRequest, options?: AxiosRequestConfig) {
        return SynthesisApiFp(this.configuration).synthesizePubmedSearch(requestParameters.pubmedSearchSynthesisInput, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TopicsApi - axios parameter creator
 * @export
 */
export const TopicsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a topic by its ID.
         * @summary Get a topic
         * @param {string} topicId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTopicById: async (topicId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'topicId' is not null or undefined
            assertParamExists('getTopicById', 'topicId', topicId)
            const localVarPath = `/v0/topics/{topic_id}`
                .replace(`{${"topic_id"}}`, encodeURIComponent(String(topicId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of determinants for a given topic. These are formatted as `TopicPath`s, which include data about the relationship and the source topic.
         * @summary Get topic determinants
         * @param {string} topicId 
         * @param {string | Null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial, topic.id, topic.wikidata_id, topic.category, topic.roles.
         * @param {string | Null} [sort] Field to sort the response by. Supported fields for sorting: num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial.
         * @param {string | Null} [search] Field to search within. Supported fields for searching: none.
         * @param {string | Null} [fields] Comma-separated list of fields to include in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTopicDeterminants: async (topicId: string, filter?: string | Null, sort?: string | Null, search?: string | Null, fields?: string | Null, offset?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'topicId' is not null or undefined
            assertParamExists('getTopicDeterminants', 'topicId', topicId)
            const localVarPath = `/v0/topics/{topic_id}/determinants`
                .replace(`{${"topic_id"}}`, encodeURIComponent(String(topicId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of interventions for a given topic. These are formatted as `TopicPath`s, which include data about the relationship and the source topic.
         * @summary Get topic interventions
         * @param {string} topicId 
         * @param {string | Null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial, topic.id, topic.wikidata_id, topic.category, topic.roles.
         * @param {string | Null} [sort] Field to sort the response by. Supported fields for sorting: num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial.
         * @param {string | Null} [search] Field to search within. Supported fields for searching: none.
         * @param {string | Null} [fields] Comma-separated list of fields to include in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTopicInterventions: async (topicId: string, filter?: string | Null, sort?: string | Null, search?: string | Null, fields?: string | Null, offset?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'topicId' is not null or undefined
            assertParamExists('getTopicInterventions', 'topicId', topicId)
            const localVarPath = `/v0/topics/{topic_id}/interventions`
                .replace(`{${"topic_id"}}`, encodeURIComponent(String(topicId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of outcomes for a given topic. These are formatted as `TopicPath`s, which include data about the relationship and the target topic.
         * @summary Get topic outcomes
         * @param {string} topicId 
         * @param {string | Null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial, topic.id, topic.wikidata_id, topic.category, topic.roles.
         * @param {string | Null} [sort] Field to sort the response by. Supported fields for sorting: num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial.
         * @param {string | Null} [search] Field to search within. Supported fields for searching: none.
         * @param {string | Null} [fields] Comma-separated list of fields to include in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTopicOutcomes: async (topicId: string, filter?: string | Null, sort?: string | Null, search?: string | Null, fields?: string | Null, offset?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'topicId' is not null or undefined
            assertParamExists('getTopicOutcomes', 'topicId', topicId)
            const localVarPath = `/v0/topics/{topic_id}/outcomes`
                .replace(`{${"topic_id"}}`, encodeURIComponent(String(topicId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of the relationships that include a given topic as the source or target topic.
         * @summary Get topic relationships
         * @param {string} topicId 
         * @param {string | Null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial, source_topic.id, source_topic.wikidata_id, source_topic.category, source_topic.roles, target_topic.id, target_topic.wikidata_id, target_topic.category, target_topic.roles.
         * @param {string | Null} [sort] Field to sort the response by. Supported fields for sorting: num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial.
         * @param {string | Null} [search] Field to search within. Supported fields for searching: none.
         * @param {string | Null} [fields] Comma-separated list of fields to include in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTopicRelationships: async (topicId: string, filter?: string | Null, sort?: string | Null, search?: string | Null, fields?: string | Null, offset?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'topicId' is not null or undefined
            assertParamExists('getTopicRelationships', 'topicId', topicId)
            const localVarPath = `/v0/topics/{topic_id}/relationships`
                .replace(`{${"topic_id"}}`, encodeURIComponent(String(topicId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of the variables that have been matched to a given topic.
         * @summary Get topic variables
         * @param {string} topicId 
         * @param {string | Null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, num_studies, topic.
         * @param {string | Null} [sort] Field to sort the response by. Supported fields for sorting: num_studies.
         * @param {string | Null} [search] Field to search within. Supported fields for searching: name.
         * @param {string | Null} [fields] Comma-separated list of fields to include in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTopicVariables: async (topicId: string, filter?: string | Null, sort?: string | Null, search?: string | Null, fields?: string | Null, offset?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'topicId' is not null or undefined
            assertParamExists('getTopicVariables', 'topicId', topicId)
            const localVarPath = `/v0/topics/{topic_id}/variables`
                .replace(`{${"topic_id"}}`, encodeURIComponent(String(topicId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of topics.
         * @summary Get topics
         * @param {string | Null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, wikidata_id, category, roles.
         * @param {string | Null} [sort] Field to sort the response by. Supported fields for sorting: none.
         * @param {string | Null} [search] Field to search within. Supported fields for searching: name.
         * @param {string | Null} [fields] Comma-separated list of fields to include in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTopics: async (filter?: string | Null, sort?: string | Null, search?: string | Null, fields?: string | Null, offset?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v0/topics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TopicsApi - functional programming interface
 * @export
 */
export const TopicsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TopicsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a topic by its ID.
         * @summary Get a topic
         * @param {string} topicId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTopicById(topicId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Topic>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTopicById(topicId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of determinants for a given topic. These are formatted as `TopicPath`s, which include data about the relationship and the source topic.
         * @summary Get topic determinants
         * @param {string} topicId 
         * @param {string | Null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial, topic.id, topic.wikidata_id, topic.category, topic.roles.
         * @param {string | Null} [sort] Field to sort the response by. Supported fields for sorting: num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial.
         * @param {string | Null} [search] Field to search within. Supported fields for searching: none.
         * @param {string | Null} [fields] Comma-separated list of fields to include in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTopicDeterminants(topicId: string, filter?: string | Null, sort?: string | Null, search?: string | Null, fields?: string | Null, offset?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListResponseTopicPath>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTopicDeterminants(topicId, filter, sort, search, fields, offset, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of interventions for a given topic. These are formatted as `TopicPath`s, which include data about the relationship and the source topic.
         * @summary Get topic interventions
         * @param {string} topicId 
         * @param {string | Null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial, topic.id, topic.wikidata_id, topic.category, topic.roles.
         * @param {string | Null} [sort] Field to sort the response by. Supported fields for sorting: num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial.
         * @param {string | Null} [search] Field to search within. Supported fields for searching: none.
         * @param {string | Null} [fields] Comma-separated list of fields to include in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTopicInterventions(topicId: string, filter?: string | Null, sort?: string | Null, search?: string | Null, fields?: string | Null, offset?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListResponseTopicPath>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTopicInterventions(topicId, filter, sort, search, fields, offset, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of outcomes for a given topic. These are formatted as `TopicPath`s, which include data about the relationship and the target topic.
         * @summary Get topic outcomes
         * @param {string} topicId 
         * @param {string | Null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial, topic.id, topic.wikidata_id, topic.category, topic.roles.
         * @param {string | Null} [sort] Field to sort the response by. Supported fields for sorting: num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial.
         * @param {string | Null} [search] Field to search within. Supported fields for searching: none.
         * @param {string | Null} [fields] Comma-separated list of fields to include in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTopicOutcomes(topicId: string, filter?: string | Null, sort?: string | Null, search?: string | Null, fields?: string | Null, offset?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListResponseTopicPath>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTopicOutcomes(topicId, filter, sort, search, fields, offset, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of the relationships that include a given topic as the source or target topic.
         * @summary Get topic relationships
         * @param {string} topicId 
         * @param {string | Null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial, source_topic.id, source_topic.wikidata_id, source_topic.category, source_topic.roles, target_topic.id, target_topic.wikidata_id, target_topic.category, target_topic.roles.
         * @param {string | Null} [sort] Field to sort the response by. Supported fields for sorting: num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial.
         * @param {string | Null} [search] Field to search within. Supported fields for searching: none.
         * @param {string | Null} [fields] Comma-separated list of fields to include in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTopicRelationships(topicId: string, filter?: string | Null, sort?: string | Null, search?: string | Null, fields?: string | Null, offset?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListResponseRelationship>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTopicRelationships(topicId, filter, sort, search, fields, offset, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of the variables that have been matched to a given topic.
         * @summary Get topic variables
         * @param {string} topicId 
         * @param {string | Null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, num_studies, topic.
         * @param {string | Null} [sort] Field to sort the response by. Supported fields for sorting: num_studies.
         * @param {string | Null} [search] Field to search within. Supported fields for searching: name.
         * @param {string | Null} [fields] Comma-separated list of fields to include in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTopicVariables(topicId: string, filter?: string | Null, sort?: string | Null, search?: string | Null, fields?: string | Null, offset?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListResponseVariable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTopicVariables(topicId, filter, sort, search, fields, offset, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of topics.
         * @summary Get topics
         * @param {string | Null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, wikidata_id, category, roles.
         * @param {string | Null} [sort] Field to sort the response by. Supported fields for sorting: none.
         * @param {string | Null} [search] Field to search within. Supported fields for searching: name.
         * @param {string | Null} [fields] Comma-separated list of fields to include in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTopics(filter?: string | Null, sort?: string | Null, search?: string | Null, fields?: string | Null, offset?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListResponseTopic>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTopics(filter, sort, search, fields, offset, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TopicsApi - factory interface
 * @export
 */
export const TopicsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TopicsApiFp(configuration)
    return {
        /**
         * Get a topic by its ID.
         * @summary Get a topic
         * @param {string} topicId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTopicById(topicId: string, options?: any): AxiosPromise<Topic> {
            return localVarFp.getTopicById(topicId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of determinants for a given topic. These are formatted as `TopicPath`s, which include data about the relationship and the source topic.
         * @summary Get topic determinants
         * @param {string} topicId 
         * @param {string | Null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial, topic.id, topic.wikidata_id, topic.category, topic.roles.
         * @param {string | Null} [sort] Field to sort the response by. Supported fields for sorting: num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial.
         * @param {string | Null} [search] Field to search within. Supported fields for searching: none.
         * @param {string | Null} [fields] Comma-separated list of fields to include in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTopicDeterminants(topicId: string, filter?: string | Null, sort?: string | Null, search?: string | Null, fields?: string | Null, offset?: number, limit?: number, options?: any): AxiosPromise<ListResponseTopicPath> {
            return localVarFp.getTopicDeterminants(topicId, filter, sort, search, fields, offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of interventions for a given topic. These are formatted as `TopicPath`s, which include data about the relationship and the source topic.
         * @summary Get topic interventions
         * @param {string} topicId 
         * @param {string | Null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial, topic.id, topic.wikidata_id, topic.category, topic.roles.
         * @param {string | Null} [sort] Field to sort the response by. Supported fields for sorting: num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial.
         * @param {string | Null} [search] Field to search within. Supported fields for searching: none.
         * @param {string | Null} [fields] Comma-separated list of fields to include in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTopicInterventions(topicId: string, filter?: string | Null, sort?: string | Null, search?: string | Null, fields?: string | Null, offset?: number, limit?: number, options?: any): AxiosPromise<ListResponseTopicPath> {
            return localVarFp.getTopicInterventions(topicId, filter, sort, search, fields, offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of outcomes for a given topic. These are formatted as `TopicPath`s, which include data about the relationship and the target topic.
         * @summary Get topic outcomes
         * @param {string} topicId 
         * @param {string | Null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial, topic.id, topic.wikidata_id, topic.category, topic.roles.
         * @param {string | Null} [sort] Field to sort the response by. Supported fields for sorting: num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial.
         * @param {string | Null} [search] Field to search within. Supported fields for searching: none.
         * @param {string | Null} [fields] Comma-separated list of fields to include in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTopicOutcomes(topicId: string, filter?: string | Null, sort?: string | Null, search?: string | Null, fields?: string | Null, offset?: number, limit?: number, options?: any): AxiosPromise<ListResponseTopicPath> {
            return localVarFp.getTopicOutcomes(topicId, filter, sort, search, fields, offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of the relationships that include a given topic as the source or target topic.
         * @summary Get topic relationships
         * @param {string} topicId 
         * @param {string | Null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial, source_topic.id, source_topic.wikidata_id, source_topic.category, source_topic.roles, target_topic.id, target_topic.wikidata_id, target_topic.category, target_topic.roles.
         * @param {string | Null} [sort] Field to sort the response by. Supported fields for sorting: num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial.
         * @param {string | Null} [search] Field to search within. Supported fields for searching: none.
         * @param {string | Null} [fields] Comma-separated list of fields to include in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTopicRelationships(topicId: string, filter?: string | Null, sort?: string | Null, search?: string | Null, fields?: string | Null, offset?: number, limit?: number, options?: any): AxiosPromise<ListResponseRelationship> {
            return localVarFp.getTopicRelationships(topicId, filter, sort, search, fields, offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of the variables that have been matched to a given topic.
         * @summary Get topic variables
         * @param {string} topicId 
         * @param {string | Null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, num_studies, topic.
         * @param {string | Null} [sort] Field to sort the response by. Supported fields for sorting: num_studies.
         * @param {string | Null} [search] Field to search within. Supported fields for searching: name.
         * @param {string | Null} [fields] Comma-separated list of fields to include in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTopicVariables(topicId: string, filter?: string | Null, sort?: string | Null, search?: string | Null, fields?: string | Null, offset?: number, limit?: number, options?: any): AxiosPromise<ListResponseVariable> {
            return localVarFp.getTopicVariables(topicId, filter, sort, search, fields, offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of topics.
         * @summary Get topics
         * @param {string | Null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, wikidata_id, category, roles.
         * @param {string | Null} [sort] Field to sort the response by. Supported fields for sorting: none.
         * @param {string | Null} [search] Field to search within. Supported fields for searching: name.
         * @param {string | Null} [fields] Comma-separated list of fields to include in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTopics(filter?: string | Null, sort?: string | Null, search?: string | Null, fields?: string | Null, offset?: number, limit?: number, options?: any): AxiosPromise<ListResponseTopic> {
            return localVarFp.getTopics(filter, sort, search, fields, offset, limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getTopicById operation in TopicsApi.
 * @export
 * @interface TopicsApiGetTopicByIdRequest
 */
export interface TopicsApiGetTopicByIdRequest {
    /**
     * 
     * @type {string}
     * @memberof TopicsApiGetTopicById
     */
    readonly topicId: string
}

/**
 * Request parameters for getTopicDeterminants operation in TopicsApi.
 * @export
 * @interface TopicsApiGetTopicDeterminantsRequest
 */
export interface TopicsApiGetTopicDeterminantsRequest {
    /**
     * 
     * @type {string}
     * @memberof TopicsApiGetTopicDeterminants
     */
    readonly topicId: string

    /**
     * Fields and values to filter the response by. Supported fields for filtering: id, num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial, topic.id, topic.wikidata_id, topic.category, topic.roles.
     * @type {string | Null}
     * @memberof TopicsApiGetTopicDeterminants
     */
    readonly filter?: string | Null

    /**
     * Field to sort the response by. Supported fields for sorting: num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial.
     * @type {string | Null}
     * @memberof TopicsApiGetTopicDeterminants
     */
    readonly sort?: string | Null

    /**
     * Field to search within. Supported fields for searching: none.
     * @type {string | Null}
     * @memberof TopicsApiGetTopicDeterminants
     */
    readonly search?: string | Null

    /**
     * Comma-separated list of fields to include in the response.
     * @type {string | Null}
     * @memberof TopicsApiGetTopicDeterminants
     */
    readonly fields?: string | Null

    /**
     * Offset
     * @type {number}
     * @memberof TopicsApiGetTopicDeterminants
     */
    readonly offset?: number

    /**
     * Limit
     * @type {number}
     * @memberof TopicsApiGetTopicDeterminants
     */
    readonly limit?: number
}

/**
 * Request parameters for getTopicInterventions operation in TopicsApi.
 * @export
 * @interface TopicsApiGetTopicInterventionsRequest
 */
export interface TopicsApiGetTopicInterventionsRequest {
    /**
     * 
     * @type {string}
     * @memberof TopicsApiGetTopicInterventions
     */
    readonly topicId: string

    /**
     * Fields and values to filter the response by. Supported fields for filtering: id, num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial, topic.id, topic.wikidata_id, topic.category, topic.roles.
     * @type {string | Null}
     * @memberof TopicsApiGetTopicInterventions
     */
    readonly filter?: string | Null

    /**
     * Field to sort the response by. Supported fields for sorting: num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial.
     * @type {string | Null}
     * @memberof TopicsApiGetTopicInterventions
     */
    readonly sort?: string | Null

    /**
     * Field to search within. Supported fields for searching: none.
     * @type {string | Null}
     * @memberof TopicsApiGetTopicInterventions
     */
    readonly search?: string | Null

    /**
     * Comma-separated list of fields to include in the response.
     * @type {string | Null}
     * @memberof TopicsApiGetTopicInterventions
     */
    readonly fields?: string | Null

    /**
     * Offset
     * @type {number}
     * @memberof TopicsApiGetTopicInterventions
     */
    readonly offset?: number

    /**
     * Limit
     * @type {number}
     * @memberof TopicsApiGetTopicInterventions
     */
    readonly limit?: number
}

/**
 * Request parameters for getTopicOutcomes operation in TopicsApi.
 * @export
 * @interface TopicsApiGetTopicOutcomesRequest
 */
export interface TopicsApiGetTopicOutcomesRequest {
    /**
     * 
     * @type {string}
     * @memberof TopicsApiGetTopicOutcomes
     */
    readonly topicId: string

    /**
     * Fields and values to filter the response by. Supported fields for filtering: id, num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial, topic.id, topic.wikidata_id, topic.category, topic.roles.
     * @type {string | Null}
     * @memberof TopicsApiGetTopicOutcomes
     */
    readonly filter?: string | Null

    /**
     * Field to sort the response by. Supported fields for sorting: num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial.
     * @type {string | Null}
     * @memberof TopicsApiGetTopicOutcomes
     */
    readonly sort?: string | Null

    /**
     * Field to search within. Supported fields for searching: none.
     * @type {string | Null}
     * @memberof TopicsApiGetTopicOutcomes
     */
    readonly search?: string | Null

    /**
     * Comma-separated list of fields to include in the response.
     * @type {string | Null}
     * @memberof TopicsApiGetTopicOutcomes
     */
    readonly fields?: string | Null

    /**
     * Offset
     * @type {number}
     * @memberof TopicsApiGetTopicOutcomes
     */
    readonly offset?: number

    /**
     * Limit
     * @type {number}
     * @memberof TopicsApiGetTopicOutcomes
     */
    readonly limit?: number
}

/**
 * Request parameters for getTopicRelationships operation in TopicsApi.
 * @export
 * @interface TopicsApiGetTopicRelationshipsRequest
 */
export interface TopicsApiGetTopicRelationshipsRequest {
    /**
     * 
     * @type {string}
     * @memberof TopicsApiGetTopicRelationships
     */
    readonly topicId: string

    /**
     * Fields and values to filter the response by. Supported fields for filtering: id, num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial, source_topic.id, source_topic.wikidata_id, source_topic.category, source_topic.roles, target_topic.id, target_topic.wikidata_id, target_topic.category, target_topic.roles.
     * @type {string | Null}
     * @memberof TopicsApiGetTopicRelationships
     */
    readonly filter?: string | Null

    /**
     * Field to sort the response by. Supported fields for sorting: num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial.
     * @type {string | Null}
     * @memberof TopicsApiGetTopicRelationships
     */
    readonly sort?: string | Null

    /**
     * Field to search within. Supported fields for searching: none.
     * @type {string | Null}
     * @memberof TopicsApiGetTopicRelationships
     */
    readonly search?: string | Null

    /**
     * Comma-separated list of fields to include in the response.
     * @type {string | Null}
     * @memberof TopicsApiGetTopicRelationships
     */
    readonly fields?: string | Null

    /**
     * Offset
     * @type {number}
     * @memberof TopicsApiGetTopicRelationships
     */
    readonly offset?: number

    /**
     * Limit
     * @type {number}
     * @memberof TopicsApiGetTopicRelationships
     */
    readonly limit?: number
}

/**
 * Request parameters for getTopicVariables operation in TopicsApi.
 * @export
 * @interface TopicsApiGetTopicVariablesRequest
 */
export interface TopicsApiGetTopicVariablesRequest {
    /**
     * 
     * @type {string}
     * @memberof TopicsApiGetTopicVariables
     */
    readonly topicId: string

    /**
     * Fields and values to filter the response by. Supported fields for filtering: id, num_studies, topic.
     * @type {string | Null}
     * @memberof TopicsApiGetTopicVariables
     */
    readonly filter?: string | Null

    /**
     * Field to sort the response by. Supported fields for sorting: num_studies.
     * @type {string | Null}
     * @memberof TopicsApiGetTopicVariables
     */
    readonly sort?: string | Null

    /**
     * Field to search within. Supported fields for searching: name.
     * @type {string | Null}
     * @memberof TopicsApiGetTopicVariables
     */
    readonly search?: string | Null

    /**
     * Comma-separated list of fields to include in the response.
     * @type {string | Null}
     * @memberof TopicsApiGetTopicVariables
     */
    readonly fields?: string | Null

    /**
     * Offset
     * @type {number}
     * @memberof TopicsApiGetTopicVariables
     */
    readonly offset?: number

    /**
     * Limit
     * @type {number}
     * @memberof TopicsApiGetTopicVariables
     */
    readonly limit?: number
}

/**
 * Request parameters for getTopics operation in TopicsApi.
 * @export
 * @interface TopicsApiGetTopicsRequest
 */
export interface TopicsApiGetTopicsRequest {
    /**
     * Fields and values to filter the response by. Supported fields for filtering: id, wikidata_id, category, roles.
     * @type {string | Null}
     * @memberof TopicsApiGetTopics
     */
    readonly filter?: string | Null

    /**
     * Field to sort the response by. Supported fields for sorting: none.
     * @type {string | Null}
     * @memberof TopicsApiGetTopics
     */
    readonly sort?: string | Null

    /**
     * Field to search within. Supported fields for searching: name.
     * @type {string | Null}
     * @memberof TopicsApiGetTopics
     */
    readonly search?: string | Null

    /**
     * Comma-separated list of fields to include in the response.
     * @type {string | Null}
     * @memberof TopicsApiGetTopics
     */
    readonly fields?: string | Null

    /**
     * Offset
     * @type {number}
     * @memberof TopicsApiGetTopics
     */
    readonly offset?: number

    /**
     * Limit
     * @type {number}
     * @memberof TopicsApiGetTopics
     */
    readonly limit?: number
}

/**
 * TopicsApi - object-oriented interface
 * @export
 * @class TopicsApi
 * @extends {BaseAPI}
 */
export class TopicsApi extends BaseAPI {
    /**
     * Get a topic by its ID.
     * @summary Get a topic
     * @param {TopicsApiGetTopicByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TopicsApi
     */
    public getTopicById(requestParameters: TopicsApiGetTopicByIdRequest, options?: AxiosRequestConfig) {
        return TopicsApiFp(this.configuration).getTopicById(requestParameters.topicId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of determinants for a given topic. These are formatted as `TopicPath`s, which include data about the relationship and the source topic.
     * @summary Get topic determinants
     * @param {TopicsApiGetTopicDeterminantsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TopicsApi
     */
    public getTopicDeterminants(requestParameters: TopicsApiGetTopicDeterminantsRequest, options?: AxiosRequestConfig) {
        return TopicsApiFp(this.configuration).getTopicDeterminants(requestParameters.topicId, requestParameters.filter, requestParameters.sort, requestParameters.search, requestParameters.fields, requestParameters.offset, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of interventions for a given topic. These are formatted as `TopicPath`s, which include data about the relationship and the source topic.
     * @summary Get topic interventions
     * @param {TopicsApiGetTopicInterventionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TopicsApi
     */
    public getTopicInterventions(requestParameters: TopicsApiGetTopicInterventionsRequest, options?: AxiosRequestConfig) {
        return TopicsApiFp(this.configuration).getTopicInterventions(requestParameters.topicId, requestParameters.filter, requestParameters.sort, requestParameters.search, requestParameters.fields, requestParameters.offset, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of outcomes for a given topic. These are formatted as `TopicPath`s, which include data about the relationship and the target topic.
     * @summary Get topic outcomes
     * @param {TopicsApiGetTopicOutcomesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TopicsApi
     */
    public getTopicOutcomes(requestParameters: TopicsApiGetTopicOutcomesRequest, options?: AxiosRequestConfig) {
        return TopicsApiFp(this.configuration).getTopicOutcomes(requestParameters.topicId, requestParameters.filter, requestParameters.sort, requestParameters.search, requestParameters.fields, requestParameters.offset, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of the relationships that include a given topic as the source or target topic.
     * @summary Get topic relationships
     * @param {TopicsApiGetTopicRelationshipsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TopicsApi
     */
    public getTopicRelationships(requestParameters: TopicsApiGetTopicRelationshipsRequest, options?: AxiosRequestConfig) {
        return TopicsApiFp(this.configuration).getTopicRelationships(requestParameters.topicId, requestParameters.filter, requestParameters.sort, requestParameters.search, requestParameters.fields, requestParameters.offset, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of the variables that have been matched to a given topic.
     * @summary Get topic variables
     * @param {TopicsApiGetTopicVariablesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TopicsApi
     */
    public getTopicVariables(requestParameters: TopicsApiGetTopicVariablesRequest, options?: AxiosRequestConfig) {
        return TopicsApiFp(this.configuration).getTopicVariables(requestParameters.topicId, requestParameters.filter, requestParameters.sort, requestParameters.search, requestParameters.fields, requestParameters.offset, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of topics.
     * @summary Get topics
     * @param {TopicsApiGetTopicsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TopicsApi
     */
    public getTopics(requestParameters: TopicsApiGetTopicsRequest = {}, options?: AxiosRequestConfig) {
        return TopicsApiFp(this.configuration).getTopics(requestParameters.filter, requestParameters.sort, requestParameters.search, requestParameters.fields, requestParameters.offset, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * VariablesApi - axios parameter creator
 * @export
 */
export const VariablesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a variable by its ID.
         * @summary Get a variable
         * @param {string} variableId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVariableById: async (variableId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'variableId' is not null or undefined
            assertParamExists('getVariableById', 'variableId', variableId)
            const localVarPath = `/v0/variables/{variable_id}`
                .replace(`{${"variable_id"}}`, encodeURIComponent(String(variableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of the statistical findings that include a given variable.
         * @summary Get variable statistical findings
         * @param {string} variableId 
         * @param {string | Null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, flagged, topic_1, topic_2, variable_1.id, variable_2.id, study.id, study.doi, statistic_type.
         * @param {string | Null} [sort] Field to sort the response by. Supported fields for sorting: none.
         * @param {string | Null} [search] Field to search within. Supported fields for searching: none.
         * @param {string | Null} [fields] Comma-separated list of fields to include in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVariableStatisticalFindings: async (variableId: string, filter?: string | Null, sort?: string | Null, search?: string | Null, fields?: string | Null, offset?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'variableId' is not null or undefined
            assertParamExists('getVariableStatisticalFindings', 'variableId', variableId)
            const localVarPath = `/v0/variables/{variable_id}/statistical_findings`
                .replace(`{${"variable_id"}}`, encodeURIComponent(String(variableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of variables.
         * @summary Get variables
         * @param {string | Null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, num_studies, topic.
         * @param {string | Null} [sort] Field to sort the response by. Supported fields for sorting: num_studies.
         * @param {string | Null} [search] Field to search within. Supported fields for searching: name.
         * @param {string | Null} [fields] Comma-separated list of fields to include in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVariables: async (filter?: string | Null, sort?: string | Null, search?: string | Null, fields?: string | Null, offset?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v0/variables`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VariablesApi - functional programming interface
 * @export
 */
export const VariablesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VariablesApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a variable by its ID.
         * @summary Get a variable
         * @param {string} variableId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVariableById(variableId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Variable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVariableById(variableId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of the statistical findings that include a given variable.
         * @summary Get variable statistical findings
         * @param {string} variableId 
         * @param {string | Null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, flagged, topic_1, topic_2, variable_1.id, variable_2.id, study.id, study.doi, statistic_type.
         * @param {string | Null} [sort] Field to sort the response by. Supported fields for sorting: none.
         * @param {string | Null} [search] Field to search within. Supported fields for searching: none.
         * @param {string | Null} [fields] Comma-separated list of fields to include in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVariableStatisticalFindings(variableId: string, filter?: string | Null, sort?: string | Null, search?: string | Null, fields?: string | Null, offset?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListResponseStatisticalFinding>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVariableStatisticalFindings(variableId, filter, sort, search, fields, offset, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of variables.
         * @summary Get variables
         * @param {string | Null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, num_studies, topic.
         * @param {string | Null} [sort] Field to sort the response by. Supported fields for sorting: num_studies.
         * @param {string | Null} [search] Field to search within. Supported fields for searching: name.
         * @param {string | Null} [fields] Comma-separated list of fields to include in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVariables(filter?: string | Null, sort?: string | Null, search?: string | Null, fields?: string | Null, offset?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListResponseVariable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVariables(filter, sort, search, fields, offset, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * VariablesApi - factory interface
 * @export
 */
export const VariablesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VariablesApiFp(configuration)
    return {
        /**
         * Get a variable by its ID.
         * @summary Get a variable
         * @param {string} variableId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVariableById(variableId: string, options?: any): AxiosPromise<Variable> {
            return localVarFp.getVariableById(variableId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of the statistical findings that include a given variable.
         * @summary Get variable statistical findings
         * @param {string} variableId 
         * @param {string | Null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, flagged, topic_1, topic_2, variable_1.id, variable_2.id, study.id, study.doi, statistic_type.
         * @param {string | Null} [sort] Field to sort the response by. Supported fields for sorting: none.
         * @param {string | Null} [search] Field to search within. Supported fields for searching: none.
         * @param {string | Null} [fields] Comma-separated list of fields to include in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVariableStatisticalFindings(variableId: string, filter?: string | Null, sort?: string | Null, search?: string | Null, fields?: string | Null, offset?: number, limit?: number, options?: any): AxiosPromise<ListResponseStatisticalFinding> {
            return localVarFp.getVariableStatisticalFindings(variableId, filter, sort, search, fields, offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of variables.
         * @summary Get variables
         * @param {string | Null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, num_studies, topic.
         * @param {string | Null} [sort] Field to sort the response by. Supported fields for sorting: num_studies.
         * @param {string | Null} [search] Field to search within. Supported fields for searching: name.
         * @param {string | Null} [fields] Comma-separated list of fields to include in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVariables(filter?: string | Null, sort?: string | Null, search?: string | Null, fields?: string | Null, offset?: number, limit?: number, options?: any): AxiosPromise<ListResponseVariable> {
            return localVarFp.getVariables(filter, sort, search, fields, offset, limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getVariableById operation in VariablesApi.
 * @export
 * @interface VariablesApiGetVariableByIdRequest
 */
export interface VariablesApiGetVariableByIdRequest {
    /**
     * 
     * @type {string}
     * @memberof VariablesApiGetVariableById
     */
    readonly variableId: string
}

/**
 * Request parameters for getVariableStatisticalFindings operation in VariablesApi.
 * @export
 * @interface VariablesApiGetVariableStatisticalFindingsRequest
 */
export interface VariablesApiGetVariableStatisticalFindingsRequest {
    /**
     * 
     * @type {string}
     * @memberof VariablesApiGetVariableStatisticalFindings
     */
    readonly variableId: string

    /**
     * Fields and values to filter the response by. Supported fields for filtering: id, flagged, topic_1, topic_2, variable_1.id, variable_2.id, study.id, study.doi, statistic_type.
     * @type {string | Null}
     * @memberof VariablesApiGetVariableStatisticalFindings
     */
    readonly filter?: string | Null

    /**
     * Field to sort the response by. Supported fields for sorting: none.
     * @type {string | Null}
     * @memberof VariablesApiGetVariableStatisticalFindings
     */
    readonly sort?: string | Null

    /**
     * Field to search within. Supported fields for searching: none.
     * @type {string | Null}
     * @memberof VariablesApiGetVariableStatisticalFindings
     */
    readonly search?: string | Null

    /**
     * Comma-separated list of fields to include in the response.
     * @type {string | Null}
     * @memberof VariablesApiGetVariableStatisticalFindings
     */
    readonly fields?: string | Null

    /**
     * Offset
     * @type {number}
     * @memberof VariablesApiGetVariableStatisticalFindings
     */
    readonly offset?: number

    /**
     * Limit
     * @type {number}
     * @memberof VariablesApiGetVariableStatisticalFindings
     */
    readonly limit?: number
}

/**
 * Request parameters for getVariables operation in VariablesApi.
 * @export
 * @interface VariablesApiGetVariablesRequest
 */
export interface VariablesApiGetVariablesRequest {
    /**
     * Fields and values to filter the response by. Supported fields for filtering: id, num_studies, topic.
     * @type {string | Null}
     * @memberof VariablesApiGetVariables
     */
    readonly filter?: string | Null

    /**
     * Field to sort the response by. Supported fields for sorting: num_studies.
     * @type {string | Null}
     * @memberof VariablesApiGetVariables
     */
    readonly sort?: string | Null

    /**
     * Field to search within. Supported fields for searching: name.
     * @type {string | Null}
     * @memberof VariablesApiGetVariables
     */
    readonly search?: string | Null

    /**
     * Comma-separated list of fields to include in the response.
     * @type {string | Null}
     * @memberof VariablesApiGetVariables
     */
    readonly fields?: string | Null

    /**
     * Offset
     * @type {number}
     * @memberof VariablesApiGetVariables
     */
    readonly offset?: number

    /**
     * Limit
     * @type {number}
     * @memberof VariablesApiGetVariables
     */
    readonly limit?: number
}

/**
 * VariablesApi - object-oriented interface
 * @export
 * @class VariablesApi
 * @extends {BaseAPI}
 */
export class VariablesApi extends BaseAPI {
    /**
     * Get a variable by its ID.
     * @summary Get a variable
     * @param {VariablesApiGetVariableByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariablesApi
     */
    public getVariableById(requestParameters: VariablesApiGetVariableByIdRequest, options?: AxiosRequestConfig) {
        return VariablesApiFp(this.configuration).getVariableById(requestParameters.variableId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of the statistical findings that include a given variable.
     * @summary Get variable statistical findings
     * @param {VariablesApiGetVariableStatisticalFindingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariablesApi
     */
    public getVariableStatisticalFindings(requestParameters: VariablesApiGetVariableStatisticalFindingsRequest, options?: AxiosRequestConfig) {
        return VariablesApiFp(this.configuration).getVariableStatisticalFindings(requestParameters.variableId, requestParameters.filter, requestParameters.sort, requestParameters.search, requestParameters.fields, requestParameters.offset, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of variables.
     * @summary Get variables
     * @param {VariablesApiGetVariablesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariablesApi
     */
    public getVariables(requestParameters: VariablesApiGetVariablesRequest = {}, options?: AxiosRequestConfig) {
        return VariablesApiFp(this.configuration).getVariables(requestParameters.filter, requestParameters.sort, requestParameters.search, requestParameters.fields, requestParameters.offset, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }
}


