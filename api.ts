/* tslint:disable */
/* eslint-disable */
/**
 * System REST API
 *  This page provides documentation for the System REST API.  If you have any questions or need support, please contact us at the email provided.  ## Formatting query parameters  Filters should be formatted as `field:value` and use the pipe operator `|` to specify an OR condition.   If they are numerical, they should be formatted as `field:opvalue`. Examples: - `doi:10.1234/5678|10.8765/4321` - `num_findings:>2`  Sorts should be formatted as `field:direction`. Examples: - `cited_by:desc` - `publish_date:asc`  Searches should be formatted as `field:value`. Examples: - `name:osteoporosis` 
 *
 * The version of the OpenAPI document: 0.1.0
 * Contact: api@system.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * Cluster.
 * @export
 * @interface Cluster
 */
export interface Cluster {
    /**
     * 
     * @type {string}
     * @memberof Cluster
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Cluster
     */
    'cluster_label_1': string;
    /**
     * 
     * @type {string}
     * @memberof Cluster
     */
    'cluster_label_2': string;
    /**
     * 
     * @type {string}
     * @memberof Cluster
     */
    'summary': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Cluster
     */
    'finding_ids': Array<string>;
}
/**
 * Flag.
 * @export
 * @interface Flag
 */
export interface Flag {
    /**
     * 
     * @type {string}
     * @memberof Flag
     */
    'flagged_property': string;
    /**
     * 
     * @type {string}
     * @memberof Flag
     */
    'reason'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Flag
     */
    'resource_id': string;
    /**
     * 
     * @type {string}
     * @memberof Flag
     */
    'system_id': string;
}
/**
 * Flag input.
 * @export
 * @interface FlagInput
 */
export interface FlagInput {
    /**
     * 
     * @type {string}
     * @memberof FlagInput
     */
    'flagged_property': string;
    /**
     * 
     * @type {string}
     * @memberof FlagInput
     */
    'reason'?: string | null;
}
/**
 * Graph response.
 * @export
 * @interface GraphResponse
 */
export interface GraphResponse {
    /**
     * 
     * @type {Array<Node>}
     * @memberof GraphResponse
     */
    'nodes': Array<Node>;
    /**
     * 
     * @type {Array<Link>}
     * @memberof GraphResponse
     */
    'links': Array<Link>;
}
/**
 * 
 * @export
 * @interface HTTPValidationError
 */
export interface HTTPValidationError {
    /**
     * 
     * @type {Array<ValidationError>}
     * @memberof HTTPValidationError
     */
    'detail'?: Array<ValidationError>;
}
/**
 * Link.
 * @export
 * @interface Link
 */
export interface Link {
    /**
     * 
     * @type {string}
     * @memberof Link
     */
    'source': string;
    /**
     * 
     * @type {string}
     * @memberof Link
     */
    'target': string;
}
/**
 * 
 * @export
 * @interface ListResponseCluster
 */
export interface ListResponseCluster {
    /**
     * 
     * @type {Array<Cluster>}
     * @memberof ListResponseCluster
     */
    'data': Array<Cluster>;
    /**
     * 
     * @type {number}
     * @memberof ListResponseCluster
     */
    'total': number;
}
/**
 * 
 * @export
 * @interface ListResponseRelationship
 */
export interface ListResponseRelationship {
    /**
     * 
     * @type {Array<Relationship>}
     * @memberof ListResponseRelationship
     */
    'data': Array<Relationship>;
    /**
     * 
     * @type {number}
     * @memberof ListResponseRelationship
     */
    'total': number;
}
/**
 * 
 * @export
 * @interface ListResponseStatisticalFinding
 */
export interface ListResponseStatisticalFinding {
    /**
     * 
     * @type {Array<StatisticalFinding>}
     * @memberof ListResponseStatisticalFinding
     */
    'data': Array<StatisticalFinding>;
    /**
     * 
     * @type {number}
     * @memberof ListResponseStatisticalFinding
     */
    'total': number;
}
/**
 * 
 * @export
 * @interface ListResponseStudy
 */
export interface ListResponseStudy {
    /**
     * 
     * @type {Array<Study>}
     * @memberof ListResponseStudy
     */
    'data': Array<Study>;
    /**
     * 
     * @type {number}
     * @memberof ListResponseStudy
     */
    'total': number;
}
/**
 * 
 * @export
 * @interface ListResponseTopic
 */
export interface ListResponseTopic {
    /**
     * 
     * @type {Array<Topic>}
     * @memberof ListResponseTopic
     */
    'data': Array<Topic>;
    /**
     * 
     * @type {number}
     * @memberof ListResponseTopic
     */
    'total': number;
}
/**
 * 
 * @export
 * @interface ListResponseTopicPath
 */
export interface ListResponseTopicPath {
    /**
     * 
     * @type {Array<TopicPath>}
     * @memberof ListResponseTopicPath
     */
    'data': Array<TopicPath>;
    /**
     * 
     * @type {number}
     * @memberof ListResponseTopicPath
     */
    'total': number;
}
/**
 * 
 * @export
 * @interface ListResponseVariable
 */
export interface ListResponseVariable {
    /**
     * 
     * @type {Array<Variable>}
     * @memberof ListResponseVariable
     */
    'data': Array<Variable>;
    /**
     * 
     * @type {number}
     * @memberof ListResponseVariable
     */
    'total': number;
}
/**
 * Nested resource.
 * @export
 * @interface NestedResource
 */
export interface NestedResource {
    /**
     * Unique identifier
     * @type {string}
     * @memberof NestedResource
     */
    'id': string;
    /**
     * Name of the resource
     * @type {string}
     * @memberof NestedResource
     */
    'name': string;
}
/**
 * Nested study.
 * @export
 * @interface NestedStudy
 */
export interface NestedStudy {
    /**
     * Unique identifier
     * @type {string}
     * @memberof NestedStudy
     */
    'id': string;
    /**
     * Digital Object Identifier (DOI)
     * @type {string}
     * @memberof NestedStudy
     */
    'doi'?: string;
    /**
     * Population studied
     * @type {string}
     * @memberof NestedStudy
     */
    'population'?: string;
    /**
     * Sample size of the study
     * @type {string}
     * @memberof NestedStudy
     */
    'sample_size'?: string;
}
/**
 * Node.
 * @export
 * @interface Node
 */
export interface Node {
    /**
     * 
     * @type {string}
     * @memberof Node
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Node
     */
    'label'?: string | null;
}
/**
 * Pubmed search synthesis input.
 * @export
 * @interface PubmedSearchSynthesisInput
 */
export interface PubmedSearchSynthesisInput {
    /**
     * 
     * @type {string}
     * @memberof PubmedSearchSynthesisInput
     */
    'query': string;
}
/**
 * Relationship.
 * @export
 * @interface Relationship
 */
export interface Relationship {
    /**
     * Unique identifier of relationship.
     * @type {string}
     * @memberof Relationship
     */
    'id': string;
    /**
     * Number of findings on relationship
     * @type {number}
     * @memberof Relationship
     */
    'num_findings': number;
    /**
     * Number of studies supporting relationship
     * @type {number}
     * @memberof Relationship
     */
    'num_studies': number;
    /**
     * Number of significant findings on relationship
     * @type {number}
     * @memberof Relationship
     */
    'num_significant_findings': number;
    /**
     * Highest cited study supporting relationship
     * @type {number}
     * @memberof Relationship
     */
    'highest_cited'?: number;
    /**
     * 
     * @type {number}
     * @memberof Relationship
     */
    'median_effect_size'?: number | null;
    /**
     * Date relationship was last updated
     * @type {string}
     * @memberof Relationship
     */
    'last_updated': string;
    /**
     * Whether or not the relationship is supported by an experimental trial
     * @type {boolean}
     * @memberof Relationship
     */
    'has_experimental_trial': boolean;
    /**
     * 
     * @type {Topic}
     * @memberof Relationship
     */
    'source_topic': Topic;
    /**
     * 
     * @type {Topic}
     * @memberof Relationship
     */
    'target_topic': Topic;
}
/**
 * Statistic type.
 * @export
 * @enum {string}
 */

export const StatisticType = {
    OddsRatio: 'odds_ratio',
    AdjustedOddsRatio: 'adjusted_odds_ratio',
    HazardRatio: 'hazard_ratio',
    AdjustedHazardRatio: 'adjusted_hazard_ratio',
    RelativeRiskRatio: 'relative_risk_ratio',
    Coefficient: 'coefficient',
    PearsonR: 'pearson_r',
    IncidentRateRatio: 'incident_rate_ratio',
    PrevalenceRatio: 'prevalence_ratio',
    SpearmanCorrelation: 'spearman_correlation',
    MeanDifferenceStandardized: 'mean_difference_standardized',
    MeanDifferenceUnstandardized: 'mean_difference_unstandardized',
    RiskDifference: 'risk_difference',
    CoefficientOfDetermination: 'coefficient_of_determination',
    TTest: 't_test',
    Elasticity: 'elasticity',
    GiniCoefficient: 'gini_coefficient'
} as const;

export type StatisticType = typeof StatisticType[keyof typeof StatisticType];


/**
 * Statistical finding.
 * @export
 * @interface StatisticalFinding
 */
export interface StatisticalFinding {
    /**
     * Unique identifier
     * @type {string}
     * @memberof StatisticalFinding
     */
    'id': string;
    /**
     * Whether finding is flagged
     * @type {boolean}
     * @memberof StatisticalFinding
     */
    'flagged'?: boolean;
    /**
     * Type of finding
     * @type {string}
     * @memberof StatisticalFinding
     */
    'finding_type'?: StatisticalFindingFindingTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof StatisticalFinding
     */
    'summary'?: string | null;
    /**
     * 
     * @type {NestedResource}
     * @memberof StatisticalFinding
     */
    'topic_1'?: NestedResource | null;
    /**
     * 
     * @type {NestedResource}
     * @memberof StatisticalFinding
     */
    'topic_2'?: NestedResource | null;
    /**
     * 
     * @type {NestedResource}
     * @memberof StatisticalFinding
     */
    'variable_1'?: NestedResource;
    /**
     * 
     * @type {NestedResource}
     * @memberof StatisticalFinding
     */
    'variable_2'?: NestedResource;
    /**
     * 
     * @type {NestedStudy}
     * @memberof StatisticalFinding
     */
    'study'?: NestedStudy;
    /**
     * 
     * @type {StatisticType}
     * @memberof StatisticalFinding
     */
    'statistic_type'?: StatisticType | null;
    /**
     * 
     * @type {number}
     * @memberof StatisticalFinding
     */
    'statistic_value'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof StatisticalFinding
     */
    'ci_upper'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof StatisticalFinding
     */
    'ci_lower'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof StatisticalFinding
     */
    'p_value'?: number | null;
}

export const StatisticalFindingFindingTypeEnum = {
    Statistical: 'statistical'
} as const;

export type StatisticalFindingFindingTypeEnum = typeof StatisticalFindingFindingTypeEnum[keyof typeof StatisticalFindingFindingTypeEnum];

/**
 * Study.
 * @export
 * @interface Study
 */
export interface Study {
    /**
     * Unique identifier
     * @type {string}
     * @memberof Study
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Study
     */
    'doi'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Study
     */
    'title'?: string | null;
    /**
     * Authors of the study
     * @type {}
     * @memberof Study
     */
    'authors'?:  | null;
    /**
     * 
     * @type {string}
     * @memberof Study
     */
    'journal'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Study
     */
    'publish_date'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Study
     */
    'population'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Study
     */
    'sample_size'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof Study
     */
    'summary'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Study
     */
    'cited_by'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof Study
     */
    'study_type'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Study
     */
    'retraction_reason'?: string | null;
}
/**
 * Topic.
 * @export
 * @interface Topic
 */
export interface Topic {
    /**
     * Unique identifier
     * @type {string}
     * @memberof Topic
     */
    'id': string;
    /**
     * Name of the topic
     * @type {string}
     * @memberof Topic
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Topic
     */
    'wikidata_id'?: string | null;
    /**
     * UMLS Concept Unique Identifiers (CUIs) for the topic
     * @type {}
     * @memberof Topic
     */
    'umls_cuis'?:  | null;
    /**
     * 
     * @type {TopicCategory}
     * @memberof Topic
     */
    'category'?: TopicCategory | null;
    /**
     * Roles associated with the topic
     * @type {}
     * @memberof Topic
     */
    'roles'?:  | null;
}


/**
 * Topic category.
 * @export
 * @enum {string}
 */

export const TopicCategory = {
    BiomedicalDiseasesDisorders: 'Biomedical - Diseases & Disorders',
    BiomedicalHospitalization: 'Biomedical - Hospitalization',
    BiomedicalMortalitySurvival: 'Biomedical - Mortality/survival',
    BiomedicalPathogen: 'Biomedical - Pathogen',
    BiomedicalEthnicity: 'Biomedical - Ethnicity',
    BiomedicalOtherBiologicalFactors: 'Biomedical - Other Biological factors',
    BiomedicalAnthropometry: 'Biomedical - Anthropometry',
    BiomedicalAge: 'Biomedical - Age',
    BiomedicalSex: 'Biomedical - Sex',
    BiomedicalCarcinogen: 'Biomedical - Carcinogen',
    BiomedicalGenetics: 'Biomedical - Genetics',
    BehavioralPersonalHygiene: 'Behavioral - Personal hygiene',
    BehavioralOtherDietaryFactors: 'Behavioral - Other dietary factors',
    BehavioralStress: 'Behavioral - Stress',
    BehavioralSubstanceUse: 'Behavioral - Substance Use',
    BehavioralEatingBehaviors: 'Behavioral - Eating behaviors',
    BehavioralSleep: 'Behavioral - Sleep',
    BehavioralPhysicalActivity: 'Behavioral - Physical activity',
    BehavioralOtherBehavioralFactors: 'Behavioral - Other behavioral factors',
    BehavioralSexualBehavior: 'Behavioral - Sexual behavior',
    EnvironmentalAirQuality: 'Environmental - Air quality',
    EnvironmentalWaterQuality: 'Environmental - Water quality',
    EnvironmentalWeatherAndClimateChange: 'Environmental - Weather and climate change',
    EnvironmentalOtherEnvironmentalFactors: 'Environmental - Other Environmental factors',
    SocialEducation: 'Social - Education',
    SocialEconomicContext: 'Social - Economic context',
    SocialOtherSocialFactors: 'Social - Other social factors',
    SocialPhysicalInfrastructure: 'Social - Physical infrastructure',
    SocialSocialContext: 'Social - Social context',
    SocialHealthcareContext: 'Social - Healthcare context',
    SocialOccupation: 'Social - Occupation',
    SocialGeography: 'Social - Geography',
    SocialOccupationalContext: 'Social - Occupational context',
    Healing: 'Healing',
    Preventative: 'Preventative',
    Diagnostic: 'Diagnostic',
    Preservative: 'Preservative',
    Managing: 'Managing',
    Therapeutic: 'Therapeutic',
    Other: 'Other'
} as const;

export type TopicCategory = typeof TopicCategory[keyof typeof TopicCategory];


/**
 * Path to topic.
 * @export
 * @interface TopicPath
 */
export interface TopicPath {
    /**
     * Unique identifier of relationship.
     * @type {string}
     * @memberof TopicPath
     */
    'id': string;
    /**
     * Number of findings on relationship
     * @type {number}
     * @memberof TopicPath
     */
    'num_findings': number;
    /**
     * Number of studies supporting relationship
     * @type {number}
     * @memberof TopicPath
     */
    'num_studies': number;
    /**
     * Number of significant findings on relationship
     * @type {number}
     * @memberof TopicPath
     */
    'num_significant_findings': number;
    /**
     * Highest cited study supporting relationship
     * @type {number}
     * @memberof TopicPath
     */
    'highest_cited'?: number;
    /**
     * 
     * @type {number}
     * @memberof TopicPath
     */
    'median_effect_size'?: number | null;
    /**
     * Date relationship was last updated
     * @type {string}
     * @memberof TopicPath
     */
    'last_updated': string;
    /**
     * Whether or not the relationship is supported by an experimental trial
     * @type {boolean}
     * @memberof TopicPath
     */
    'has_experimental_trial': boolean;
    /**
     * 
     * @type {Topic}
     * @memberof TopicPath
     */
    'topic': Topic;
}
/**
 * Topic role.
 * @export
 * @enum {string}
 */

export const TopicRole = {
    Determinant: 'Determinant',
    Intervention: 'Intervention',
    Outcome: 'Outcome',
    Agent: 'Agent'
} as const;

export type TopicRole = typeof TopicRole[keyof typeof TopicRole];


/**
 * 
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
    /**
     * 
     * @type {Array<ValidationErrorLocInner>}
     * @memberof ValidationError
     */
    'loc': Array<ValidationErrorLocInner>;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface ValidationErrorLocInner
 */
export interface ValidationErrorLocInner {
}
/**
 * Variable.
 * @export
 * @interface Variable
 */
export interface Variable {
    /**
     * Unique identifier
     * @type {string}
     * @memberof Variable
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Variable
     */
    'name'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Variable
     */
    'num_studies'?: number | null;
    /**
     * 
     * @type {NestedResource}
     * @memberof Variable
     */
    'topic'?: NestedResource | null;
}

/**
 * GraphApi - axios parameter creator
 * @export
 */
export const GraphApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Gets a subgraph of a topic by id.         The subgraph includes upstream and downstream relationships within two hops.         If the response takes too long or is too large, consider using filters to reduce the size of the response.
         * @summary Get subgraph by topic id
         * @param {string} topicId 
         * @param {string | null} [upstream1Filter] Fields and values to filter the first upstream relationship. Supported fields for filtering: id, num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial, topic.id, topic.wikidata_id, topic.category, topic.roles.
         * @param {string | null} [upstream2Filter] Fields and values to filter the second upstream relationship. Supported fields for filtering: id, num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial, topic.id, topic.wikidata_id, topic.category, topic.roles.
         * @param {string | null} [downstream1Filter] Fields and values to filter the first downstream relationship. Supported fields for filtering: id, num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial, topic.id, topic.wikidata_id, topic.category, topic.roles.
         * @param {string | null} [downstream2Filter] Fields and values to filter the second downstream relationship. Supported fields for filtering: id, num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial, topic.id, topic.wikidata_id, topic.category, topic.roles.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubgraphByTopicId: async (topicId: string, upstream1Filter?: string | null, upstream2Filter?: string | null, downstream1Filter?: string | null, downstream2Filter?: string | null, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'topicId' is not null or undefined
            assertParamExists('getSubgraphByTopicId', 'topicId', topicId)
            const localVarPath = `/v0/graph/{topic_id}`
                .replace(`{${"topic_id"}}`, encodeURIComponent(String(topicId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (upstream1Filter !== undefined) {
                localVarQueryParameter['upstream_1_filter'] = upstream1Filter;
            }

            if (upstream2Filter !== undefined) {
                localVarQueryParameter['upstream_2_filter'] = upstream2Filter;
            }

            if (downstream1Filter !== undefined) {
                localVarQueryParameter['downstream_1_filter'] = downstream1Filter;
            }

            if (downstream2Filter !== undefined) {
                localVarQueryParameter['downstream_2_filter'] = downstream2Filter;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GraphApi - functional programming interface
 * @export
 */
export const GraphApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GraphApiAxiosParamCreator(configuration)
    return {
        /**
         * Gets a subgraph of a topic by id.         The subgraph includes upstream and downstream relationships within two hops.         If the response takes too long or is too large, consider using filters to reduce the size of the response.
         * @summary Get subgraph by topic id
         * @param {string} topicId 
         * @param {string | null} [upstream1Filter] Fields and values to filter the first upstream relationship. Supported fields for filtering: id, num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial, topic.id, topic.wikidata_id, topic.category, topic.roles.
         * @param {string | null} [upstream2Filter] Fields and values to filter the second upstream relationship. Supported fields for filtering: id, num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial, topic.id, topic.wikidata_id, topic.category, topic.roles.
         * @param {string | null} [downstream1Filter] Fields and values to filter the first downstream relationship. Supported fields for filtering: id, num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial, topic.id, topic.wikidata_id, topic.category, topic.roles.
         * @param {string | null} [downstream2Filter] Fields and values to filter the second downstream relationship. Supported fields for filtering: id, num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial, topic.id, topic.wikidata_id, topic.category, topic.roles.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSubgraphByTopicId(topicId: string, upstream1Filter?: string | null, upstream2Filter?: string | null, downstream1Filter?: string | null, downstream2Filter?: string | null, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GraphResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSubgraphByTopicId(topicId, upstream1Filter, upstream2Filter, downstream1Filter, downstream2Filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * GraphApi - factory interface
 * @export
 */
export const GraphApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GraphApiFp(configuration)
    return {
        /**
         * Gets a subgraph of a topic by id.         The subgraph includes upstream and downstream relationships within two hops.         If the response takes too long or is too large, consider using filters to reduce the size of the response.
         * @summary Get subgraph by topic id
         * @param {string} topicId 
         * @param {string | null} [upstream1Filter] Fields and values to filter the first upstream relationship. Supported fields for filtering: id, num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial, topic.id, topic.wikidata_id, topic.category, topic.roles.
         * @param {string | null} [upstream2Filter] Fields and values to filter the second upstream relationship. Supported fields for filtering: id, num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial, topic.id, topic.wikidata_id, topic.category, topic.roles.
         * @param {string | null} [downstream1Filter] Fields and values to filter the first downstream relationship. Supported fields for filtering: id, num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial, topic.id, topic.wikidata_id, topic.category, topic.roles.
         * @param {string | null} [downstream2Filter] Fields and values to filter the second downstream relationship. Supported fields for filtering: id, num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial, topic.id, topic.wikidata_id, topic.category, topic.roles.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubgraphByTopicId(topicId: string, upstream1Filter?: string | null, upstream2Filter?: string | null, downstream1Filter?: string | null, downstream2Filter?: string | null, options?: any): AxiosPromise<GraphResponse> {
            return localVarFp.getSubgraphByTopicId(topicId, upstream1Filter, upstream2Filter, downstream1Filter, downstream2Filter, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GraphApi - object-oriented interface
 * @export
 * @class GraphApi
 * @extends {BaseAPI}
 */
export class GraphApi extends BaseAPI {
    /**
     * Gets a subgraph of a topic by id.         The subgraph includes upstream and downstream relationships within two hops.         If the response takes too long or is too large, consider using filters to reduce the size of the response.
     * @summary Get subgraph by topic id
     * @param {string} topicId 
     * @param {string | null} [upstream1Filter] Fields and values to filter the first upstream relationship. Supported fields for filtering: id, num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial, topic.id, topic.wikidata_id, topic.category, topic.roles.
     * @param {string | null} [upstream2Filter] Fields and values to filter the second upstream relationship. Supported fields for filtering: id, num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial, topic.id, topic.wikidata_id, topic.category, topic.roles.
     * @param {string | null} [downstream1Filter] Fields and values to filter the first downstream relationship. Supported fields for filtering: id, num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial, topic.id, topic.wikidata_id, topic.category, topic.roles.
     * @param {string | null} [downstream2Filter] Fields and values to filter the second downstream relationship. Supported fields for filtering: id, num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial, topic.id, topic.wikidata_id, topic.category, topic.roles.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApi
     */
    public getSubgraphByTopicId(topicId: string, upstream1Filter?: string | null, upstream2Filter?: string | null, downstream1Filter?: string | null, downstream2Filter?: string | null, options?: AxiosRequestConfig) {
        return GraphApiFp(this.configuration).getSubgraphByTopicId(topicId, upstream1Filter, upstream2Filter, downstream1Filter, downstream2Filter, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RelationshipsApi - axios parameter creator
 * @export
 */
export const RelationshipsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a relationship by its ID.
         * @summary Get a relationship
         * @param {string} relationshipId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelationshipById: async (relationshipId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'relationshipId' is not null or undefined
            assertParamExists('getRelationshipById', 'relationshipId', relationshipId)
            const localVarPath = `/v0/relationships/{relationship_id}`
                .replace(`{${"relationship_id"}}`, encodeURIComponent(String(relationshipId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of the statistical findings underlying a given relationship.
         * @summary Get relationship statistical findings
         * @param {string} relationshipId 
         * @param {string | null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, flagged, topic_1, topic_2, variable_1.id, variable_2.id, study.id, study.doi, statistic_type.
         * @param {string | null} [sort] Field to sort the response by. Supported fields for sorting: none.
         * @param {string | null} [search] Field to search within. Supported fields for searching: none.
         * @param {string | null} [fields] Comma-separated list of fields to include in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelationshipStatisticalFindings: async (relationshipId: string, filter?: string | null, sort?: string | null, search?: string | null, fields?: string | null, offset?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'relationshipId' is not null or undefined
            assertParamExists('getRelationshipStatisticalFindings', 'relationshipId', relationshipId)
            const localVarPath = `/v0/relationships/{relationship_id}/statistical_findings`
                .replace(`{${"relationship_id"}}`, encodeURIComponent(String(relationshipId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of the studies underlying a given relationship.
         * @summary Get relationship studies
         * @param {string} relationshipId 
         * @param {string | null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, doi, publish_date, cited_by, study_type.
         * @param {string | null} [sort] Field to sort the response by. Supported fields for sorting: publish_date, sample_size, cited_by.
         * @param {string | null} [search] Field to search within. Supported fields for searching: title.
         * @param {string | null} [fields] Comma-separated list of fields to include in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelationshipStudies: async (relationshipId: string, filter?: string | null, sort?: string | null, search?: string | null, fields?: string | null, offset?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'relationshipId' is not null or undefined
            assertParamExists('getRelationshipStudies', 'relationshipId', relationshipId)
            const localVarPath = `/v0/relationships/{relationship_id}/studies`
                .replace(`{${"relationship_id"}}`, encodeURIComponent(String(relationshipId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of relationships.
         * @summary Get relationships
         * @param {string | null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial, source_topic.id, source_topic.wikidata_id, source_topic.category, source_topic.roles, target_topic.id, target_topic.wikidata_id, target_topic.category, target_topic.roles.
         * @param {string | null} [sort] Field to sort the response by. Supported fields for sorting: num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial.
         * @param {string | null} [search] Field to search within. Supported fields for searching: none.
         * @param {string | null} [fields] Comma-separated list of fields to include in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelationships: async (filter?: string | null, sort?: string | null, search?: string | null, fields?: string | null, offset?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v0/relationships`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RelationshipsApi - functional programming interface
 * @export
 */
export const RelationshipsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RelationshipsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a relationship by its ID.
         * @summary Get a relationship
         * @param {string} relationshipId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRelationshipById(relationshipId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Relationship>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRelationshipById(relationshipId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of the statistical findings underlying a given relationship.
         * @summary Get relationship statistical findings
         * @param {string} relationshipId 
         * @param {string | null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, flagged, topic_1, topic_2, variable_1.id, variable_2.id, study.id, study.doi, statistic_type.
         * @param {string | null} [sort] Field to sort the response by. Supported fields for sorting: none.
         * @param {string | null} [search] Field to search within. Supported fields for searching: none.
         * @param {string | null} [fields] Comma-separated list of fields to include in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRelationshipStatisticalFindings(relationshipId: string, filter?: string | null, sort?: string | null, search?: string | null, fields?: string | null, offset?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListResponseStatisticalFinding>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRelationshipStatisticalFindings(relationshipId, filter, sort, search, fields, offset, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of the studies underlying a given relationship.
         * @summary Get relationship studies
         * @param {string} relationshipId 
         * @param {string | null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, doi, publish_date, cited_by, study_type.
         * @param {string | null} [sort] Field to sort the response by. Supported fields for sorting: publish_date, sample_size, cited_by.
         * @param {string | null} [search] Field to search within. Supported fields for searching: title.
         * @param {string | null} [fields] Comma-separated list of fields to include in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRelationshipStudies(relationshipId: string, filter?: string | null, sort?: string | null, search?: string | null, fields?: string | null, offset?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListResponseStudy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRelationshipStudies(relationshipId, filter, sort, search, fields, offset, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of relationships.
         * @summary Get relationships
         * @param {string | null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial, source_topic.id, source_topic.wikidata_id, source_topic.category, source_topic.roles, target_topic.id, target_topic.wikidata_id, target_topic.category, target_topic.roles.
         * @param {string | null} [sort] Field to sort the response by. Supported fields for sorting: num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial.
         * @param {string | null} [search] Field to search within. Supported fields for searching: none.
         * @param {string | null} [fields] Comma-separated list of fields to include in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRelationships(filter?: string | null, sort?: string | null, search?: string | null, fields?: string | null, offset?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListResponseRelationship>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRelationships(filter, sort, search, fields, offset, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RelationshipsApi - factory interface
 * @export
 */
export const RelationshipsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RelationshipsApiFp(configuration)
    return {
        /**
         * Get a relationship by its ID.
         * @summary Get a relationship
         * @param {string} relationshipId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelationshipById(relationshipId: string, options?: any): AxiosPromise<Relationship> {
            return localVarFp.getRelationshipById(relationshipId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of the statistical findings underlying a given relationship.
         * @summary Get relationship statistical findings
         * @param {string} relationshipId 
         * @param {string | null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, flagged, topic_1, topic_2, variable_1.id, variable_2.id, study.id, study.doi, statistic_type.
         * @param {string | null} [sort] Field to sort the response by. Supported fields for sorting: none.
         * @param {string | null} [search] Field to search within. Supported fields for searching: none.
         * @param {string | null} [fields] Comma-separated list of fields to include in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelationshipStatisticalFindings(relationshipId: string, filter?: string | null, sort?: string | null, search?: string | null, fields?: string | null, offset?: number, limit?: number, options?: any): AxiosPromise<ListResponseStatisticalFinding> {
            return localVarFp.getRelationshipStatisticalFindings(relationshipId, filter, sort, search, fields, offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of the studies underlying a given relationship.
         * @summary Get relationship studies
         * @param {string} relationshipId 
         * @param {string | null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, doi, publish_date, cited_by, study_type.
         * @param {string | null} [sort] Field to sort the response by. Supported fields for sorting: publish_date, sample_size, cited_by.
         * @param {string | null} [search] Field to search within. Supported fields for searching: title.
         * @param {string | null} [fields] Comma-separated list of fields to include in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelationshipStudies(relationshipId: string, filter?: string | null, sort?: string | null, search?: string | null, fields?: string | null, offset?: number, limit?: number, options?: any): AxiosPromise<ListResponseStudy> {
            return localVarFp.getRelationshipStudies(relationshipId, filter, sort, search, fields, offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of relationships.
         * @summary Get relationships
         * @param {string | null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial, source_topic.id, source_topic.wikidata_id, source_topic.category, source_topic.roles, target_topic.id, target_topic.wikidata_id, target_topic.category, target_topic.roles.
         * @param {string | null} [sort] Field to sort the response by. Supported fields for sorting: num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial.
         * @param {string | null} [search] Field to search within. Supported fields for searching: none.
         * @param {string | null} [fields] Comma-separated list of fields to include in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelationships(filter?: string | null, sort?: string | null, search?: string | null, fields?: string | null, offset?: number, limit?: number, options?: any): AxiosPromise<ListResponseRelationship> {
            return localVarFp.getRelationships(filter, sort, search, fields, offset, limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RelationshipsApi - object-oriented interface
 * @export
 * @class RelationshipsApi
 * @extends {BaseAPI}
 */
export class RelationshipsApi extends BaseAPI {
    /**
     * Get a relationship by its ID.
     * @summary Get a relationship
     * @param {string} relationshipId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RelationshipsApi
     */
    public getRelationshipById(relationshipId: string, options?: AxiosRequestConfig) {
        return RelationshipsApiFp(this.configuration).getRelationshipById(relationshipId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of the statistical findings underlying a given relationship.
     * @summary Get relationship statistical findings
     * @param {string} relationshipId 
     * @param {string | null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, flagged, topic_1, topic_2, variable_1.id, variable_2.id, study.id, study.doi, statistic_type.
     * @param {string | null} [sort] Field to sort the response by. Supported fields for sorting: none.
     * @param {string | null} [search] Field to search within. Supported fields for searching: none.
     * @param {string | null} [fields] Comma-separated list of fields to include in the response.
     * @param {number} [offset] Offset
     * @param {number} [limit] Limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RelationshipsApi
     */
    public getRelationshipStatisticalFindings(relationshipId: string, filter?: string | null, sort?: string | null, search?: string | null, fields?: string | null, offset?: number, limit?: number, options?: AxiosRequestConfig) {
        return RelationshipsApiFp(this.configuration).getRelationshipStatisticalFindings(relationshipId, filter, sort, search, fields, offset, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of the studies underlying a given relationship.
     * @summary Get relationship studies
     * @param {string} relationshipId 
     * @param {string | null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, doi, publish_date, cited_by, study_type.
     * @param {string | null} [sort] Field to sort the response by. Supported fields for sorting: publish_date, sample_size, cited_by.
     * @param {string | null} [search] Field to search within. Supported fields for searching: title.
     * @param {string | null} [fields] Comma-separated list of fields to include in the response.
     * @param {number} [offset] Offset
     * @param {number} [limit] Limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RelationshipsApi
     */
    public getRelationshipStudies(relationshipId: string, filter?: string | null, sort?: string | null, search?: string | null, fields?: string | null, offset?: number, limit?: number, options?: AxiosRequestConfig) {
        return RelationshipsApiFp(this.configuration).getRelationshipStudies(relationshipId, filter, sort, search, fields, offset, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of relationships.
     * @summary Get relationships
     * @param {string | null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial, source_topic.id, source_topic.wikidata_id, source_topic.category, source_topic.roles, target_topic.id, target_topic.wikidata_id, target_topic.category, target_topic.roles.
     * @param {string | null} [sort] Field to sort the response by. Supported fields for sorting: num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial.
     * @param {string | null} [search] Field to search within. Supported fields for searching: none.
     * @param {string | null} [fields] Comma-separated list of fields to include in the response.
     * @param {number} [offset] Offset
     * @param {number} [limit] Limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RelationshipsApi
     */
    public getRelationships(filter?: string | null, sort?: string | null, search?: string | null, fields?: string | null, offset?: number, limit?: number, options?: AxiosRequestConfig) {
        return RelationshipsApiFp(this.configuration).getRelationships(filter, sort, search, fields, offset, limit, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * StatisticalFindingsApi - axios parameter creator
 * @export
 */
export const StatisticalFindingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Flag a statistical finding for review.
         * @summary Flag statistical finding
         * @param {string} findingId 
         * @param {Array<FlagInput>} flagInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        flagStatisticalFinding: async (findingId: string, flagInput: Array<FlagInput>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'findingId' is not null or undefined
            assertParamExists('flagStatisticalFinding', 'findingId', findingId)
            // verify required parameter 'flagInput' is not null or undefined
            assertParamExists('flagStatisticalFinding', 'flagInput', flagInput)
            const localVarPath = `/v0/statistical_findings/{finding_id}/flags`
                .replace(`{${"finding_id"}}`, encodeURIComponent(String(findingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(flagInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a statistical finding by its ID.
         * @summary Get a statistical finding
         * @param {string} findingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatisticalFindingById: async (findingId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'findingId' is not null or undefined
            assertParamExists('getStatisticalFindingById', 'findingId', findingId)
            const localVarPath = `/v0/statistical_findings/{finding_id}`
                .replace(`{${"finding_id"}}`, encodeURIComponent(String(findingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of statistical findings.
         * @summary Get statistical findings
         * @param {string | null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, flagged, topic_1, topic_2, variable_1.id, variable_2.id, study.id, study.doi, statistic_type.
         * @param {string | null} [sort] Field to sort the response by. Supported fields for sorting: none.
         * @param {string | null} [search] Field to search within. Supported fields for searching: none.
         * @param {string | null} [fields] Comma-separated list of fields to include in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatisticalFindings: async (filter?: string | null, sort?: string | null, search?: string | null, fields?: string | null, offset?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v0/statistical_findings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StatisticalFindingsApi - functional programming interface
 * @export
 */
export const StatisticalFindingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StatisticalFindingsApiAxiosParamCreator(configuration)
    return {
        /**
         * Flag a statistical finding for review.
         * @summary Flag statistical finding
         * @param {string} findingId 
         * @param {Array<FlagInput>} flagInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async flagStatisticalFinding(findingId: string, flagInput: Array<FlagInput>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Flag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.flagStatisticalFinding(findingId, flagInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a statistical finding by its ID.
         * @summary Get a statistical finding
         * @param {string} findingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStatisticalFindingById(findingId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatisticalFinding>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStatisticalFindingById(findingId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of statistical findings.
         * @summary Get statistical findings
         * @param {string | null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, flagged, topic_1, topic_2, variable_1.id, variable_2.id, study.id, study.doi, statistic_type.
         * @param {string | null} [sort] Field to sort the response by. Supported fields for sorting: none.
         * @param {string | null} [search] Field to search within. Supported fields for searching: none.
         * @param {string | null} [fields] Comma-separated list of fields to include in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStatisticalFindings(filter?: string | null, sort?: string | null, search?: string | null, fields?: string | null, offset?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListResponseStatisticalFinding>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStatisticalFindings(filter, sort, search, fields, offset, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StatisticalFindingsApi - factory interface
 * @export
 */
export const StatisticalFindingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StatisticalFindingsApiFp(configuration)
    return {
        /**
         * Flag a statistical finding for review.
         * @summary Flag statistical finding
         * @param {string} findingId 
         * @param {Array<FlagInput>} flagInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        flagStatisticalFinding(findingId: string, flagInput: Array<FlagInput>, options?: any): AxiosPromise<Array<Flag>> {
            return localVarFp.flagStatisticalFinding(findingId, flagInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a statistical finding by its ID.
         * @summary Get a statistical finding
         * @param {string} findingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatisticalFindingById(findingId: string, options?: any): AxiosPromise<StatisticalFinding> {
            return localVarFp.getStatisticalFindingById(findingId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of statistical findings.
         * @summary Get statistical findings
         * @param {string | null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, flagged, topic_1, topic_2, variable_1.id, variable_2.id, study.id, study.doi, statistic_type.
         * @param {string | null} [sort] Field to sort the response by. Supported fields for sorting: none.
         * @param {string | null} [search] Field to search within. Supported fields for searching: none.
         * @param {string | null} [fields] Comma-separated list of fields to include in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatisticalFindings(filter?: string | null, sort?: string | null, search?: string | null, fields?: string | null, offset?: number, limit?: number, options?: any): AxiosPromise<ListResponseStatisticalFinding> {
            return localVarFp.getStatisticalFindings(filter, sort, search, fields, offset, limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StatisticalFindingsApi - object-oriented interface
 * @export
 * @class StatisticalFindingsApi
 * @extends {BaseAPI}
 */
export class StatisticalFindingsApi extends BaseAPI {
    /**
     * Flag a statistical finding for review.
     * @summary Flag statistical finding
     * @param {string} findingId 
     * @param {Array<FlagInput>} flagInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatisticalFindingsApi
     */
    public flagStatisticalFinding(findingId: string, flagInput: Array<FlagInput>, options?: AxiosRequestConfig) {
        return StatisticalFindingsApiFp(this.configuration).flagStatisticalFinding(findingId, flagInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a statistical finding by its ID.
     * @summary Get a statistical finding
     * @param {string} findingId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatisticalFindingsApi
     */
    public getStatisticalFindingById(findingId: string, options?: AxiosRequestConfig) {
        return StatisticalFindingsApiFp(this.configuration).getStatisticalFindingById(findingId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of statistical findings.
     * @summary Get statistical findings
     * @param {string | null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, flagged, topic_1, topic_2, variable_1.id, variable_2.id, study.id, study.doi, statistic_type.
     * @param {string | null} [sort] Field to sort the response by. Supported fields for sorting: none.
     * @param {string | null} [search] Field to search within. Supported fields for searching: none.
     * @param {string | null} [fields] Comma-separated list of fields to include in the response.
     * @param {number} [offset] Offset
     * @param {number} [limit] Limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatisticalFindingsApi
     */
    public getStatisticalFindings(filter?: string | null, sort?: string | null, search?: string | null, fields?: string | null, offset?: number, limit?: number, options?: AxiosRequestConfig) {
        return StatisticalFindingsApiFp(this.configuration).getStatisticalFindings(filter, sort, search, fields, offset, limit, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * StudiesApi - axios parameter creator
 * @export
 */
export const StudiesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a list of studies.
         * @summary Get studies
         * @param {string | null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, doi, publish_date, cited_by, study_type.
         * @param {string | null} [sort] Field to sort the response by. Supported fields for sorting: publish_date, sample_size, cited_by.
         * @param {string | null} [search] Field to search within. Supported fields for searching: title.
         * @param {string | null} [fields] Comma-separated list of fields to include in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudies: async (filter?: string | null, sort?: string | null, search?: string | null, fields?: string | null, offset?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v0/studies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a study by its ID.
         * @summary Get a study
         * @param {string} studyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudyById: async (studyId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'studyId' is not null or undefined
            assertParamExists('getStudyById', 'studyId', studyId)
            const localVarPath = `/v0/studies/{study_id}`
                .replace(`{${"study_id"}}`, encodeURIComponent(String(studyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of the statistical findings reported by a given study.
         * @summary Get study statistical findings
         * @param {string} studyId 
         * @param {string | null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, flagged, topic_1, topic_2, variable_1.id, variable_2.id, study.id, study.doi, statistic_type.
         * @param {string | null} [sort] Field to sort the response by. Supported fields for sorting: none.
         * @param {string | null} [search] Field to search within. Supported fields for searching: none.
         * @param {string | null} [fields] Comma-separated list of fields to include in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudyStatisticalFindings: async (studyId: string, filter?: string | null, sort?: string | null, search?: string | null, fields?: string | null, offset?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'studyId' is not null or undefined
            assertParamExists('getStudyStatisticalFindings', 'studyId', studyId)
            const localVarPath = `/v0/studies/{study_id}/statistical_findings`
                .replace(`{${"study_id"}}`, encodeURIComponent(String(studyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StudiesApi - functional programming interface
 * @export
 */
export const StudiesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StudiesApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a list of studies.
         * @summary Get studies
         * @param {string | null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, doi, publish_date, cited_by, study_type.
         * @param {string | null} [sort] Field to sort the response by. Supported fields for sorting: publish_date, sample_size, cited_by.
         * @param {string | null} [search] Field to search within. Supported fields for searching: title.
         * @param {string | null} [fields] Comma-separated list of fields to include in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStudies(filter?: string | null, sort?: string | null, search?: string | null, fields?: string | null, offset?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListResponseStudy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStudies(filter, sort, search, fields, offset, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a study by its ID.
         * @summary Get a study
         * @param {string} studyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStudyById(studyId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Study>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStudyById(studyId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of the statistical findings reported by a given study.
         * @summary Get study statistical findings
         * @param {string} studyId 
         * @param {string | null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, flagged, topic_1, topic_2, variable_1.id, variable_2.id, study.id, study.doi, statistic_type.
         * @param {string | null} [sort] Field to sort the response by. Supported fields for sorting: none.
         * @param {string | null} [search] Field to search within. Supported fields for searching: none.
         * @param {string | null} [fields] Comma-separated list of fields to include in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStudyStatisticalFindings(studyId: string, filter?: string | null, sort?: string | null, search?: string | null, fields?: string | null, offset?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListResponseStatisticalFinding>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStudyStatisticalFindings(studyId, filter, sort, search, fields, offset, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StudiesApi - factory interface
 * @export
 */
export const StudiesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StudiesApiFp(configuration)
    return {
        /**
         * Get a list of studies.
         * @summary Get studies
         * @param {string | null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, doi, publish_date, cited_by, study_type.
         * @param {string | null} [sort] Field to sort the response by. Supported fields for sorting: publish_date, sample_size, cited_by.
         * @param {string | null} [search] Field to search within. Supported fields for searching: title.
         * @param {string | null} [fields] Comma-separated list of fields to include in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudies(filter?: string | null, sort?: string | null, search?: string | null, fields?: string | null, offset?: number, limit?: number, options?: any): AxiosPromise<ListResponseStudy> {
            return localVarFp.getStudies(filter, sort, search, fields, offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a study by its ID.
         * @summary Get a study
         * @param {string} studyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudyById(studyId: string, options?: any): AxiosPromise<Study> {
            return localVarFp.getStudyById(studyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of the statistical findings reported by a given study.
         * @summary Get study statistical findings
         * @param {string} studyId 
         * @param {string | null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, flagged, topic_1, topic_2, variable_1.id, variable_2.id, study.id, study.doi, statistic_type.
         * @param {string | null} [sort] Field to sort the response by. Supported fields for sorting: none.
         * @param {string | null} [search] Field to search within. Supported fields for searching: none.
         * @param {string | null} [fields] Comma-separated list of fields to include in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudyStatisticalFindings(studyId: string, filter?: string | null, sort?: string | null, search?: string | null, fields?: string | null, offset?: number, limit?: number, options?: any): AxiosPromise<ListResponseStatisticalFinding> {
            return localVarFp.getStudyStatisticalFindings(studyId, filter, sort, search, fields, offset, limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StudiesApi - object-oriented interface
 * @export
 * @class StudiesApi
 * @extends {BaseAPI}
 */
export class StudiesApi extends BaseAPI {
    /**
     * Get a list of studies.
     * @summary Get studies
     * @param {string | null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, doi, publish_date, cited_by, study_type.
     * @param {string | null} [sort] Field to sort the response by. Supported fields for sorting: publish_date, sample_size, cited_by.
     * @param {string | null} [search] Field to search within. Supported fields for searching: title.
     * @param {string | null} [fields] Comma-separated list of fields to include in the response.
     * @param {number} [offset] Offset
     * @param {number} [limit] Limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudiesApi
     */
    public getStudies(filter?: string | null, sort?: string | null, search?: string | null, fields?: string | null, offset?: number, limit?: number, options?: AxiosRequestConfig) {
        return StudiesApiFp(this.configuration).getStudies(filter, sort, search, fields, offset, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a study by its ID.
     * @summary Get a study
     * @param {string} studyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudiesApi
     */
    public getStudyById(studyId: string, options?: AxiosRequestConfig) {
        return StudiesApiFp(this.configuration).getStudyById(studyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of the statistical findings reported by a given study.
     * @summary Get study statistical findings
     * @param {string} studyId 
     * @param {string | null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, flagged, topic_1, topic_2, variable_1.id, variable_2.id, study.id, study.doi, statistic_type.
     * @param {string | null} [sort] Field to sort the response by. Supported fields for sorting: none.
     * @param {string | null} [search] Field to search within. Supported fields for searching: none.
     * @param {string | null} [fields] Comma-separated list of fields to include in the response.
     * @param {number} [offset] Offset
     * @param {number} [limit] Limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudiesApi
     */
    public getStudyStatisticalFindings(studyId: string, filter?: string | null, sort?: string | null, search?: string | null, fields?: string | null, offset?: number, limit?: number, options?: AxiosRequestConfig) {
        return StudiesApiFp(this.configuration).getStudyStatisticalFindings(studyId, filter, sort, search, fields, offset, limit, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SynthesisApi - axios parameter creator
 * @export
 */
export const SynthesisApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get clusters from pubmed search synthesis.
         * @summary Get clusters from pubmed search synthesis
         * @param {string} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClustersFromPubmedSearch: async (jobId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('getClustersFromPubmedSearch', 'jobId', jobId)
            const localVarPath = `/v0/synthesis/pubmed_search/{job_id}/clusters`
                .replace(`{${"job_id"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get statistical findings from pubmed search synthesis.
         * @summary Get statistical findings from pubmed search synthesis
         * @param {string} jobId 
         * @param {string | null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, flagged, topic_1, topic_2, variable_1.id, variable_2.id, study.id, study.doi, statistic_type.
         * @param {string | null} [sort] Field to sort the response by. Supported fields for sorting: none.
         * @param {string | null} [search] Field to search within. Supported fields for searching: none.
         * @param {string | null} [fields] Comma-separated list of fields to include in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatisticalFindingsFromPubmedSearch: async (jobId: string, filter?: string | null, sort?: string | null, search?: string | null, fields?: string | null, offset?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('getStatisticalFindingsFromPubmedSearch', 'jobId', jobId)
            const localVarPath = `/v0/synthesis/pubmed_search/{job_id}/statistical_findings`
                .replace(`{${"job_id"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get studies from pubmed search synthesis.
         * @summary Get studies from pubmed search synthesis
         * @param {string} jobId 
         * @param {string | null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, doi, publish_date, cited_by, study_type.
         * @param {string | null} [sort] Field to sort the response by. Supported fields for sorting: publish_date, sample_size, cited_by.
         * @param {string | null} [search] Field to search within. Supported fields for searching: title.
         * @param {string | null} [fields] Comma-separated list of fields to include in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudiesFromPubmedSearch: async (jobId: string, filter?: string | null, sort?: string | null, search?: string | null, fields?: string | null, offset?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('getStudiesFromPubmedSearch', 'jobId', jobId)
            const localVarPath = `/v0/synthesis/pubmed_search/{job_id}/studies`
                .replace(`{${"job_id"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get synthesis from pubmed search synthesis.
         * @summary Get synthesis from pubmed search synthesis
         * @param {string} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSynthesisFromPubmedSearch: async (jobId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('getSynthesisFromPubmedSearch', 'jobId', jobId)
            const localVarPath = `/v0/synthesis/pubmed_search/{job_id}/synthesis`
                .replace(`{${"job_id"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Initiate pubmed search synthesis.
         * @summary Initiate pubmed search synthesis
         * @param {PubmedSearchSynthesisInput} pubmedSearchSynthesisInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        synthesizePubmedSearch: async (pubmedSearchSynthesisInput: PubmedSearchSynthesisInput, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pubmedSearchSynthesisInput' is not null or undefined
            assertParamExists('synthesizePubmedSearch', 'pubmedSearchSynthesisInput', pubmedSearchSynthesisInput)
            const localVarPath = `/v0/synthesis/pubmed_search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pubmedSearchSynthesisInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SynthesisApi - functional programming interface
 * @export
 */
export const SynthesisApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SynthesisApiAxiosParamCreator(configuration)
    return {
        /**
         * Get clusters from pubmed search synthesis.
         * @summary Get clusters from pubmed search synthesis
         * @param {string} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getClustersFromPubmedSearch(jobId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListResponseCluster>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getClustersFromPubmedSearch(jobId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get statistical findings from pubmed search synthesis.
         * @summary Get statistical findings from pubmed search synthesis
         * @param {string} jobId 
         * @param {string | null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, flagged, topic_1, topic_2, variable_1.id, variable_2.id, study.id, study.doi, statistic_type.
         * @param {string | null} [sort] Field to sort the response by. Supported fields for sorting: none.
         * @param {string | null} [search] Field to search within. Supported fields for searching: none.
         * @param {string | null} [fields] Comma-separated list of fields to include in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStatisticalFindingsFromPubmedSearch(jobId: string, filter?: string | null, sort?: string | null, search?: string | null, fields?: string | null, offset?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListResponseStatisticalFinding>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStatisticalFindingsFromPubmedSearch(jobId, filter, sort, search, fields, offset, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get studies from pubmed search synthesis.
         * @summary Get studies from pubmed search synthesis
         * @param {string} jobId 
         * @param {string | null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, doi, publish_date, cited_by, study_type.
         * @param {string | null} [sort] Field to sort the response by. Supported fields for sorting: publish_date, sample_size, cited_by.
         * @param {string | null} [search] Field to search within. Supported fields for searching: title.
         * @param {string | null} [fields] Comma-separated list of fields to include in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStudiesFromPubmedSearch(jobId: string, filter?: string | null, sort?: string | null, search?: string | null, fields?: string | null, offset?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListResponseStudy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStudiesFromPubmedSearch(jobId, filter, sort, search, fields, offset, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get synthesis from pubmed search synthesis.
         * @summary Get synthesis from pubmed search synthesis
         * @param {string} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSynthesisFromPubmedSearch(jobId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSynthesisFromPubmedSearch(jobId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Initiate pubmed search synthesis.
         * @summary Initiate pubmed search synthesis
         * @param {PubmedSearchSynthesisInput} pubmedSearchSynthesisInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async synthesizePubmedSearch(pubmedSearchSynthesisInput: PubmedSearchSynthesisInput, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.synthesizePubmedSearch(pubmedSearchSynthesisInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SynthesisApi - factory interface
 * @export
 */
export const SynthesisApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SynthesisApiFp(configuration)
    return {
        /**
         * Get clusters from pubmed search synthesis.
         * @summary Get clusters from pubmed search synthesis
         * @param {string} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClustersFromPubmedSearch(jobId: string, options?: any): AxiosPromise<ListResponseCluster> {
            return localVarFp.getClustersFromPubmedSearch(jobId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get statistical findings from pubmed search synthesis.
         * @summary Get statistical findings from pubmed search synthesis
         * @param {string} jobId 
         * @param {string | null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, flagged, topic_1, topic_2, variable_1.id, variable_2.id, study.id, study.doi, statistic_type.
         * @param {string | null} [sort] Field to sort the response by. Supported fields for sorting: none.
         * @param {string | null} [search] Field to search within. Supported fields for searching: none.
         * @param {string | null} [fields] Comma-separated list of fields to include in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatisticalFindingsFromPubmedSearch(jobId: string, filter?: string | null, sort?: string | null, search?: string | null, fields?: string | null, offset?: number, limit?: number, options?: any): AxiosPromise<ListResponseStatisticalFinding> {
            return localVarFp.getStatisticalFindingsFromPubmedSearch(jobId, filter, sort, search, fields, offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get studies from pubmed search synthesis.
         * @summary Get studies from pubmed search synthesis
         * @param {string} jobId 
         * @param {string | null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, doi, publish_date, cited_by, study_type.
         * @param {string | null} [sort] Field to sort the response by. Supported fields for sorting: publish_date, sample_size, cited_by.
         * @param {string | null} [search] Field to search within. Supported fields for searching: title.
         * @param {string | null} [fields] Comma-separated list of fields to include in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudiesFromPubmedSearch(jobId: string, filter?: string | null, sort?: string | null, search?: string | null, fields?: string | null, offset?: number, limit?: number, options?: any): AxiosPromise<ListResponseStudy> {
            return localVarFp.getStudiesFromPubmedSearch(jobId, filter, sort, search, fields, offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get synthesis from pubmed search synthesis.
         * @summary Get synthesis from pubmed search synthesis
         * @param {string} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSynthesisFromPubmedSearch(jobId: string, options?: any): AxiosPromise<void> {
            return localVarFp.getSynthesisFromPubmedSearch(jobId, options).then((request) => request(axios, basePath));
        },
        /**
         * Initiate pubmed search synthesis.
         * @summary Initiate pubmed search synthesis
         * @param {PubmedSearchSynthesisInput} pubmedSearchSynthesisInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        synthesizePubmedSearch(pubmedSearchSynthesisInput: PubmedSearchSynthesisInput, options?: any): AxiosPromise<string> {
            return localVarFp.synthesizePubmedSearch(pubmedSearchSynthesisInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SynthesisApi - object-oriented interface
 * @export
 * @class SynthesisApi
 * @extends {BaseAPI}
 */
export class SynthesisApi extends BaseAPI {
    /**
     * Get clusters from pubmed search synthesis.
     * @summary Get clusters from pubmed search synthesis
     * @param {string} jobId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SynthesisApi
     */
    public getClustersFromPubmedSearch(jobId: string, options?: AxiosRequestConfig) {
        return SynthesisApiFp(this.configuration).getClustersFromPubmedSearch(jobId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get statistical findings from pubmed search synthesis.
     * @summary Get statistical findings from pubmed search synthesis
     * @param {string} jobId 
     * @param {string | null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, flagged, topic_1, topic_2, variable_1.id, variable_2.id, study.id, study.doi, statistic_type.
     * @param {string | null} [sort] Field to sort the response by. Supported fields for sorting: none.
     * @param {string | null} [search] Field to search within. Supported fields for searching: none.
     * @param {string | null} [fields] Comma-separated list of fields to include in the response.
     * @param {number} [offset] Offset
     * @param {number} [limit] Limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SynthesisApi
     */
    public getStatisticalFindingsFromPubmedSearch(jobId: string, filter?: string | null, sort?: string | null, search?: string | null, fields?: string | null, offset?: number, limit?: number, options?: AxiosRequestConfig) {
        return SynthesisApiFp(this.configuration).getStatisticalFindingsFromPubmedSearch(jobId, filter, sort, search, fields, offset, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get studies from pubmed search synthesis.
     * @summary Get studies from pubmed search synthesis
     * @param {string} jobId 
     * @param {string | null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, doi, publish_date, cited_by, study_type.
     * @param {string | null} [sort] Field to sort the response by. Supported fields for sorting: publish_date, sample_size, cited_by.
     * @param {string | null} [search] Field to search within. Supported fields for searching: title.
     * @param {string | null} [fields] Comma-separated list of fields to include in the response.
     * @param {number} [offset] Offset
     * @param {number} [limit] Limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SynthesisApi
     */
    public getStudiesFromPubmedSearch(jobId: string, filter?: string | null, sort?: string | null, search?: string | null, fields?: string | null, offset?: number, limit?: number, options?: AxiosRequestConfig) {
        return SynthesisApiFp(this.configuration).getStudiesFromPubmedSearch(jobId, filter, sort, search, fields, offset, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get synthesis from pubmed search synthesis.
     * @summary Get synthesis from pubmed search synthesis
     * @param {string} jobId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SynthesisApi
     */
    public getSynthesisFromPubmedSearch(jobId: string, options?: AxiosRequestConfig) {
        return SynthesisApiFp(this.configuration).getSynthesisFromPubmedSearch(jobId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Initiate pubmed search synthesis.
     * @summary Initiate pubmed search synthesis
     * @param {PubmedSearchSynthesisInput} pubmedSearchSynthesisInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SynthesisApi
     */
    public synthesizePubmedSearch(pubmedSearchSynthesisInput: PubmedSearchSynthesisInput, options?: AxiosRequestConfig) {
        return SynthesisApiFp(this.configuration).synthesizePubmedSearch(pubmedSearchSynthesisInput, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TopicsApi - axios parameter creator
 * @export
 */
export const TopicsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a topic by its ID.
         * @summary Get a topic
         * @param {string} topicId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTopicById: async (topicId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'topicId' is not null or undefined
            assertParamExists('getTopicById', 'topicId', topicId)
            const localVarPath = `/v0/topics/{topic_id}`
                .replace(`{${"topic_id"}}`, encodeURIComponent(String(topicId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of determinants for a given topic. These are formatted as `TopicPath`s, which include data about the relationship and the source topic.
         * @summary Get topic determinants
         * @param {string} topicId 
         * @param {string | null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial, topic.id, topic.wikidata_id, topic.category, topic.roles.
         * @param {string | null} [sort] Field to sort the response by. Supported fields for sorting: num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial.
         * @param {string | null} [search] Field to search within. Supported fields for searching: none.
         * @param {string | null} [fields] Comma-separated list of fields to include in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTopicDeterminants: async (topicId: string, filter?: string | null, sort?: string | null, search?: string | null, fields?: string | null, offset?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'topicId' is not null or undefined
            assertParamExists('getTopicDeterminants', 'topicId', topicId)
            const localVarPath = `/v0/topics/{topic_id}/determinants`
                .replace(`{${"topic_id"}}`, encodeURIComponent(String(topicId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of interventions for a given topic. These are formatted as `TopicPath`s, which include data about the relationship and the source topic.
         * @summary Get topic interventions
         * @param {string} topicId 
         * @param {string | null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial, topic.id, topic.wikidata_id, topic.category, topic.roles.
         * @param {string | null} [sort] Field to sort the response by. Supported fields for sorting: num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial.
         * @param {string | null} [search] Field to search within. Supported fields for searching: none.
         * @param {string | null} [fields] Comma-separated list of fields to include in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTopicInterventions: async (topicId: string, filter?: string | null, sort?: string | null, search?: string | null, fields?: string | null, offset?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'topicId' is not null or undefined
            assertParamExists('getTopicInterventions', 'topicId', topicId)
            const localVarPath = `/v0/topics/{topic_id}/interventions`
                .replace(`{${"topic_id"}}`, encodeURIComponent(String(topicId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of outcomes for a given topic. These are formatted as `TopicPath`s, which include data about the relationship and the target topic.
         * @summary Get topic outcomes
         * @param {string} topicId 
         * @param {string | null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial, topic.id, topic.wikidata_id, topic.category, topic.roles.
         * @param {string | null} [sort] Field to sort the response by. Supported fields for sorting: num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial.
         * @param {string | null} [search] Field to search within. Supported fields for searching: none.
         * @param {string | null} [fields] Comma-separated list of fields to include in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTopicOutcomes: async (topicId: string, filter?: string | null, sort?: string | null, search?: string | null, fields?: string | null, offset?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'topicId' is not null or undefined
            assertParamExists('getTopicOutcomes', 'topicId', topicId)
            const localVarPath = `/v0/topics/{topic_id}/outcomes`
                .replace(`{${"topic_id"}}`, encodeURIComponent(String(topicId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of the relationships that include a given topic as the source or target topic.
         * @summary Get topic relationships
         * @param {string} topicId 
         * @param {string | null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial, source_topic.id, source_topic.wikidata_id, source_topic.category, source_topic.roles, target_topic.id, target_topic.wikidata_id, target_topic.category, target_topic.roles.
         * @param {string | null} [sort] Field to sort the response by. Supported fields for sorting: num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial.
         * @param {string | null} [search] Field to search within. Supported fields for searching: none.
         * @param {string | null} [fields] Comma-separated list of fields to include in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTopicRelationships: async (topicId: string, filter?: string | null, sort?: string | null, search?: string | null, fields?: string | null, offset?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'topicId' is not null or undefined
            assertParamExists('getTopicRelationships', 'topicId', topicId)
            const localVarPath = `/v0/topics/{topic_id}/relationships`
                .replace(`{${"topic_id"}}`, encodeURIComponent(String(topicId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of the variables that have been matched to a given topic.
         * @summary Get topic variables
         * @param {string} topicId 
         * @param {string | null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, num_studies, topic.
         * @param {string | null} [sort] Field to sort the response by. Supported fields for sorting: num_studies.
         * @param {string | null} [search] Field to search within. Supported fields for searching: name.
         * @param {string | null} [fields] Comma-separated list of fields to include in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTopicVariables: async (topicId: string, filter?: string | null, sort?: string | null, search?: string | null, fields?: string | null, offset?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'topicId' is not null or undefined
            assertParamExists('getTopicVariables', 'topicId', topicId)
            const localVarPath = `/v0/topics/{topic_id}/variables`
                .replace(`{${"topic_id"}}`, encodeURIComponent(String(topicId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of topics.
         * @summary Get topics
         * @param {string | null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, wikidata_id, category, roles.
         * @param {string | null} [sort] Field to sort the response by. Supported fields for sorting: none.
         * @param {string | null} [search] Field to search within. Supported fields for searching: name.
         * @param {string | null} [fields] Comma-separated list of fields to include in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTopics: async (filter?: string | null, sort?: string | null, search?: string | null, fields?: string | null, offset?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v0/topics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TopicsApi - functional programming interface
 * @export
 */
export const TopicsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TopicsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a topic by its ID.
         * @summary Get a topic
         * @param {string} topicId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTopicById(topicId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Topic>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTopicById(topicId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of determinants for a given topic. These are formatted as `TopicPath`s, which include data about the relationship and the source topic.
         * @summary Get topic determinants
         * @param {string} topicId 
         * @param {string | null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial, topic.id, topic.wikidata_id, topic.category, topic.roles.
         * @param {string | null} [sort] Field to sort the response by. Supported fields for sorting: num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial.
         * @param {string | null} [search] Field to search within. Supported fields for searching: none.
         * @param {string | null} [fields] Comma-separated list of fields to include in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTopicDeterminants(topicId: string, filter?: string | null, sort?: string | null, search?: string | null, fields?: string | null, offset?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListResponseTopicPath>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTopicDeterminants(topicId, filter, sort, search, fields, offset, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of interventions for a given topic. These are formatted as `TopicPath`s, which include data about the relationship and the source topic.
         * @summary Get topic interventions
         * @param {string} topicId 
         * @param {string | null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial, topic.id, topic.wikidata_id, topic.category, topic.roles.
         * @param {string | null} [sort] Field to sort the response by. Supported fields for sorting: num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial.
         * @param {string | null} [search] Field to search within. Supported fields for searching: none.
         * @param {string | null} [fields] Comma-separated list of fields to include in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTopicInterventions(topicId: string, filter?: string | null, sort?: string | null, search?: string | null, fields?: string | null, offset?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListResponseTopicPath>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTopicInterventions(topicId, filter, sort, search, fields, offset, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of outcomes for a given topic. These are formatted as `TopicPath`s, which include data about the relationship and the target topic.
         * @summary Get topic outcomes
         * @param {string} topicId 
         * @param {string | null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial, topic.id, topic.wikidata_id, topic.category, topic.roles.
         * @param {string | null} [sort] Field to sort the response by. Supported fields for sorting: num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial.
         * @param {string | null} [search] Field to search within. Supported fields for searching: none.
         * @param {string | null} [fields] Comma-separated list of fields to include in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTopicOutcomes(topicId: string, filter?: string | null, sort?: string | null, search?: string | null, fields?: string | null, offset?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListResponseTopicPath>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTopicOutcomes(topicId, filter, sort, search, fields, offset, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of the relationships that include a given topic as the source or target topic.
         * @summary Get topic relationships
         * @param {string} topicId 
         * @param {string | null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial, source_topic.id, source_topic.wikidata_id, source_topic.category, source_topic.roles, target_topic.id, target_topic.wikidata_id, target_topic.category, target_topic.roles.
         * @param {string | null} [sort] Field to sort the response by. Supported fields for sorting: num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial.
         * @param {string | null} [search] Field to search within. Supported fields for searching: none.
         * @param {string | null} [fields] Comma-separated list of fields to include in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTopicRelationships(topicId: string, filter?: string | null, sort?: string | null, search?: string | null, fields?: string | null, offset?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListResponseRelationship>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTopicRelationships(topicId, filter, sort, search, fields, offset, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of the variables that have been matched to a given topic.
         * @summary Get topic variables
         * @param {string} topicId 
         * @param {string | null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, num_studies, topic.
         * @param {string | null} [sort] Field to sort the response by. Supported fields for sorting: num_studies.
         * @param {string | null} [search] Field to search within. Supported fields for searching: name.
         * @param {string | null} [fields] Comma-separated list of fields to include in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTopicVariables(topicId: string, filter?: string | null, sort?: string | null, search?: string | null, fields?: string | null, offset?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListResponseVariable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTopicVariables(topicId, filter, sort, search, fields, offset, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of topics.
         * @summary Get topics
         * @param {string | null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, wikidata_id, category, roles.
         * @param {string | null} [sort] Field to sort the response by. Supported fields for sorting: none.
         * @param {string | null} [search] Field to search within. Supported fields for searching: name.
         * @param {string | null} [fields] Comma-separated list of fields to include in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTopics(filter?: string | null, sort?: string | null, search?: string | null, fields?: string | null, offset?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListResponseTopic>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTopics(filter, sort, search, fields, offset, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TopicsApi - factory interface
 * @export
 */
export const TopicsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TopicsApiFp(configuration)
    return {
        /**
         * Get a topic by its ID.
         * @summary Get a topic
         * @param {string} topicId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTopicById(topicId: string, options?: any): AxiosPromise<Topic> {
            return localVarFp.getTopicById(topicId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of determinants for a given topic. These are formatted as `TopicPath`s, which include data about the relationship and the source topic.
         * @summary Get topic determinants
         * @param {string} topicId 
         * @param {string | null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial, topic.id, topic.wikidata_id, topic.category, topic.roles.
         * @param {string | null} [sort] Field to sort the response by. Supported fields for sorting: num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial.
         * @param {string | null} [search] Field to search within. Supported fields for searching: none.
         * @param {string | null} [fields] Comma-separated list of fields to include in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTopicDeterminants(topicId: string, filter?: string | null, sort?: string | null, search?: string | null, fields?: string | null, offset?: number, limit?: number, options?: any): AxiosPromise<ListResponseTopicPath> {
            return localVarFp.getTopicDeterminants(topicId, filter, sort, search, fields, offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of interventions for a given topic. These are formatted as `TopicPath`s, which include data about the relationship and the source topic.
         * @summary Get topic interventions
         * @param {string} topicId 
         * @param {string | null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial, topic.id, topic.wikidata_id, topic.category, topic.roles.
         * @param {string | null} [sort] Field to sort the response by. Supported fields for sorting: num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial.
         * @param {string | null} [search] Field to search within. Supported fields for searching: none.
         * @param {string | null} [fields] Comma-separated list of fields to include in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTopicInterventions(topicId: string, filter?: string | null, sort?: string | null, search?: string | null, fields?: string | null, offset?: number, limit?: number, options?: any): AxiosPromise<ListResponseTopicPath> {
            return localVarFp.getTopicInterventions(topicId, filter, sort, search, fields, offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of outcomes for a given topic. These are formatted as `TopicPath`s, which include data about the relationship and the target topic.
         * @summary Get topic outcomes
         * @param {string} topicId 
         * @param {string | null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial, topic.id, topic.wikidata_id, topic.category, topic.roles.
         * @param {string | null} [sort] Field to sort the response by. Supported fields for sorting: num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial.
         * @param {string | null} [search] Field to search within. Supported fields for searching: none.
         * @param {string | null} [fields] Comma-separated list of fields to include in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTopicOutcomes(topicId: string, filter?: string | null, sort?: string | null, search?: string | null, fields?: string | null, offset?: number, limit?: number, options?: any): AxiosPromise<ListResponseTopicPath> {
            return localVarFp.getTopicOutcomes(topicId, filter, sort, search, fields, offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of the relationships that include a given topic as the source or target topic.
         * @summary Get topic relationships
         * @param {string} topicId 
         * @param {string | null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial, source_topic.id, source_topic.wikidata_id, source_topic.category, source_topic.roles, target_topic.id, target_topic.wikidata_id, target_topic.category, target_topic.roles.
         * @param {string | null} [sort] Field to sort the response by. Supported fields for sorting: num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial.
         * @param {string | null} [search] Field to search within. Supported fields for searching: none.
         * @param {string | null} [fields] Comma-separated list of fields to include in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTopicRelationships(topicId: string, filter?: string | null, sort?: string | null, search?: string | null, fields?: string | null, offset?: number, limit?: number, options?: any): AxiosPromise<ListResponseRelationship> {
            return localVarFp.getTopicRelationships(topicId, filter, sort, search, fields, offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of the variables that have been matched to a given topic.
         * @summary Get topic variables
         * @param {string} topicId 
         * @param {string | null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, num_studies, topic.
         * @param {string | null} [sort] Field to sort the response by. Supported fields for sorting: num_studies.
         * @param {string | null} [search] Field to search within. Supported fields for searching: name.
         * @param {string | null} [fields] Comma-separated list of fields to include in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTopicVariables(topicId: string, filter?: string | null, sort?: string | null, search?: string | null, fields?: string | null, offset?: number, limit?: number, options?: any): AxiosPromise<ListResponseVariable> {
            return localVarFp.getTopicVariables(topicId, filter, sort, search, fields, offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of topics.
         * @summary Get topics
         * @param {string | null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, wikidata_id, category, roles.
         * @param {string | null} [sort] Field to sort the response by. Supported fields for sorting: none.
         * @param {string | null} [search] Field to search within. Supported fields for searching: name.
         * @param {string | null} [fields] Comma-separated list of fields to include in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTopics(filter?: string | null, sort?: string | null, search?: string | null, fields?: string | null, offset?: number, limit?: number, options?: any): AxiosPromise<ListResponseTopic> {
            return localVarFp.getTopics(filter, sort, search, fields, offset, limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TopicsApi - object-oriented interface
 * @export
 * @class TopicsApi
 * @extends {BaseAPI}
 */
export class TopicsApi extends BaseAPI {
    /**
     * Get a topic by its ID.
     * @summary Get a topic
     * @param {string} topicId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TopicsApi
     */
    public getTopicById(topicId: string, options?: AxiosRequestConfig) {
        return TopicsApiFp(this.configuration).getTopicById(topicId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of determinants for a given topic. These are formatted as `TopicPath`s, which include data about the relationship and the source topic.
     * @summary Get topic determinants
     * @param {string} topicId 
     * @param {string | null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial, topic.id, topic.wikidata_id, topic.category, topic.roles.
     * @param {string | null} [sort] Field to sort the response by. Supported fields for sorting: num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial.
     * @param {string | null} [search] Field to search within. Supported fields for searching: none.
     * @param {string | null} [fields] Comma-separated list of fields to include in the response.
     * @param {number} [offset] Offset
     * @param {number} [limit] Limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TopicsApi
     */
    public getTopicDeterminants(topicId: string, filter?: string | null, sort?: string | null, search?: string | null, fields?: string | null, offset?: number, limit?: number, options?: AxiosRequestConfig) {
        return TopicsApiFp(this.configuration).getTopicDeterminants(topicId, filter, sort, search, fields, offset, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of interventions for a given topic. These are formatted as `TopicPath`s, which include data about the relationship and the source topic.
     * @summary Get topic interventions
     * @param {string} topicId 
     * @param {string | null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial, topic.id, topic.wikidata_id, topic.category, topic.roles.
     * @param {string | null} [sort] Field to sort the response by. Supported fields for sorting: num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial.
     * @param {string | null} [search] Field to search within. Supported fields for searching: none.
     * @param {string | null} [fields] Comma-separated list of fields to include in the response.
     * @param {number} [offset] Offset
     * @param {number} [limit] Limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TopicsApi
     */
    public getTopicInterventions(topicId: string, filter?: string | null, sort?: string | null, search?: string | null, fields?: string | null, offset?: number, limit?: number, options?: AxiosRequestConfig) {
        return TopicsApiFp(this.configuration).getTopicInterventions(topicId, filter, sort, search, fields, offset, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of outcomes for a given topic. These are formatted as `TopicPath`s, which include data about the relationship and the target topic.
     * @summary Get topic outcomes
     * @param {string} topicId 
     * @param {string | null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial, topic.id, topic.wikidata_id, topic.category, topic.roles.
     * @param {string | null} [sort] Field to sort the response by. Supported fields for sorting: num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial.
     * @param {string | null} [search] Field to search within. Supported fields for searching: none.
     * @param {string | null} [fields] Comma-separated list of fields to include in the response.
     * @param {number} [offset] Offset
     * @param {number} [limit] Limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TopicsApi
     */
    public getTopicOutcomes(topicId: string, filter?: string | null, sort?: string | null, search?: string | null, fields?: string | null, offset?: number, limit?: number, options?: AxiosRequestConfig) {
        return TopicsApiFp(this.configuration).getTopicOutcomes(topicId, filter, sort, search, fields, offset, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of the relationships that include a given topic as the source or target topic.
     * @summary Get topic relationships
     * @param {string} topicId 
     * @param {string | null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial, source_topic.id, source_topic.wikidata_id, source_topic.category, source_topic.roles, target_topic.id, target_topic.wikidata_id, target_topic.category, target_topic.roles.
     * @param {string | null} [sort] Field to sort the response by. Supported fields for sorting: num_findings, num_studies, num_significant_findings, highest_cited, median_effect_size, last_updated, has_experimental_trial.
     * @param {string | null} [search] Field to search within. Supported fields for searching: none.
     * @param {string | null} [fields] Comma-separated list of fields to include in the response.
     * @param {number} [offset] Offset
     * @param {number} [limit] Limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TopicsApi
     */
    public getTopicRelationships(topicId: string, filter?: string | null, sort?: string | null, search?: string | null, fields?: string | null, offset?: number, limit?: number, options?: AxiosRequestConfig) {
        return TopicsApiFp(this.configuration).getTopicRelationships(topicId, filter, sort, search, fields, offset, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of the variables that have been matched to a given topic.
     * @summary Get topic variables
     * @param {string} topicId 
     * @param {string | null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, num_studies, topic.
     * @param {string | null} [sort] Field to sort the response by. Supported fields for sorting: num_studies.
     * @param {string | null} [search] Field to search within. Supported fields for searching: name.
     * @param {string | null} [fields] Comma-separated list of fields to include in the response.
     * @param {number} [offset] Offset
     * @param {number} [limit] Limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TopicsApi
     */
    public getTopicVariables(topicId: string, filter?: string | null, sort?: string | null, search?: string | null, fields?: string | null, offset?: number, limit?: number, options?: AxiosRequestConfig) {
        return TopicsApiFp(this.configuration).getTopicVariables(topicId, filter, sort, search, fields, offset, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of topics.
     * @summary Get topics
     * @param {string | null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, wikidata_id, category, roles.
     * @param {string | null} [sort] Field to sort the response by. Supported fields for sorting: none.
     * @param {string | null} [search] Field to search within. Supported fields for searching: name.
     * @param {string | null} [fields] Comma-separated list of fields to include in the response.
     * @param {number} [offset] Offset
     * @param {number} [limit] Limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TopicsApi
     */
    public getTopics(filter?: string | null, sort?: string | null, search?: string | null, fields?: string | null, offset?: number, limit?: number, options?: AxiosRequestConfig) {
        return TopicsApiFp(this.configuration).getTopics(filter, sort, search, fields, offset, limit, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VariablesApi - axios parameter creator
 * @export
 */
export const VariablesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a variable by its ID.
         * @summary Get a variable
         * @param {string} variableId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVariableById: async (variableId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'variableId' is not null or undefined
            assertParamExists('getVariableById', 'variableId', variableId)
            const localVarPath = `/v0/variables/{variable_id}`
                .replace(`{${"variable_id"}}`, encodeURIComponent(String(variableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of the statistical findings that include a given variable.
         * @summary Get variable statistical findings
         * @param {string} variableId 
         * @param {string | null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, flagged, topic_1, topic_2, variable_1.id, variable_2.id, study.id, study.doi, statistic_type.
         * @param {string | null} [sort] Field to sort the response by. Supported fields for sorting: none.
         * @param {string | null} [search] Field to search within. Supported fields for searching: none.
         * @param {string | null} [fields] Comma-separated list of fields to include in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVariableStatisticalFindings: async (variableId: string, filter?: string | null, sort?: string | null, search?: string | null, fields?: string | null, offset?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'variableId' is not null or undefined
            assertParamExists('getVariableStatisticalFindings', 'variableId', variableId)
            const localVarPath = `/v0/variables/{variable_id}/statistical_findings`
                .replace(`{${"variable_id"}}`, encodeURIComponent(String(variableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of variables.
         * @summary Get variables
         * @param {string | null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, num_studies, topic.
         * @param {string | null} [sort] Field to sort the response by. Supported fields for sorting: num_studies.
         * @param {string | null} [search] Field to search within. Supported fields for searching: name.
         * @param {string | null} [fields] Comma-separated list of fields to include in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVariables: async (filter?: string | null, sort?: string | null, search?: string | null, fields?: string | null, offset?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v0/variables`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VariablesApi - functional programming interface
 * @export
 */
export const VariablesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VariablesApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a variable by its ID.
         * @summary Get a variable
         * @param {string} variableId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVariableById(variableId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Variable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVariableById(variableId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of the statistical findings that include a given variable.
         * @summary Get variable statistical findings
         * @param {string} variableId 
         * @param {string | null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, flagged, topic_1, topic_2, variable_1.id, variable_2.id, study.id, study.doi, statistic_type.
         * @param {string | null} [sort] Field to sort the response by. Supported fields for sorting: none.
         * @param {string | null} [search] Field to search within. Supported fields for searching: none.
         * @param {string | null} [fields] Comma-separated list of fields to include in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVariableStatisticalFindings(variableId: string, filter?: string | null, sort?: string | null, search?: string | null, fields?: string | null, offset?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListResponseStatisticalFinding>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVariableStatisticalFindings(variableId, filter, sort, search, fields, offset, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of variables.
         * @summary Get variables
         * @param {string | null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, num_studies, topic.
         * @param {string | null} [sort] Field to sort the response by. Supported fields for sorting: num_studies.
         * @param {string | null} [search] Field to search within. Supported fields for searching: name.
         * @param {string | null} [fields] Comma-separated list of fields to include in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVariables(filter?: string | null, sort?: string | null, search?: string | null, fields?: string | null, offset?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListResponseVariable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVariables(filter, sort, search, fields, offset, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * VariablesApi - factory interface
 * @export
 */
export const VariablesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VariablesApiFp(configuration)
    return {
        /**
         * Get a variable by its ID.
         * @summary Get a variable
         * @param {string} variableId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVariableById(variableId: string, options?: any): AxiosPromise<Variable> {
            return localVarFp.getVariableById(variableId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of the statistical findings that include a given variable.
         * @summary Get variable statistical findings
         * @param {string} variableId 
         * @param {string | null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, flagged, topic_1, topic_2, variable_1.id, variable_2.id, study.id, study.doi, statistic_type.
         * @param {string | null} [sort] Field to sort the response by. Supported fields for sorting: none.
         * @param {string | null} [search] Field to search within. Supported fields for searching: none.
         * @param {string | null} [fields] Comma-separated list of fields to include in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVariableStatisticalFindings(variableId: string, filter?: string | null, sort?: string | null, search?: string | null, fields?: string | null, offset?: number, limit?: number, options?: any): AxiosPromise<ListResponseStatisticalFinding> {
            return localVarFp.getVariableStatisticalFindings(variableId, filter, sort, search, fields, offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of variables.
         * @summary Get variables
         * @param {string | null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, num_studies, topic.
         * @param {string | null} [sort] Field to sort the response by. Supported fields for sorting: num_studies.
         * @param {string | null} [search] Field to search within. Supported fields for searching: name.
         * @param {string | null} [fields] Comma-separated list of fields to include in the response.
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVariables(filter?: string | null, sort?: string | null, search?: string | null, fields?: string | null, offset?: number, limit?: number, options?: any): AxiosPromise<ListResponseVariable> {
            return localVarFp.getVariables(filter, sort, search, fields, offset, limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VariablesApi - object-oriented interface
 * @export
 * @class VariablesApi
 * @extends {BaseAPI}
 */
export class VariablesApi extends BaseAPI {
    /**
     * Get a variable by its ID.
     * @summary Get a variable
     * @param {string} variableId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariablesApi
     */
    public getVariableById(variableId: string, options?: AxiosRequestConfig) {
        return VariablesApiFp(this.configuration).getVariableById(variableId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of the statistical findings that include a given variable.
     * @summary Get variable statistical findings
     * @param {string} variableId 
     * @param {string | null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, flagged, topic_1, topic_2, variable_1.id, variable_2.id, study.id, study.doi, statistic_type.
     * @param {string | null} [sort] Field to sort the response by. Supported fields for sorting: none.
     * @param {string | null} [search] Field to search within. Supported fields for searching: none.
     * @param {string | null} [fields] Comma-separated list of fields to include in the response.
     * @param {number} [offset] Offset
     * @param {number} [limit] Limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariablesApi
     */
    public getVariableStatisticalFindings(variableId: string, filter?: string | null, sort?: string | null, search?: string | null, fields?: string | null, offset?: number, limit?: number, options?: AxiosRequestConfig) {
        return VariablesApiFp(this.configuration).getVariableStatisticalFindings(variableId, filter, sort, search, fields, offset, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of variables.
     * @summary Get variables
     * @param {string | null} [filter] Fields and values to filter the response by. Supported fields for filtering: id, num_studies, topic.
     * @param {string | null} [sort] Field to sort the response by. Supported fields for sorting: num_studies.
     * @param {string | null} [search] Field to search within. Supported fields for searching: name.
     * @param {string | null} [fields] Comma-separated list of fields to include in the response.
     * @param {number} [offset] Offset
     * @param {number} [limit] Limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariablesApi
     */
    public getVariables(filter?: string | null, sort?: string | null, search?: string | null, fields?: string | null, offset?: number, limit?: number, options?: AxiosRequestConfig) {
        return VariablesApiFp(this.configuration).getVariables(filter, sort, search, fields, offset, limit, options).then((request) => request(this.axios, this.basePath));
    }
}



